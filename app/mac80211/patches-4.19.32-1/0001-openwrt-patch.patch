From 435a1a793327d3863f1c6d8cc3dade2891f69e68 Mon Sep 17 00:00:00 2001
From: Yuan Jianpeng <yuanjianpeng@360.cn>
Date: Thu, 5 Mar 2020 00:22:41 +0800
Subject: [PATCH] openwrt patch

---
 Kconfig.local                                 | 111 ---
 Kconfig.sources                               |   3 -
 Makefile                                      | 116 +--
 Makefile.kernel                               |   2 -
 Makefile.real                                 |   9 +-
 backport-include/linux/bcm47xx_nvram.h        |  25 -
 backport-include/linux/kconfig.h              |   5 +
 backport-include/linux/rfkill.h               |   6 +
 compat/main.c                                 |  25 -
 drivers/net/wireless/ath/Kconfig              |   5 +-
 drivers/net/wireless/ath/Makefile             |   2 +-
 drivers/net/wireless/ath/ath.h                |   8 +-
 drivers/net/wireless/ath/ath10k/Kconfig       |  16 +
 drivers/net/wireless/ath/ath10k/Makefile      |   3 +-
 drivers/net/wireless/ath/ath10k/core.c        |  31 +
 drivers/net/wireless/ath/ath10k/core.h        |  13 +-
 drivers/net/wireless/ath/ath10k/htt.h         |   2 +-
 drivers/net/wireless/ath/ath10k/hw.h          |   1 +
 drivers/net/wireless/ath/ath10k/leds.c        | 101 +++
 drivers/net/wireless/ath/ath10k/leds.h        |  41 +
 drivers/net/wireless/ath/ath10k/mac.c         | 136 +++-
 drivers/net/wireless/ath/ath10k/pci.c         |   8 +-
 drivers/net/wireless/ath/ath10k/thermal.h     |   2 +-
 drivers/net/wireless/ath/ath10k/wmi-ops.h     |  32 +
 drivers/net/wireless/ath/ath10k/wmi-tlv.c     |   2 +
 drivers/net/wireless/ath/ath10k/wmi.c         |  72 +-
 drivers/net/wireless/ath/ath10k/wmi.h         |  49 +-
 drivers/net/wireless/ath/ath5k/ath5k.h        |   1 +
 drivers/net/wireless/ath/ath5k/base.c         |   8 +-
 drivers/net/wireless/ath/ath5k/debug.c        |  93 +++
 drivers/net/wireless/ath/ath5k/dma.c          |   8 +
 drivers/net/wireless/ath/ath5k/initvals.c     |   6 +
 drivers/net/wireless/ath/ath5k/mac80211-ops.c |   9 +-
 drivers/net/wireless/ath/ath5k/pci.c          |  28 +-
 drivers/net/wireless/ath/ath5k/reset.c        |   2 +
 drivers/net/wireless/ath/ath9k/Kconfig        |  15 +-
 drivers/net/wireless/ath/ath9k/Makefile       |   1 +
 drivers/net/wireless/ath/ath9k/ahb.c          | 259 ++++++-
 drivers/net/wireless/ath/ath9k/ani.h          |   2 +-
 drivers/net/wireless/ath/ath9k/ar5008_phy.c   |  72 +-
 drivers/net/wireless/ath/ath9k/ar9002_phy.h   |  11 +
 drivers/net/wireless/ath/ath9k/ar9003_phy.c   |  95 +--
 drivers/net/wireless/ath/ath9k/ath9k.h        |  34 +-
 drivers/net/wireless/ath/ath9k/channel.c      |   8 +
 drivers/net/wireless/ath/ath9k/common.c       |  21 +-
 drivers/net/wireless/ath/ath9k/debug.c        | 202 +++++
 drivers/net/wireless/ath/ath9k/dynack.c       |  26 +-
 drivers/net/wireless/ath/ath9k/gpio.c         | 365 ++++++++-
 drivers/net/wireless/ath/ath9k/hsr.c          | 247 ++++++
 drivers/net/wireless/ath/ath9k/hsr.h          |  48 ++
 drivers/net/wireless/ath/ath9k/hw-ops.h       |   6 +
 drivers/net/wireless/ath/ath9k/hw.c           | 154 +++-
 drivers/net/wireless/ath/ath9k/hw.h           |  12 +
 drivers/net/wireless/ath/ath9k/init.c         |  40 +-
 drivers/net/wireless/ath/ath9k/mac.c          |   9 +-
 drivers/net/wireless/ath/ath9k/main.c         |  17 +-
 drivers/net/wireless/ath/ath9k/pci.c          |   1 +
 drivers/net/wireless/ath/ath9k/phy.h          |   3 +
 drivers/net/wireless/ath/ath9k/tx99.c         |  10 +-
 drivers/net/wireless/ath/regd.c               |  72 +-
 drivers/net/wireless/ath/regd.h               |   2 +
 drivers/net/wireless/ath/regd_common.h        |   5 +
 drivers/net/wireless/broadcom/b43/Kconfig     |  12 +-
 drivers/net/wireless/broadcom/b43/main.c      |   4 +-
 .../net/wireless/broadcom/b43legacy/Kconfig   |   8 +-
 .../net/wireless/broadcom/b43legacy/main.c    |   4 +-
 .../net/wireless/broadcom/brcm80211/Kconfig   |   2 +-
 .../broadcom/brcm80211/brcmsmac/Makefile      |   2 +-
 .../broadcom/brcm80211/brcmsmac/led.h         |   2 +-
 drivers/net/wireless/intel/ipw2x00/ipw2200.c  |  18 +-
 include/linux/ath5k_platform.h                |  30 +
 include/linux/ath9k_platform.h                |   9 +
 include/linux/bcma/bcma.h                     | 494 ------------
 include/linux/bcma/bcma_driver_arm_c9.h       |  16 -
 include/linux/bcma/bcma_driver_chipcommon.h   | 716 ------------------
 include/linux/bcma/bcma_driver_gmac_cmn.h     |  95 ---
 include/linux/bcma/bcma_driver_mips.h         |  45 --
 include/linux/bcma/bcma_driver_pci.h          | 264 -------
 include/linux/bcma/bcma_driver_pcie2.h        | 159 ----
 include/linux/bcma/bcma_regs.h                | 104 ---
 include/linux/bcma/bcma_soc.h                 |  17 -
 include/linux/ieee80211.h                     |   1 +
 include/linux/spi/libertas_spi.h              |  29 -
 include/linux/ssb/ssb.h                       | 682 -----------------
 include/linux/ssb/ssb_driver_chipcommon.h     | 673 ----------------
 include/linux/ssb/ssb_driver_extif.h          | 259 -------
 include/linux/ssb/ssb_driver_gige.h           | 194 -----
 include/linux/ssb/ssb_driver_mips.h           |  71 --
 include/linux/ssb/ssb_driver_pci.h            | 131 ----
 include/linux/ssb/ssb_embedded.h              |  19 -
 include/linux/ssb/ssb_regs.h                  | 687 -----------------
 include/linux/wl12xx.h                        |  58 --
 include/net/cfg80211.h                        |  16 +-
 include/net/fq_impl.h                         |  18 +-
 include/net/mac80211.h                        | 187 ++++-
 include/uapi/linux/nl80211.h                  |  37 +
 kconf/Makefile                                |   4 +-
 kconf/conf.c                                  |  30 +-
 kconf/confdata.c                              |   4 +-
 local-symbols                                 |  41 +-
 net/mac80211/Kconfig                          |  20 +-
 net/mac80211/Makefile                         |  14 +-
 net/mac80211/aead_api.h                       |  27 -
 net/mac80211/aes_ccm.c                        | 144 ++++
 net/mac80211/aes_ccm.h                        |  46 +-
 net/mac80211/aes_cmac.c                       | 126 ++-
 net/mac80211/aes_cmac.h                       |  11 +-
 net/mac80211/{aead_api.c => aes_gcm.c}        |  52 +-
 net/mac80211/aes_gcm.h                        |  30 +-
 net/mac80211/aes_gmac.h                       |  22 +-
 net/mac80211/agg-tx.c                         |   2 +-
 net/mac80211/cfg.c                            |  20 +-
 net/mac80211/debugfs.c                        |   5 +
 net/mac80211/debugfs_sta.c                    |  68 +-
 net/mac80211/driver-ops.h                     |  10 +
 net/mac80211/fils_aead.c                      |   2 +-
 net/mac80211/fils_aead.h                      |   2 +-
 net/mac80211/ieee80211_i.h                    |  19 +
 net/mac80211/iface.c                          |   5 +
 net/mac80211/key.h                            |   4 +-
 net/mac80211/main.c                           |  49 +-
 net/mac80211/mesh_hwmp.c                      |  26 +-
 net/mac80211/mesh_pathtbl.c                   |   8 +-
 net/mac80211/rate.h                           |  13 -
 net/mac80211/rc80211_minstrel.c               | 156 ----
 net/mac80211/rc80211_minstrel.h               |   9 -
 net/mac80211/rc80211_minstrel_debugfs.c       |  54 --
 net/mac80211/rc80211_minstrel_ht.c            | 325 +++++---
 net/mac80211/rc80211_minstrel_ht.h            |  20 +-
 net/mac80211/rc80211_minstrel_ht_debugfs.c    |  51 +-
 net/mac80211/rx.c                             |  22 +-
 net/mac80211/sta_info.c                       |  46 +-
 net/mac80211/sta_info.h                       |  15 +-
 net/mac80211/status.c                         |  27 +-
 net/mac80211/tkip.c                           |   4 +-
 net/mac80211/tx.c                             | 324 ++++++--
 net/mac80211/util.c                           | 119 ++-
 net/mac80211/wep.c                            |  11 +-
 net/mac80211/wep.h                            |   1 +
 net/mac80211/wme.c                            |  82 +-
 net/mac80211/wme.h                            |   2 +
 net/mac80211/wpa.c                            |  56 +-
 net/wireless/Kconfig                          |   8 +-
 net/wireless/core.c                           |   9 +-
 net/wireless/nl80211.c                        |  49 +-
 net/wireless/reg.c                            |   3 +
 net/wireless/sysfs.c                          |  27 +-
 147 files changed, 3862 insertions(+), 6143 deletions(-)
 delete mode 100644 backport-include/linux/bcm47xx_nvram.h
 create mode 100644 drivers/net/wireless/ath/ath10k/leds.c
 create mode 100644 drivers/net/wireless/ath/ath10k/leds.h
 create mode 100644 drivers/net/wireless/ath/ath9k/hsr.c
 create mode 100644 drivers/net/wireless/ath/ath9k/hsr.h
 create mode 100644 include/linux/ath5k_platform.h
 delete mode 100644 include/linux/bcma/bcma.h
 delete mode 100644 include/linux/bcma/bcma_driver_arm_c9.h
 delete mode 100644 include/linux/bcma/bcma_driver_chipcommon.h
 delete mode 100644 include/linux/bcma/bcma_driver_gmac_cmn.h
 delete mode 100644 include/linux/bcma/bcma_driver_mips.h
 delete mode 100644 include/linux/bcma/bcma_driver_pci.h
 delete mode 100644 include/linux/bcma/bcma_driver_pcie2.h
 delete mode 100644 include/linux/bcma/bcma_regs.h
 delete mode 100644 include/linux/bcma/bcma_soc.h
 delete mode 100644 include/linux/spi/libertas_spi.h
 delete mode 100644 include/linux/ssb/ssb.h
 delete mode 100644 include/linux/ssb/ssb_driver_chipcommon.h
 delete mode 100644 include/linux/ssb/ssb_driver_extif.h
 delete mode 100644 include/linux/ssb/ssb_driver_gige.h
 delete mode 100644 include/linux/ssb/ssb_driver_mips.h
 delete mode 100644 include/linux/ssb/ssb_driver_pci.h
 delete mode 100644 include/linux/ssb/ssb_embedded.h
 delete mode 100644 include/linux/ssb/ssb_regs.h
 delete mode 100644 include/linux/wl12xx.h
 delete mode 100644 net/mac80211/aead_api.h
 create mode 100644 net/mac80211/aes_ccm.c
 rename net/mac80211/{aead_api.c => aes_gcm.c} (54%)

diff --git a/Kconfig.local b/Kconfig.local
index f5b641d..7900095 100644
--- a/Kconfig.local
+++ b/Kconfig.local
@@ -1192,117 +1192,6 @@ config BACKPORTED_USB_VL600
 config BACKPORTED_USB_NET_CH9200
 	tristate
 	default USB_NET_CH9200
-config BACKPORTED_SSB_POSSIBLE
-	tristate
-	default SSB_POSSIBLE
-config BACKPORTED_SSB
-	tristate
-	default SSB
-config BACKPORTED_SSB_SPROM
-	tristate
-	default SSB_SPROM
-config BACKPORTED_SSB_BLOCKIO
-	tristate
-	default SSB_BLOCKIO
-config BACKPORTED_SSB_PCIHOST_POSSIBLE
-	tristate
-	default SSB_PCIHOST_POSSIBLE
-config BACKPORTED_SSB_PCIHOST
-	tristate
-	default SSB_PCIHOST
-config BACKPORTED_SSB_B43_PCI_BRIDGE
-	tristate
-	default SSB_B43_PCI_BRIDGE
-config BACKPORTED_SSB_PCMCIAHOST_POSSIBLE
-	tristate
-	default SSB_PCMCIAHOST_POSSIBLE
-config BACKPORTED_SSB_PCMCIAHOST
-	tristate
-	default SSB_PCMCIAHOST
-config BACKPORTED_SSB_SDIOHOST_POSSIBLE
-	tristate
-	default SSB_SDIOHOST_POSSIBLE
-config BACKPORTED_SSB_SDIOHOST
-	tristate
-	default SSB_SDIOHOST
-config BACKPORTED_SSB_HOST_SOC
-	tristate
-	default SSB_HOST_SOC
-config BACKPORTED_SSB_SERIAL
-	tristate
-	default SSB_SERIAL
-config BACKPORTED_SSB_DRIVER_PCICORE_POSSIBLE
-	tristate
-	default SSB_DRIVER_PCICORE_POSSIBLE
-config BACKPORTED_SSB_DRIVER_PCICORE
-	tristate
-	default SSB_DRIVER_PCICORE
-config BACKPORTED_SSB_PCICORE_HOSTMODE
-	tristate
-	default SSB_PCICORE_HOSTMODE
-config BACKPORTED_SSB_DRIVER_MIPS
-	tristate
-	default SSB_DRIVER_MIPS
-config BACKPORTED_SSB_SFLASH
-	tristate
-	default SSB_SFLASH
-config BACKPORTED_SSB_EMBEDDED
-	tristate
-	default SSB_EMBEDDED
-config BACKPORTED_SSB_DRIVER_EXTIF
-	tristate
-	default SSB_DRIVER_EXTIF
-config BACKPORTED_SSB_DRIVER_GIGE
-	tristate
-	default SSB_DRIVER_GIGE
-config BACKPORTED_SSB_DRIVER_GPIO
-	tristate
-	default SSB_DRIVER_GPIO
-config BACKPORTED_BCMA_POSSIBLE
-	tristate
-	default BCMA_POSSIBLE
-config BACKPORTED_BCMA
-	tristate
-	default BCMA
-config BACKPORTED_BCMA_BLOCKIO
-	tristate
-	default BCMA_BLOCKIO
-config BACKPORTED_BCMA_HOST_PCI_POSSIBLE
-	tristate
-	default BCMA_HOST_PCI_POSSIBLE
-config BACKPORTED_BCMA_HOST_PCI
-	tristate
-	default BCMA_HOST_PCI
-config BACKPORTED_BCMA_HOST_SOC
-	tristate
-	default BCMA_HOST_SOC
-config BACKPORTED_BCMA_DRIVER_PCI
-	tristate
-	default BCMA_DRIVER_PCI
-config BACKPORTED_BCMA_DRIVER_PCI_HOSTMODE
-	tristate
-	default BCMA_DRIVER_PCI_HOSTMODE
-config BACKPORTED_BCMA_DRIVER_MIPS
-	tristate
-	default BCMA_DRIVER_MIPS
-config BACKPORTED_BCMA_PFLASH
-	tristate
-	default BCMA_PFLASH
-config BACKPORTED_BCMA_SFLASH
-	tristate
-	default BCMA_SFLASH
-config BACKPORTED_BCMA_NFLASH
-	tristate
-	default BCMA_NFLASH
-config BACKPORTED_BCMA_DRIVER_GMAC_CMN
-	tristate
-	default BCMA_DRIVER_GMAC_CMN
-config BACKPORTED_BCMA_DRIVER_GPIO
-	tristate
-	default BCMA_DRIVER_GPIO
-config BACKPORTED_BCMA_DEBUG
-	tristate
-	default BCMA_DEBUG
 config BACKPORTED_USB_ACM
 	tristate
 	default USB_ACM
diff --git a/Kconfig.sources b/Kconfig.sources
index 5fb4478..347f1c5 100644
--- a/Kconfig.sources
+++ b/Kconfig.sources
@@ -7,9 +7,6 @@ source "$BACKPORT_DIR/net/mac80211/Kconfig"
 source "$BACKPORT_DIR/drivers/net/wireless/Kconfig"
 source "$BACKPORT_DIR/drivers/net/usb/Kconfig"
 
-source "$BACKPORT_DIR/drivers/ssb/Kconfig"
-source "$BACKPORT_DIR/drivers/bcma/Kconfig"
-
 source "$BACKPORT_DIR/drivers/usb/class/Kconfig"
 
 source "$BACKPORT_DIR/drivers/staging/Kconfig"
diff --git a/Makefile b/Makefile
index ee7df4b..79e5fab 100644
--- a/Makefile
+++ b/Makefile
@@ -2,10 +2,10 @@
 # Makefile for the output source package
 #
 
-ifeq ($(KERNELRELEASE),)
+ifeq ($(KERNELVERSION),)
 
 MAKEFLAGS += --no-print-directory
-SHELL := /bin/bash
+SHELL := /usr/bin/env bash
 BACKPORT_DIR := $(shell pwd)
 
 KMODDIR ?= updates
@@ -19,6 +19,7 @@ KLIB_BUILD ?= $(KLIB)/build/
 KERNEL_CONFIG := $(KLIB_BUILD)/.config
 KERNEL_MAKEFILE := $(KLIB_BUILD)/Makefile
 CONFIG_MD5 := $(shell md5sum $(KERNEL_CONFIG) 2>/dev/null | sed 's/\s.*//')
+STAMP_KERNEL_CONFIG := .kernel_config_md5_$(CONFIG_MD5)
 
 export KLIB KLIB_BUILD BACKPORT_DIR KMODDIR KMODPATH_ARG
 
@@ -36,7 +37,8 @@ mrproper:
 	@rm -f .kernel_config_md5 Kconfig.versions Kconfig.kernel
 	@rm -f backport-include/backport/autoconf.h
 
-.DEFAULT:
+.SILENT: $(STAMP_KERNEL_CONFIG)
+$(STAMP_KERNEL_CONFIG):
 	@set -e ; test -f local-symbols || (						\
 	echo "/--------------"								;\
 	echo "| You shouldn't run make in the backports tree, but only in"		;\
@@ -60,58 +62,62 @@ mrproper:
 	echo "| (that isn't currently running.)"					;\
 	echo "\\--"									;\
 	false)
-	@set -e ; if [ "$$(cat .kernel_config_md5 2>/dev/null)" != "$(CONFIG_MD5)" ]	;\
-	then 										\
-		echo -n "Generating local configuration database from kernel ..."	;\
-		grep -v -f local-symbols $(KERNEL_CONFIG) | grep = | (			\
-			while read l ; do						\
-				if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
-					continue					;\
-				fi							;\
-				l=$${l:7}						;\
-				n=$${l%%=*}						;\
-				v=$${l#*=}						;\
-				if [ "$$v" = "m" ] ; then				\
-					echo config $$n					;\
-					echo '    tristate' 				;\
-				elif [ "$$v" = "y" ] ; then				\
-					echo config $$n					;\
-					echo '    bool'					;\
-				else							\
-					continue					;\
-				fi							;\
-				echo "    default $$v"					;\
-				echo ""							;\
-			done								\
-		) > Kconfig.kernel							;\
-		kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) kernelversion |	\
-			sed 's/^\(\([3-5]\|2\.6\)\.[0-9]\+\).*/\1/;t;d')		;\
-		test "$$kver" != "" || echo "Kernel version parse failed!"		;\
-		test "$$kver" != ""							;\
-		kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
-		kvers="$$kvers $$(seq 0 19 | sed 's/^/3./')"				;\
-		kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
-		kvers="$$kvers $$(seq 0 99 | sed 's/^/5./')"				;\
-		print=0									;\
-		for v in $$kvers ; do							\
-			if [ "$$print" = "1" ] ; then					\
-				echo config KERNEL_$$(echo $$v | tr . _)	;\
-				echo "    def_bool y"					;\
-			fi								;\
-			if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
-		done > Kconfig.versions							;\
-		# RHEL as well, sadly we need to grep for it				;\
-		RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
-					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-		RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
-					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-		for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
-			echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
-			echo "    def_bool y"						;\
-		done >> Kconfig.versions						;\
-		echo " done."								;\
-	fi										;\
-	echo "$(CONFIG_MD5)" > .kernel_config_md5
+	@rm -f .kernel_config_md5_*
+	@touch $@
+
+Kconfig.kernel: $(STAMP_KERNEL_CONFIG) local-symbols
+	@printf "Generating local configuration database from kernel ..."
+	@grep -v -f local-symbols $(KERNEL_CONFIG) | grep = | (			\
+		while read l ; do						\
+			if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
+				continue					;\
+			fi							;\
+			l=$${l:7}						;\
+			n=$${l%%=*}						;\
+			v=$${l#*=}						;\
+			if [ "$$v" = "m" ] ; then				\
+				echo config $$n					;\
+				echo '    tristate' 				;\
+			elif [ "$$v" = "y" ] ; then				\
+				echo config $$n					;\
+				echo '    bool'					;\
+			else							\
+				continue					;\
+			fi							;\
+			echo "    default $$v"					;\
+			echo ""							;\
+		done								\
+	) > $@
+	@echo " done."
+
+Kconfig.versions: Kconfig.kernel
+	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) kernelversion |	\
+		sed 's/^\(\([3-5]\|2\.6\)\.[0-9]\+\).*/\1/;t;d')		;\
+	test "$$kver" != "" || echo "Kernel version parse failed!"		;\
+	test "$$kver" != ""							;\
+	kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
+	kvers="$$kvers $$(seq 0 19 | sed 's/^/3./')"				;\
+	kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
+	kvers="$$kvers $$(seq 0 99 | sed 's/^/5./')"				;\
+	print=0									;\
+	for v in $$kvers ; do							\
+		if [ "$$print" = "1" ] ; then					\
+			echo config KERNEL_$$(echo $$v | tr . _)	;\
+			echo "    def_bool y"					;\
+		fi								;\
+		if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
+	done > $@
+	@RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
+	RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
+	for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
+		echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
+		echo "    def_bool y"						;\
+	done >> $@
+
+.DEFAULT:
+	@$(MAKE) Kconfig.versions
 	@$(MAKE) -f Makefile.real "$@"
 
 .PHONY: defconfig-help
diff --git a/Makefile.kernel b/Makefile.kernel
index 5c96697..23b2688 100644
--- a/Makefile.kernel
+++ b/Makefile.kernel
@@ -40,8 +40,6 @@ obj-y += compat/
 obj-$(CPTCFG_CFG80211) += net/wireless/
 obj-$(CPTCFG_MAC80211) += net/mac80211/
 obj-$(CPTCFG_WLAN) += drivers/net/wireless/
-obj-$(CPTCFG_SSB) += drivers/ssb/
-obj-$(CPTCFG_BCMA) += drivers/bcma/
 obj-$(CPTCFG_USB_NET_RNDIS_WLAN) += drivers/net/usb/
 
 obj-$(CPTCFG_USB_WDM) += drivers/usb/class/
diff --git a/Makefile.real b/Makefile.real
index 6550802..d0a8c20 100644
--- a/Makefile.real
+++ b/Makefile.real
@@ -59,7 +59,7 @@ defconfig-%::
 
 backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
 	@$(MAKE) oldconfig
-	@echo -n "Building backport-include/backport/autoconf.h ..."
+	@printf "Building backport-include/backport/autoconf.h ..."
 	@grep -f local-symbols .config | (				\
 		echo "#ifndef COMPAT_AUTOCONF_INCLUDED"			;\
 		echo "#define COMPAT_AUTOCONF_INCLUDED"			;\
@@ -80,7 +80,12 @@ backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
 			esac						;\
 		done							;\
 		echo "#endif /* COMPAT_AUTOCONF_INCLUDED */"		;\
-	) > backport-include/backport/autoconf.h
+	) > $@.new
+	@if cmp -s $@ $@.new; then \
+		rm -f $@.new; \
+	else \
+		mv $@.new $@; \
+	fi
 	@echo " done."
 
 .PHONY: modules
diff --git a/backport-include/linux/bcm47xx_nvram.h b/backport-include/linux/bcm47xx_nvram.h
deleted file mode 100644
index 5295a02..0000000
--- a/backport-include/linux/bcm47xx_nvram.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef __BACKPORTS_BCM47XX_NVRAM_H
-#define __BACKPORTS_BCM47XX_NVRAM_H
-#include <linux/version.h>
-
-#if LINUX_VERSION_IS_GEQ(4,1,0)
-#include_next <linux/bcm47xx_nvram.h>
-#else
-#include <linux/types.h>
-#include <linux/kernel.h>
-#endif
-
-#if LINUX_VERSION_IS_LESS(4,2,0)
-#define bcm47xx_nvram_get_contents LINUX_BACKPORT(bcm47xx_nvram_get_contents)
-static inline char *bcm47xx_nvram_get_contents(size_t *val_len)
-{
-	return NULL;
-}
-
-#define bcm47xx_nvram_release_contents LINUX_BACKPORT(bcm47xx_nvram_release_contents)
-static inline void bcm47xx_nvram_release_contents(char *nvram)
-{
-}
-#endif /* LINUX_VERSION_IS_GEQ(4,1,0) */
-
-#endif /* __BACKPORTS_BCM47XX_NVRAM_H */
diff --git a/backport-include/linux/kconfig.h b/backport-include/linux/kconfig.h
index d1faad9..a0bc8c4 100644
--- a/backport-include/linux/kconfig.h
+++ b/backport-include/linux/kconfig.h
@@ -5,6 +5,8 @@
 #include_next <linux/kconfig.h>
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+
 #ifndef __ARG_PLACEHOLDER_1
 #define __ARG_PLACEHOLDER_1 0,
 #define config_enabled(cfg) _config_enabled(cfg)
@@ -16,6 +18,7 @@
  * 3.1 - 3.3 had a broken version of this, so undef
  * (they didn't have __ARG_PLACEHOLDER_1)
  */
+
 #undef IS_ENABLED
 #define IS_ENABLED(option) \
         (config_enabled(option) || config_enabled(option##_MODULE))
@@ -31,6 +34,8 @@
 #undef IS_BUILTIN
 #define IS_BUILTIN(option) config_enabled(option)
 
+#endif
+
 #ifndef IS_REACHABLE
 /*
  * IS_REACHABLE(CONFIG_FOO) evaluates to 1 if the currently compiled
diff --git a/backport-include/linux/rfkill.h b/backport-include/linux/rfkill.h
index 99015af..0193f96 100644
--- a/backport-include/linux/rfkill.h
+++ b/backport-include/linux/rfkill.h
@@ -2,6 +2,12 @@
 #define __COMPAT_RFKILL_H
 #include <linux/version.h>
 
+#undef CONFIG_RFKILL
+#undef CONFIG_RFKILL_FULL
+#undef CONFIG_RFKILL_LEDS
+#undef CONFIG_RFKILL_MODULE
+#undef CONFIG_RFKILL_FULL_MODULE
+
 #if LINUX_VERSION_IS_GEQ(3,10,0)
 #include_next <linux/rfkill.h>
 #else
diff --git a/compat/main.c b/compat/main.c
index 0bf0420..740bf09 100644
--- a/compat/main.c
+++ b/compat/main.c
@@ -20,31 +20,6 @@ MODULE_LICENSE("GPL");
 #error "You need a CPTCFG_VERSION"
 #endif
 
-static char *backported_kernel_name = CPTCFG_KERNEL_NAME;
-
-module_param(backported_kernel_name, charp, 0400);
-MODULE_PARM_DESC(backported_kernel_name,
-		 "The kernel tree name that was used for this backport (" CPTCFG_KERNEL_NAME ")");
-
-#ifdef BACKPORTS_GIT_TRACKED
-static char *backports_tracker_id = BACKPORTS_GIT_TRACKED;
-module_param(backports_tracker_id, charp, 0400);
-MODULE_PARM_DESC(backports_tracker_id,
-		 "The version of the tree containing this backport (" BACKPORTS_GIT_TRACKED ")");
-#else
-static char *backported_kernel_version = CPTCFG_KERNEL_VERSION;
-static char *backports_version = CPTCFG_VERSION;
-
-module_param(backported_kernel_version, charp, 0400);
-MODULE_PARM_DESC(backported_kernel_version,
-		 "The kernel version that was used for this backport (" CPTCFG_KERNEL_VERSION ")");
-
-module_param(backports_version, charp, 0400);
-MODULE_PARM_DESC(backports_version,
-		 "The git version of the backports tree used to generate this backport (" CPTCFG_VERSION ")");
-
-#endif
-
 void backport_dependency_symbol(void)
 {
 }
diff --git a/drivers/net/wireless/ath/Kconfig b/drivers/net/wireless/ath/Kconfig
index 64d3d31..187e041 100644
--- a/drivers/net/wireless/ath/Kconfig
+++ b/drivers/net/wireless/ath/Kconfig
@@ -1,5 +1,5 @@
 config ATH_COMMON
-	tristate
+	tristate "ath.ko"
 	depends on m
 
 config WLAN_VENDOR_ATH
@@ -23,6 +23,9 @@ config WLAN_VENDOR_ATH
 
 if WLAN_VENDOR_ATH
 
+config ATH_USER_REGD
+	bool "Do not enforce EEPROM regulatory restrictions"
+
 config ATH_DEBUG
 	bool "Atheros wireless debugging"
 	---help---
diff --git a/drivers/net/wireless/ath/Makefile b/drivers/net/wireless/ath/Makefile
index a7521a7..ac2aefd 100644
--- a/drivers/net/wireless/ath/Makefile
+++ b/drivers/net/wireless/ath/Makefile
@@ -14,10 +14,10 @@ ath-objs :=	main.o \
 		regd.o \
 		hw.o \
 		key.o \
+		debug.o \
 		dfs_pattern_detector.o \
 		dfs_pri_detector.o
 
-ath-$(CPTCFG_ATH_DEBUG) += debug.o
 ath-$(CPTCFG_ATH_TRACEPOINTS) += trace.o
 
 CFLAGS_trace.o := -I$(src)
diff --git a/drivers/net/wireless/ath/ath.h b/drivers/net/wireless/ath/ath.h
index a547b2d..2a18e2e 100644
--- a/drivers/net/wireless/ath/ath.h
+++ b/drivers/net/wireless/ath/ath.h
@@ -149,6 +149,7 @@ struct ath_common {
 	int debug_mask;
 	enum ath_device_state state;
 	unsigned long op_flags;
+	u32 chan_bw;
 
 	struct ath_ani ani;
 
@@ -316,14 +317,7 @@ void _ath_dbg(struct ath_common *common, enum ATH_DEBUG dbg_mask,
 #endif /* CPTCFG_ATH_DEBUG */
 
 /** Returns string describing opmode, or NULL if unknown mode. */
-#ifdef CPTCFG_ATH_DEBUG
 const char *ath_opmode_to_string(enum nl80211_iftype opmode);
-#else
-static inline const char *ath_opmode_to_string(enum nl80211_iftype opmode)
-{
-	return "UNKNOWN";
-}
-#endif
 
 extern const char *ath_bus_type_strings[];
 static inline const char *ath_bus_type_to_string(enum ath_bus_type bustype)
diff --git a/drivers/net/wireless/ath/ath10k/Kconfig b/drivers/net/wireless/ath/ath10k/Kconfig
index ca7fb7e..ad46459 100644
--- a/drivers/net/wireless/ath/ath10k/Kconfig
+++ b/drivers/net/wireless/ath/ath10k/Kconfig
@@ -69,6 +69,16 @@ config ATH10K_DEBUGFS
 
 	  If unsure, say Y to make it easier to debug problems.
 
+config ATH10K_LEDS
+	bool "Atheros ath10k LED support"
+	depends on ATH10K
+	select MAC80211_LEDS
+	select LEDS_CLASS
+	select NEW_LEDS
+	default y
+	---help---
+	  This option is necessary, if you want LED support for chipset connected led pins. If unsure, say N.
+
 config ATH10K_SPECTRAL
 	bool "Atheros ath10k spectral scan support"
 	depends on ATH10K_DEBUGFS
@@ -85,6 +95,12 @@ config ATH10K_TRACING
 	---help---
 	  Select this to ath10k use tracing infrastructure.
 
+config ATH10K_THERMAL
+	bool "Atheros ath10k thermal monitoring support"
+	depends on THERMAL
+	---help---
+	  Select this to ath10k use hwmon for thermal measurement.
+
 config ATH10K_DFS_CERTIFIED
 	bool "Atheros DFS support for certified platforms"
 	depends on ATH10K && CFG80211_CERTIFICATION_ONUS
diff --git a/drivers/net/wireless/ath/ath10k/Makefile b/drivers/net/wireless/ath/ath10k/Makefile
index 09e1bb1..0d29302 100644
--- a/drivers/net/wireless/ath/ath10k/Makefile
+++ b/drivers/net/wireless/ath/ath10k/Makefile
@@ -18,7 +18,8 @@ ath10k_core-y += mac.o \
 ath10k_core-$(CPTCFG_ATH10K_SPECTRAL) += spectral.o
 ath10k_core-$(CPTCFG_NL80211_TESTMODE) += testmode.o
 ath10k_core-$(CPTCFG_ATH10K_TRACING) += trace.o
-ath10k_core-$(CONFIG_THERMAL) += thermal.o
+ath10k_core-$(CPTCFG_ATH10K_THERMAL) += thermal.o
+ath10k_core-$(CPTCFG_ATH10K_LEDS) += leds.o
 ath10k_core-$(CPTCFG_MAC80211_DEBUGFS) += debugfs_sta.o
 ath10k_core-$(CONFIG_PM) += wow.o
 ath10k_core-$(CONFIG_DEV_COREDUMP) += coredump.o
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index 5210cff..20ac58a 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -34,6 +34,7 @@
 #include "testmode.h"
 #include "wmi-ops.h"
 #include "coredump.h"
+#include "leds.h"
 
 unsigned int ath10k_debug_mask;
 static unsigned int ath10k_cryptmode_param;
@@ -64,6 +65,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.id = QCA988X_HW_2_0_VERSION,
 		.dev_id = QCA988X_2_0_DEVICE_ID,
 		.name = "qca988x hw2.0",
+		.led_pin = 1,
 		.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
@@ -129,6 +131,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.id = QCA9887_HW_1_0_VERSION,
 		.dev_id = QCA9887_1_0_DEVICE_ID,
 		.name = "qca9887 hw1.0",
+		.led_pin = 1,
 		.patch_load_addr = QCA9887_HW_1_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
@@ -293,6 +296,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.id = QCA99X0_HW_2_0_DEV_VERSION,
 		.dev_id = QCA99X0_2_0_DEVICE_ID,
 		.name = "qca99x0 hw2.0",
+		.led_pin = 17,
 		.patch_load_addr = QCA99X0_HW_2_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
 		.otp_exe_param = 0x00000700,
@@ -331,6 +335,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.id = QCA9984_HW_1_0_DEV_VERSION,
 		.dev_id = QCA9984_1_0_DEVICE_ID,
 		.name = "qca9984/qca9994 hw1.0",
+		.led_pin = 17,
 		.patch_load_addr = QCA9984_HW_1_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
@@ -374,6 +379,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.id = QCA9888_HW_2_0_DEV_VERSION,
 		.dev_id = QCA9888_2_0_DEVICE_ID,
 		.name = "qca9888 hw2.0",
+		.led_pin = 17,
 		.patch_load_addr = QCA9888_HW_2_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
@@ -2441,6 +2447,10 @@ int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,
 	if (status)
 		goto err_hif_stop;
 
+	status = ath10k_leds_start(ar);
+	if (status)
+		goto err_hif_stop;
+
 	return 0;
 
 err_hif_stop:
@@ -2695,9 +2705,18 @@ static void ath10k_core_register_work(struct work_struct *work)
 		goto err_spectral_destroy;
 	}
 
+	status = ath10k_leds_register(ar);
+	if (status) {
+		ath10k_err(ar, "could not register leds: %d\n",
+			   status);
+		goto err_thermal_unregister;
+	}
+
 	set_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags);
 	return;
 
+err_thermal_unregister:
+	ath10k_thermal_unregister(ar);
 err_spectral_destroy:
 	ath10k_spectral_destroy(ar);
 err_debug_destroy:
@@ -2720,6 +2739,16 @@ int ath10k_core_register(struct ath10k *ar, u32 chip_id)
 	ar->chip_id = chip_id;
 	queue_work(ar->workqueue, &ar->register_work);
 
+	/* OpenWrt requires all PHYs to be initialized to create the
+	 * configuration files during bootup. ath10k violates this
+	 * because it delays the creation of the PHY to a not well defined
+	 * point in the future.
+	 *
+	 * Forcing the work to be done immediately works around this problem
+	 * but may also delay the boot when firmware images cannot be found.
+	 */
+	flush_workqueue(ar->workqueue);
+
 	return 0;
 }
 EXPORT_SYMBOL(ath10k_core_register);
@@ -2731,6 +2760,8 @@ void ath10k_core_unregister(struct ath10k *ar)
 	if (!test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags))
 		return;
 
+	ath10k_leds_unregister(ar);
+
 	ath10k_thermal_unregister(ar);
 	/* Stop spectral before unregistering from mac80211 to remove the
 	 * relayfs debugfs file cleanly. Otherwise the parent debugfs tree
diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h
index 1d95ba3..97688de 100644
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -25,6 +25,7 @@
 #include <linux/pci.h>
 #include <linux/uuid.h>
 #include <linux/time.h>
+#include <linux/leds.h>
 
 #include "htt.h"
 #include "htc.h"
@@ -908,7 +909,6 @@ struct ath10k {
 	u32 low_5ghz_chan;
 	u32 high_5ghz_chan;
 	bool ani_enabled;
-
 	bool p2p;
 
 	struct {
@@ -1098,6 +1098,13 @@ struct ath10k {
 		bool utf_monitor;
 	} testmode;
 
+	struct {
+		struct gpio_led wifi_led;
+		struct led_classdev cdev;
+		char label[48];
+		u32 gpio_state_pin;
+	} leds;
+
 	struct {
 		/* protected by data_lock */
 		u32 fw_crash_counter;
@@ -1137,6 +1144,10 @@ struct ath10k {
 	struct ath10k_radar_found_info last_radar_info;
 	struct work_struct radar_confirmation_work;
 
+#ifdef CPTCFG_MAC80211_LEDS
+	const char *led_default_trigger;
+#endif
+
 	/* must be last */
 	u8 drv_priv[0] __aligned(sizeof(void *));
 };
diff --git a/drivers/net/wireless/ath/ath10k/htt.h b/drivers/net/wireless/ath/ath10k/htt.h
index 9dd938e..694af31 100644
--- a/drivers/net/wireless/ath/ath10k/htt.h
+++ b/drivers/net/wireless/ath/ath10k/htt.h
@@ -238,7 +238,7 @@ enum htt_rx_ring_flags {
 };
 
 #define HTT_RX_RING_SIZE_MIN 128
-#define HTT_RX_RING_SIZE_MAX 2048
+#define HTT_RX_RING_SIZE_MAX 512
 #define HTT_RX_RING_SIZE HTT_RX_RING_SIZE_MAX
 #define HTT_RX_RING_FILL_LEVEL (((HTT_RX_RING_SIZE) / 2) - 1)
 #define HTT_RX_RING_FILL_LEVEL_DUAL_MAC (HTT_RX_RING_SIZE - 1)
diff --git a/drivers/net/wireless/ath/ath10k/hw.h b/drivers/net/wireless/ath/ath10k/hw.h
index 46a2039..c0c1101 100644
--- a/drivers/net/wireless/ath/ath10k/hw.h
+++ b/drivers/net/wireless/ath/ath10k/hw.h
@@ -504,6 +504,7 @@ struct ath10k_hw_params {
 	const char *name;
 	u32 patch_load_addr;
 	int uart_pin;
+	int led_pin;
 	u32 otp_exe_param;
 
 	/* Type of hw cycle counter wraparound logic, for more info
diff --git a/drivers/net/wireless/ath/ath10k/leds.c b/drivers/net/wireless/ath/ath10k/leds.c
new file mode 100644
index 0000000..be8f255
--- /dev/null
+++ b/drivers/net/wireless/ath/ath10k/leds.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2005-2011 Atheros Communications Inc.
+ * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.
+ * Copyright (c) 2018 Sebastian Gottschall <s.gottschall@dd-wrt.com>
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/leds.h>
+
+#include "core.h"
+#include "wmi.h"
+#include "wmi-ops.h"
+
+#include "leds.h"
+
+static int ath10k_leds_set_brightness_blocking(struct led_classdev *led_cdev,
+					       enum led_brightness brightness)
+{
+	struct ath10k *ar = container_of(led_cdev, struct ath10k,
+					 leds.cdev);
+	struct gpio_led *led = &ar->leds.wifi_led;
+
+	mutex_lock(&ar->conf_mutex);
+
+	if (ar->state != ATH10K_STATE_ON)
+		goto out;
+
+	ar->leds.gpio_state_pin = (brightness != LED_OFF) ^ led->active_low;
+	ath10k_wmi_gpio_output(ar, led->gpio, ar->leds.gpio_state_pin);
+
+out:
+	mutex_unlock(&ar->conf_mutex);
+
+	return 0;
+}
+
+int ath10k_leds_start(struct ath10k *ar)
+{
+	if (ar->hw_params.led_pin == 0)
+		/* leds not supported */
+		return 0;
+
+	/* under some circumstances, the gpio pin gets reconfigured
+	 * to default state by the firmware, so we need to
+	 * reconfigure it this behaviour has only ben seen on
+	 * QCA9984 and QCA99XX devices so far
+	 */
+	ath10k_wmi_gpio_config(ar, ar->hw_params.led_pin, 0,
+			       WMI_GPIO_PULL_NONE, WMI_GPIO_INTTYPE_DISABLE);
+	ath10k_wmi_gpio_output(ar, ar->hw_params.led_pin, 1);
+
+	return 0;
+}
+
+int ath10k_leds_register(struct ath10k *ar)
+{
+	int ret;
+
+	if (ar->hw_params.led_pin == 0)
+		/* leds not supported */
+		return 0;
+
+	snprintf(ar->leds.label, sizeof(ar->leds.label), "ath10k-%s",
+		 wiphy_name(ar->hw->wiphy));
+	ar->leds.wifi_led.active_low = 1;
+	ar->leds.wifi_led.gpio = ar->hw_params.led_pin;
+	ar->leds.wifi_led.name = ar->leds.label;
+	ar->leds.wifi_led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
+
+	ar->leds.cdev.name = ar->leds.label;
+	ar->leds.cdev.brightness_set_blocking = ath10k_leds_set_brightness_blocking;
+	ar->leds.cdev.default_trigger = ar->led_default_trigger;
+
+	ret = led_classdev_register(wiphy_dev(ar->hw->wiphy), &ar->leds.cdev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void ath10k_leds_unregister(struct ath10k *ar)
+{
+	if (ar->hw_params.led_pin == 0)
+		/* leds not supported */
+		return;
+
+	led_classdev_unregister(&ar->leds.cdev);
+}
+
diff --git a/drivers/net/wireless/ath/ath10k/leds.h b/drivers/net/wireless/ath/ath10k/leds.h
new file mode 100644
index 0000000..a0f5c84
--- /dev/null
+++ b/drivers/net/wireless/ath/ath10k/leds.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _LEDS_H_
+#define _LEDS_H_
+
+#include "core.h"
+
+#ifdef CPTCFG_ATH10K_LEDS
+void ath10k_leds_unregister(struct ath10k *ar);
+int ath10k_leds_start(struct ath10k *ar);
+int ath10k_leds_register(struct ath10k *ar);
+#else
+static inline void ath10k_leds_unregister(struct ath10k *ar)
+{
+}
+
+static inline int ath10k_leds_start(struct ath10k *ar)
+{
+	return 0;
+}
+
+static inline int ath10k_leds_register(struct ath10k *ar)
+{
+	return 0;
+}
+
+#endif
+#endif /* _LEDS_H_ */
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index 3ceca7a..2d160b6 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -18,6 +18,7 @@
 
 #include "mac.h"
 
+#include <net/cfg80211.h>
 #include <net/mac80211.h>
 #include <linux/etherdevice.h>
 #include <linux/acpi.h>
@@ -33,6 +34,7 @@
 #include "wmi-tlv.h"
 #include "wmi-ops.h"
 #include "wow.h"
+#include "leds.h"
 
 /*********/
 /* Rates */
@@ -156,6 +158,22 @@ u8 ath10k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,
 	return 0;
 }
 
+static int ath10k_mac_get_rate_hw_value(int bitrate)
+{
+	int i;
+	u8 hw_value_prefix = 0;
+
+	if (ath10k_mac_bitrate_is_cck(bitrate))
+		hw_value_prefix = WMI_RATE_PREAMBLE_CCK << 6;
+
+	for (i = 0; i < ARRAY_SIZE(ath10k_rates); i++) {
+		if (ath10k_rates[i].bitrate == bitrate)
+			return hw_value_prefix | ath10k_rates[i].hw_value;
+	}
+
+	return -EINVAL;
+}
+
 static int ath10k_mac_get_max_vht_mcs_map(u16 mcs_map, int nss)
 {
 	switch ((mcs_map >> (2 * nss)) & 0x3) {
@@ -2469,7 +2487,7 @@ static void ath10k_peer_assoc_h_vht(struct ath10k *ar,
 	const u16 *vht_mcs_mask;
 	u8 ampdu_factor;
 	u8 max_nss, vht_mcs;
-	int i;
+	int i, nss160;
 
 	if (WARN_ON(ath10k_mac_vif_chan(vif, &def)))
 		return;
@@ -2529,23 +2547,45 @@ static void ath10k_peer_assoc_h_vht(struct ath10k *ar,
 		__le16_to_cpu(vht_cap->vht_mcs.tx_highest);
 	arg->peer_vht_rates.tx_mcs_set = ath10k_peer_assoc_h_vht_limit(
 		__le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map), vht_mcs_mask);
+	arg->peer_bw_rxnss_override = 0;
+	nss160 = 1; /* 1x1 default config for VHT160 */
 
-	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac vht peer %pM max_mpdu %d flags 0x%x\n",
-		   sta->addr, arg->peer_max_mpdu, arg->peer_flags);
+	/* only local 4x4 configuration do support 2x2 for VHT160,
+	 * everything else must use 1x1 
+	 */
 
-	if (arg->peer_vht_rates.rx_max_rate &&
-	    (sta->vht_cap.cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK)) {
-		switch (arg->peer_vht_rates.rx_max_rate) {
-		case 1560:
-			/* Must be 2x2 at 160Mhz is all it can do. */
-			arg->peer_bw_rxnss_override = 2;
-			break;
-		case 780:
-			/* Can only do 1x1 at 160Mhz (Long Guard Interval) */
-			arg->peer_bw_rxnss_override = 1;
-			break;
-		}
+	if (ar->cfg_rx_chainmask == 15)
+		nss160 = arg->peer_num_spatial_streams <= 2 ? 1 : 2;
+
+	/* if peer provides 1x1 nss160 information using max rate
+	 * vht information, we reduce local nss160 to 1x1.
+	 * consider that it has been observed that some client
+	 * devices provide zero here, no matter which transmission
+	 * rate is possible. in that case the local nss configuration 
+	 * will be used at maxmimum configuration possible. (see above)
+	 */
+
+	if (arg->peer_vht_rates.rx_max_rate == 780)
+		nss160 = 1;
+
+	/* in case if peer is connected with vht160 or vht80+80,
+         * we need to properly adjust rxnss parameters otherwise 
+	 * firmware will raise a assert 
+	 */
+	switch (arg->peer_phymode) {
+	case MODE_11AC_VHT80_80:
+		arg->peer_bw_rxnss_override = BW_NSS_FWCONF_80_80(nss160);
+	/* fall through */
+	case MODE_11AC_VHT160:
+		arg->peer_bw_rxnss_override |= BW_NSS_FWCONF_160(nss160);
+		break;
+	default:
+		break;
 	}
+
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac vht peer %pM max_mpdu %d flags 0x%x peer_bw_rxnss_override 0x%x\n",
+		   sta->addr, arg->peer_max_mpdu, arg->peer_flags, 
+		   arg->peer_bw_rxnss_override);
 }
 
 static void ath10k_peer_assoc_h_qos(struct ath10k *ar,
@@ -2697,9 +2737,9 @@ static int ath10k_peer_assoc_prepare(struct ath10k *ar,
 	ath10k_peer_assoc_h_crypto(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_rates(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_ht(ar, vif, sta, arg);
+	ath10k_peer_assoc_h_phymode(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_vht(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_qos(ar, vif, sta, arg);
-	ath10k_peer_assoc_h_phymode(ar, vif, sta, arg);
 
 	return 0;
 }
@@ -4451,13 +4491,6 @@ static struct ieee80211_sta_vht_cap ath10k_create_vht_cap(struct ath10k *ar)
 		vht_cap.cap |= val;
 	}
 
-	/* Currently the firmware seems to be buggy, don't enable 80+80
-	 * mode until that's resolved.
-	 */
-	if ((ar->vht_cap_info & IEEE80211_VHT_CAP_SHORT_GI_160) &&
-	    (ar->vht_cap_info & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) == 0)
-		vht_cap.cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
-
 	mcs_map = 0;
 	for (i = 0; i < 8; i++) {
 		if ((i < ar->num_rf_chains) && (ar->cfg_tx_chainmask & BIT(i)))
@@ -5451,9 +5484,10 @@ static void ath10k_bss_info_changed(struct ieee80211_hw *hw,
 	struct cfg80211_chan_def def;
 	u32 vdev_param, pdev_param, slottime, preamble;
 	u16 bitrate, hw_value;
-	u8 rate;
-	int rateidx, ret = 0;
+	u8 rate, basic_rate_idx, rateidx;
+	int ret = 0, hw_rate_code, mcast_rate;
 	enum nl80211_band band;
+	const struct ieee80211_supported_band *sband;
 
 	mutex_lock(&ar->conf_mutex);
 
@@ -5624,7 +5658,11 @@ static void ath10k_bss_info_changed(struct ieee80211_hw *hw,
 	if (changed & BSS_CHANGED_MCAST_RATE &&
 	    !WARN_ON(ath10k_mac_vif_chan(arvif->vif, &def))) {
 		band = def.chan->band;
-		rateidx = vif->bss_conf.mcast_rate[band] - 1;
+		mcast_rate = vif->bss_conf.mcast_rate[band];
+		if (mcast_rate > 0)
+			rateidx = mcast_rate - 1;
+		else
+			rateidx = ffs(vif->bss_conf.basic_rates) - 1;
 
 		if (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY)
 			rateidx += ATH10K_MAC_FIRST_OFDM_RATE_IDX;
@@ -5659,6 +5697,30 @@ static void ath10k_bss_info_changed(struct ieee80211_hw *hw,
 				    arvif->vdev_id,  ret);
 	}
 
+	if (changed & BSS_CHANGED_BASIC_RATES) {
+		if (WARN_ON(ath10k_mac_vif_chan(vif, &def))) {
+			mutex_unlock(&ar->conf_mutex);
+			return;
+		}
+
+		sband = ar->hw->wiphy->bands[def.chan->band];
+		basic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;
+		bitrate = sband->bitrates[basic_rate_idx].bitrate;
+
+		hw_rate_code = ath10k_mac_get_rate_hw_value(bitrate);
+		if (hw_rate_code < 0) {
+			ath10k_warn(ar, "bitrate not supported %d\n", bitrate);
+			mutex_unlock(&ar->conf_mutex);
+			return;
+		}
+
+		vdev_param = ar->wmi.vdev_param->mgmt_rate;
+		ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,
+						hw_rate_code);
+		if (ret)
+			ath10k_warn(ar, "failed to set mgmt tx rate %d\n", ret);
+	}
+
 	mutex_unlock(&ar->conf_mutex);
 }
 
@@ -8282,6 +8344,21 @@ static int ath10k_mac_init_rd(struct ath10k *ar)
 	return 0;
 }
 
+#ifdef CPTCFG_MAC80211_LEDS
+static const struct ieee80211_tpt_blink ath10k_tpt_blink[] = {
+	{ .throughput = 0 * 1024, .blink_time = 334 },
+	{ .throughput = 1 * 1024, .blink_time = 260 },
+	{ .throughput = 2 * 1024, .blink_time = 220 },
+	{ .throughput = 5 * 1024, .blink_time = 190 },
+	{ .throughput = 10 * 1024, .blink_time = 170 },
+	{ .throughput = 25 * 1024, .blink_time = 150 },
+	{ .throughput = 54 * 1024, .blink_time = 130 },
+	{ .throughput = 120 * 1024, .blink_time = 110 },
+	{ .throughput = 265 * 1024, .blink_time = 80 },
+	{ .throughput = 586 * 1024, .blink_time = 50 },
+};
+#endif
+
 int ath10k_mac_register(struct ath10k *ar)
 {
 	static const u32 cipher_suites[] = {
@@ -8359,6 +8436,7 @@ int ath10k_mac_register(struct ath10k *ar)
 		ar->hw->wiphy->bands[NL80211_BAND_5GHZ] = band;
 	}
 
+	wiphy_read_of_freq_limits(ar->hw->wiphy);
 	ath10k_mac_setup_ht_vht_cap(ar);
 
 	ar->hw->wiphy->interface_modes =
@@ -8571,6 +8649,12 @@ int ath10k_mac_register(struct ath10k *ar)
 
 	wiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
 
+#ifdef CPTCFG_MAC80211_LEDS
+	ar->led_default_trigger = ieee80211_create_tpt_led_trigger(ar->hw,
+		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath10k_tpt_blink,
+		ARRAY_SIZE(ath10k_tpt_blink));
+#endif
+
 	ret = ieee80211_register_hw(ar->hw);
 	if (ret) {
 		ath10k_err(ar, "failed to register ieee80211: %d\n", ret);
diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c
index 284aac1..300f0fb 100644
--- a/drivers/net/wireless/ath/ath10k/pci.c
+++ b/drivers/net/wireless/ath/ath10k/pci.c
@@ -142,7 +142,7 @@ static struct ce_attr host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
-		.dest_nentries = 512,
+		.dest_nentries = 128,
 		.recv_cb = ath10k_pci_htt_htc_rx_cb,
 	},
 
@@ -151,7 +151,7 @@ static struct ce_attr host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
-		.dest_nentries = 128,
+		.dest_nentries = 64,
 		.recv_cb = ath10k_pci_htc_rx_cb,
 	},
 
@@ -178,7 +178,7 @@ static struct ce_attr host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 512,
-		.dest_nentries = 512,
+		.dest_nentries = 128,
 		.recv_cb = ath10k_pci_htt_rx_cb,
 	},
 
@@ -203,7 +203,7 @@ static struct ce_attr host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
-		.dest_nentries = 128,
+		.dest_nentries = 96,
 		.recv_cb = ath10k_pci_pktlog_rx_cb,
 	},
 
diff --git a/drivers/net/wireless/ath/ath10k/thermal.h b/drivers/net/wireless/ath/ath10k/thermal.h
index 65e2419..91b7b0f 100644
--- a/drivers/net/wireless/ath/ath10k/thermal.h
+++ b/drivers/net/wireless/ath/ath10k/thermal.h
@@ -36,7 +36,7 @@ struct ath10k_thermal {
 	int temperature;
 };
 
-#if IS_REACHABLE(CONFIG_THERMAL)
+#if IS_REACHABLE(CPTCFG_ATH10K_THERMAL)
 int ath10k_thermal_register(struct ath10k *ar);
 void ath10k_thermal_unregister(struct ath10k *ar);
 void ath10k_thermal_event_temperature(struct ath10k *ar, int temperature);
diff --git a/drivers/net/wireless/ath/ath10k/wmi-ops.h b/drivers/net/wireless/ath/ath10k/wmi-ops.h
index 7fd63bb..5d34c81 100644
--- a/drivers/net/wireless/ath/ath10k/wmi-ops.h
+++ b/drivers/net/wireless/ath/ath10k/wmi-ops.h
@@ -216,7 +216,10 @@ struct wmi_ops {
 	struct sk_buff *(*gen_echo)(struct ath10k *ar, u32 value);
 	struct sk_buff *(*gen_pdev_get_tpc_table_cmdid)(struct ath10k *ar,
 							u32 param);
+	struct sk_buff *(*gen_gpio_config)(struct ath10k *ar, u32 gpio_num,
+					   u32 input, u32 pull_type, u32 intr_mode);
 
+	struct sk_buff *(*gen_gpio_output)(struct ath10k *ar, u32 gpio_num, u32 set);
 };
 
 int ath10k_wmi_cmd_send(struct ath10k *ar, struct sk_buff *skb, u32 cmd_id);
@@ -1054,6 +1057,35 @@ ath10k_wmi_force_fw_hang(struct ath10k *ar,
 	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->force_fw_hang_cmdid);
 }
 
+static inline int ath10k_wmi_gpio_config(struct ath10k *ar, u32 gpio_num,
+					 u32 input, u32 pull_type, u32 intr_mode)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_gpio_config)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_gpio_config(ar, gpio_num, input, pull_type, intr_mode);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->gpio_config_cmdid);
+}
+
+static inline int ath10k_wmi_gpio_output(struct ath10k *ar, u32 gpio_num, u32 set)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_gpio_config)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_gpio_output(ar, gpio_num, set);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->gpio_output_cmdid);
+}
+
 static inline int
 ath10k_wmi_dbglog_cfg(struct ath10k *ar, u64 module_enable, u32 log_level)
 {
diff --git a/drivers/net/wireless/ath/ath10k/wmi-tlv.c b/drivers/net/wireless/ath/ath10k/wmi-tlv.c
index cdc1e64..046b165 100644
--- a/drivers/net/wireless/ath/ath10k/wmi-tlv.c
+++ b/drivers/net/wireless/ath/ath10k/wmi-tlv.c
@@ -3976,6 +3976,8 @@ static const struct wmi_ops wmi_tlv_ops = {
 	.gen_echo = ath10k_wmi_tlv_op_gen_echo,
 	.gen_vdev_spectral_conf = ath10k_wmi_tlv_op_gen_vdev_spectral_conf,
 	.gen_vdev_spectral_enable = ath10k_wmi_tlv_op_gen_vdev_spectral_enable,
+	/* .gen_gpio_config not implemented */
+	/* .gen_gpio_output not implemented */
 };
 
 static const struct wmi_peer_flags_map wmi_tlv_peer_flags_map = {
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index f9e93d0..07d3106 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -1677,13 +1677,18 @@ void ath10k_wmi_put_wmi_channel(struct wmi_channel *ch,
 		flags |= WMI_CHAN_FLAG_HT40_PLUS;
 	if (arg->chan_radar)
 		flags |= WMI_CHAN_FLAG_DFS;
-
+	ch->band_center_freq2 = 0;
 	ch->mhz = __cpu_to_le32(arg->freq);
 	ch->band_center_freq1 = __cpu_to_le32(arg->band_center_freq1);
 	if (arg->mode == MODE_11AC_VHT80_80)
 		ch->band_center_freq2 = __cpu_to_le32(arg->band_center_freq2);
-	else
-		ch->band_center_freq2 = 0;
+	if (arg->mode == MODE_11AC_VHT160)  {
+		if (arg->freq < arg->band_center_freq1)
+			ch->band_center_freq1 = __cpu_to_le32(arg->band_center_freq1 - 40);
+		else
+			ch->band_center_freq1 = __cpu_to_le32(arg->band_center_freq1 + 40);
+		ch->band_center_freq2 = __cpu_to_le32(arg->band_center_freq1);
+	}
 	ch->min_power = arg->min_power;
 	ch->max_power = arg->max_power;
 	ch->reg_power = arg->max_reg_power;
@@ -7172,6 +7177,49 @@ ath10k_wmi_op_gen_peer_set_param(struct ath10k *ar, u32 vdev_id,
 	return skb;
 }
 
+static struct sk_buff *ath10k_wmi_op_gen_gpio_config(struct ath10k *ar,
+						     u32 gpio_num, u32 input,
+						     u32 pull_type, u32 intr_mode)
+{
+	struct wmi_gpio_config_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_gpio_config_cmd *)skb->data;
+	cmd->pull_type = __cpu_to_le32(pull_type);
+	cmd->gpio_num = __cpu_to_le32(gpio_num);
+	cmd->input = __cpu_to_le32(input);
+	cmd->intr_mode = __cpu_to_le32(intr_mode);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi gpio_config gpio_num 0x%08x input 0x%08x pull_type 0x%08x intr_mode 0x%08x\n",
+		   gpio_num, input, pull_type, intr_mode);
+
+	return skb;
+}
+
+static struct sk_buff *ath10k_wmi_op_gen_gpio_output(struct ath10k *ar,
+						     u32 gpio_num, u32 set)
+{
+	struct wmi_gpio_output_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_gpio_output_cmd *)skb->data;
+	cmd->gpio_num = __cpu_to_le32(gpio_num);
+	cmd->set = __cpu_to_le32(set);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi gpio_output gpio_num 0x%08x set 0x%08x\n",
+		   gpio_num, set);
+
+	return skb;
+}
+
 static struct sk_buff *
 ath10k_wmi_op_gen_set_psmode(struct ath10k *ar, u32 vdev_id,
 			     enum wmi_sta_ps_mode psmode)
@@ -7357,12 +7405,7 @@ ath10k_wmi_peer_assoc_fill_10_4(struct ath10k *ar, void *buf,
 	struct wmi_10_4_peer_assoc_complete_cmd *cmd = buf;
 
 	ath10k_wmi_peer_assoc_fill_10_2(ar, buf, arg);
-	if (arg->peer_bw_rxnss_override)
-		cmd->peer_bw_rxnss_override =
-			__cpu_to_le32((arg->peer_bw_rxnss_override - 1) |
-				      BIT(PEER_BW_RXNSS_OVERRIDE_OFFSET));
-	else
-		cmd->peer_bw_rxnss_override = 0;
+	cmd->peer_bw_rxnss_override = __cpu_to_le32(arg->peer_bw_rxnss_override);
 }
 
 static int
@@ -8788,6 +8831,9 @@ static const struct wmi_ops wmi_ops = {
 	.fw_stats_fill = ath10k_wmi_main_op_fw_stats_fill,
 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
 	.gen_echo = ath10k_wmi_op_gen_echo,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
+
 	/* .gen_bcn_tmpl not implemented */
 	/* .gen_prb_tmpl not implemented */
 	/* .gen_p2p_go_bcn_ie not implemented */
@@ -8858,6 +8904,8 @@ static const struct wmi_ops wmi_10_1_ops = {
 	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
 	.gen_echo = ath10k_wmi_op_gen_echo,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 	/* .gen_bcn_tmpl not implemented */
 	/* .gen_prb_tmpl not implemented */
 	/* .gen_p2p_go_bcn_ie not implemented */
@@ -8929,6 +8977,8 @@ static const struct wmi_ops wmi_10_2_ops = {
 	.gen_delba_send = ath10k_wmi_op_gen_delba_send,
 	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 	/* .gen_pdev_enable_adaptive_cca not implemented */
 };
 
@@ -8999,6 +9049,8 @@ static const struct wmi_ops wmi_10_2_4_ops = {
 	.gen_pdev_enable_adaptive_cca =
 		ath10k_wmi_op_gen_pdev_enable_adaptive_cca,
 	.get_vdev_subtype = ath10k_wmi_10_2_4_op_get_vdev_subtype,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 	/* .gen_bcn_tmpl not implemented */
 	/* .gen_prb_tmpl not implemented */
 	/* .gen_p2p_go_bcn_ie not implemented */
@@ -9078,6 +9130,8 @@ static const struct wmi_ops wmi_10_4_ops = {
 	.gen_pdev_bss_chan_info_req = ath10k_wmi_10_2_op_gen_pdev_bss_chan_info,
 	.gen_echo = ath10k_wmi_op_gen_echo,
 	.gen_pdev_get_tpc_config = ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 };
 
 int ath10k_wmi_attach(struct ath10k *ar)
diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h
index 3622025..a9dfc73 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.h
+++ b/drivers/net/wireless/ath/ath10k/wmi.h
@@ -2942,6 +2942,41 @@ enum wmi_10_4_feature_mask {
 
 };
 
+/* WMI_GPIO_CONFIG_CMDID */
+enum {
+	WMI_GPIO_PULL_NONE,
+	WMI_GPIO_PULL_UP,
+	WMI_GPIO_PULL_DOWN,
+};
+
+enum {
+	WMI_GPIO_INTTYPE_DISABLE,
+	WMI_GPIO_INTTYPE_RISING_EDGE,
+	WMI_GPIO_INTTYPE_FALLING_EDGE,
+	WMI_GPIO_INTTYPE_BOTH_EDGE,
+	WMI_GPIO_INTTYPE_LEVEL_LOW,
+	WMI_GPIO_INTTYPE_LEVEL_HIGH
+};
+
+/* WMI_GPIO_CONFIG_CMDID */
+struct wmi_gpio_config_cmd {
+	__le32 gpio_num;             /* GPIO number to be setup */
+	__le32 input;                /* 0 - Output/ 1 - Input */
+	__le32 pull_type;            /* Pull type defined above */
+	__le32 intr_mode;            /* Interrupt mode defined above (Input) */
+} __packed;
+
+/* WMI_GPIO_OUTPUT_CMDID */
+struct wmi_gpio_output_cmd {
+	__le32 gpio_num;    /* GPIO number to be setup */
+	__le32 set;         /* Set the GPIO pin*/
+} __packed;
+
+/* WMI_GPIO_INPUT_EVENTID */
+struct wmi_gpio_input_event {
+	__le32 gpio_num;    /* GPIO number which changed state */
+} __packed;
+
 struct wmi_ext_resource_config_10_4_cmd {
 	/* contains enum wmi_host_platform_type */
 	__le32 host_platform_config;
@@ -6357,7 +6392,19 @@ struct wmi_10_2_peer_assoc_complete_cmd {
 	__le32 info0; /* WMI_PEER_ASSOC_INFO0_ */
 } __packed;
 
-#define PEER_BW_RXNSS_OVERRIDE_OFFSET  31
+#define BW_NSS_FWCONF_MAP_ENABLE	BIT(31)
+#define BW_NSS_FWCONF_MAP_160MHZ_LSB	(0)
+#define BW_NSS_FWCONF_MAP_160MHZ_MASK	(0x00000007)
+#define BW_NSS_FWCONF_MAP_80_80MHZ_LSB	(3)
+#define BW_NSS_FWCONF_MAP_80_80MHZ_MASK (0x00000038)
+#define BW_NSS_FWCONF_MAP_MASK		(0x0000003F)
+
+#define GET_BW_NSS_FWCONF_160(x)	(MS(x, BW_NSS_FWCONF_MAP_160MHZ) + 1)
+#define GET_BW_NSS_FWCONF_80_80(x)	(MS(x, BW_NSS_FWCONF_MAP_80_80MHZ) + 1)
+
+/* Values defined to set 160 MHz Bandwidth NSS Mapping into FW*/
+#define BW_NSS_FWCONF_160(x)		(BW_NSS_FWCONF_MAP_ENABLE | SM(x - 1, BW_NSS_FWCONF_MAP_160MHZ))
+#define BW_NSS_FWCONF_80_80(x)		(BW_NSS_FWCONF_MAP_ENABLE | SM(x - 1, BW_NSS_FWCONF_MAP_80_80MHZ))
 
 struct wmi_10_4_peer_assoc_complete_cmd {
 	struct wmi_10_2_peer_assoc_complete_cmd cmd;
diff --git a/drivers/net/wireless/ath/ath5k/ath5k.h b/drivers/net/wireless/ath/ath5k/ath5k.h
index f73c794..211a8d9 100644
--- a/drivers/net/wireless/ath/ath5k/ath5k.h
+++ b/drivers/net/wireless/ath/ath5k/ath5k.h
@@ -1372,6 +1372,7 @@ struct ath5k_hw {
 	u8			ah_coverage_class;
 	bool			ah_ack_bitrate_high;
 	u8			ah_bwmode;
+	u8			ah_bwmode_debug;
 	bool			ah_short_slot;
 
 	/* Antenna Control */
diff --git a/drivers/net/wireless/ath/ath5k/base.c b/drivers/net/wireless/ath/ath5k/base.c
index 56e9431..672c67e 100644
--- a/drivers/net/wireless/ath/ath5k/base.c
+++ b/drivers/net/wireless/ath/ath5k/base.c
@@ -466,6 +466,9 @@ ath5k_chan_set(struct ath5k_hw *ah, struct cfg80211_chan_def *chandef)
 		return -EINVAL;
 	}
 
+	if (ah->ah_bwmode_debug != AR5K_BWMODE_DEFAULT)
+		ah->ah_bwmode = ah->ah_bwmode_debug;
+
 	/*
 	 * To switch channels clear any pending DMA operations;
 	 * wait long enough for the RX fifo to drain, reset the
@@ -1965,7 +1968,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
 	}
 
 	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
-			ah->num_mesh_vifs > 1) ||
+			ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) ||
 			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
 		u64 tsf = ath5k_hw_get_tsf64(ah);
 		u32 tsftu = TSF_TO_TU(tsf);
@@ -2051,7 +2054,7 @@ ath5k_beacon_update_timers(struct ath5k_hw *ah, u64 bc_tsf)
 
 	intval = ah->bintval & AR5K_BEACON_PERIOD;
 	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
-		+ ah->num_mesh_vifs > 1) {
+		+ ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) {
 		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
 		if (intval < 15)
 			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
@@ -2518,6 +2521,7 @@ static const struct ieee80211_iface_limit if_limits[] = {
 				 BIT(NL80211_IFTYPE_MESH_POINT) |
 #endif
 				 BIT(NL80211_IFTYPE_AP) },
+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
 };
 
 static const struct ieee80211_iface_combination if_comb = {
diff --git a/drivers/net/wireless/ath/ath5k/debug.c b/drivers/net/wireless/ath/ath5k/debug.c
index e01faf6..a0dedd1 100644
--- a/drivers/net/wireless/ath/ath5k/debug.c
+++ b/drivers/net/wireless/ath/ath5k/debug.c
@@ -822,6 +822,97 @@ static const struct file_operations fops_ani = {
 	.llseek = default_llseek,
 };
 
+/* debugfs: bwmode */
+
+static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[15];
+	unsigned int len = 0;
+
+	int cur_ah_bwmode = ah->ah_bwmode_debug;
+
+#define print_selected(MODE, LABEL) \
+	if (cur_ah_bwmode == MODE) \
+		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
+	else \
+		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
+	len += snprintf(buf+len, sizeof(buf)-len, " ");
+
+	print_selected(AR5K_BWMODE_5MHZ, "5");
+	print_selected(AR5K_BWMODE_10MHZ, "10");
+	print_selected(AR5K_BWMODE_DEFAULT, "20");
+	print_selected(AR5K_BWMODE_40MHZ, "40");
+#undef print_selected
+
+	len += snprintf(buf+len, sizeof(buf)-len, "\n");
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_bwmode(struct file *file,
+				 const char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[3];
+	int bw = 20;
+	int tobwmode = AR5K_BWMODE_DEFAULT;
+
+	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+		return -EFAULT;
+
+	/* TODO: Add check for active interface */
+
+	if(strncmp(buf, "5", 1) == 0 ) {
+		tobwmode = AR5K_BWMODE_5MHZ;
+		bw = 5;
+	} else if ( strncmp(buf, "10", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_10MHZ;
+		bw = 10;
+	} else if ( strncmp(buf, "20", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_DEFAULT;
+		bw = 20;
+	} else if ( strncmp(buf, "40", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_40MHZ;
+		bw = 40;
+	} else
+		return -EINVAL;
+
+	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
+		bw, tobwmode);
+
+	switch (ah->ah_radio) {
+	/* TODO: only define radios that actually support 5/10mhz channels */
+	case AR5K_RF5413:
+	case AR5K_RF5110:
+	case AR5K_RF5111:
+	case AR5K_RF5112:
+	case AR5K_RF2413:
+	case AR5K_RF2316:
+	case AR5K_RF2317:
+	case AR5K_RF2425:
+		if(ah->ah_bwmode_debug != tobwmode) {
+			mutex_lock(&ah->lock);
+			ah->ah_bwmode = tobwmode;
+			ah->ah_bwmode_debug = tobwmode;
+			mutex_unlock(&ah->lock);
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return count;
+}
+
+static const struct file_operations fops_bwmode = {
+	.read = read_file_bwmode,
+	.write = write_file_bwmode,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 /* debugfs: queues etc */
 
@@ -1016,6 +1107,8 @@ ath5k_debug_init_device(struct ath5k_hw *ah)
 	debugfs_create_file("queue", 0600, phydir, ah, &fops_queue);
 	debugfs_create_bool("32khz_clock", 0600, phydir,
 			    &ah->ah_use_32khz_clock);
+	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
+			    &fops_bwmode);
 }
 
 /* functions used in other places */
diff --git a/drivers/net/wireless/ath/ath5k/dma.c b/drivers/net/wireless/ath/ath5k/dma.c
index e6c52f7..53e075e 100644
--- a/drivers/net/wireless/ath/ath5k/dma.c
+++ b/drivers/net/wireless/ath/ath5k/dma.c
@@ -869,10 +869,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
 	 * guess we can tweak it and see how it goes ;-)
 	 */
 	if (ah->ah_version != AR5K_AR5210) {
+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
 		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
 			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
 		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
 			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_128B);
+#else
+		/* WAR for AR71xx PCI bug */
+		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
+			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
+		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
+			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_4B);
+#endif
 	}
 
 	/* Pre-enable interrupts on 5211/5212*/
diff --git a/drivers/net/wireless/ath/ath5k/initvals.c b/drivers/net/wireless/ath/ath5k/initvals.c
index ee1c2fa..122fe1c 100644
--- a/drivers/net/wireless/ath/ath5k/initvals.c
+++ b/drivers/net/wireless/ath/ath5k/initvals.c
@@ -62,8 +62,14 @@ static const struct ath5k_ini ar5210_ini[] = {
 	{ AR5K_IMR,		0 },
 	{ AR5K_IER,		AR5K_IER_DISABLE },
 	{ AR5K_BSR,		0, AR5K_INI_READ },
+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
 	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
 	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
+#else
+	/* WAR for AR71xx PCI bug */
+	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
+	{ AR5K_RXCFG,		AR5K_DMASIZE_4B },
+#endif
 	{ AR5K_CFG,		AR5K_INIT_CFG },
 	{ AR5K_TOPS,		8 },
 	{ AR5K_RXNOFRM,		8 },
diff --git a/drivers/net/wireless/ath/ath5k/mac80211-ops.c b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
index 16e052d..f20c5cc 100644
--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
@@ -86,13 +86,8 @@ ath5k_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		goto end;
 	}
 
-	/* Don't allow other interfaces if one ad-hoc is configured.
-	 * TODO: Fix the problems with ad-hoc and multiple other interfaces.
-	 * We would need to operate the HW in ad-hoc mode to allow TSF updates
-	 * for the IBSS, but this breaks with additional AP or STA interfaces
-	 * at the moment. */
-	if (ah->num_adhoc_vifs ||
-	    (ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {
+	/* Don't allow more than one ad-hoc interface */
+	if (ah->num_adhoc_vifs && vif->type == NL80211_IFTYPE_ADHOC) {
 		ATH5K_ERR(ah, "Only one single ad-hoc interface is allowed.\n");
 		ret = -ELNRNG;
 		goto end;
diff --git a/drivers/net/wireless/ath/ath5k/pci.c b/drivers/net/wireless/ath/ath5k/pci.c
index c6156cc..c9a1854 100644
--- a/drivers/net/wireless/ath/ath5k/pci.c
+++ b/drivers/net/wireless/ath/ath5k/pci.c
@@ -21,6 +21,7 @@
 #include <linux/pci-aspm.h>
 #include <linux/etherdevice.h>
 #include <linux/module.h>
+#include <linux/ath5k_platform.h>
 #include "../ath.h"
 #include "ath5k.h"
 #include "debug.h"
@@ -47,6 +48,8 @@ static const struct pci_device_id ath5k_pci_id_table[] = {
 	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
 	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
 	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
+	{ PCI_VDEVICE(ATHEROS, 0xff16) }, /* 2413,2414 sx76x on lantiq_danube */
+	{ PCI_VDEVICE(ATHEROS, 0xff1a) }, /* 2417 arv45xx on lantiq_danube */
 	{ PCI_VDEVICE(ATHEROS, 0xff1b) }, /* AR5BXB63 */
 	{ 0 }
 };
@@ -72,7 +75,7 @@ static void ath5k_pci_read_cachesize(struct ath_common *common, int *csz)
 }
 
 /*
- * Read from eeprom
+ * Read from eeprom or platform_data
  */
 static bool
 ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
@@ -80,6 +83,19 @@ ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
 	struct ath5k_hw *ah = (struct ath5k_hw *) common->ah;
 	u32 status, timeout;
 
+	struct ath5k_platform_data *pdata = NULL;
+
+	if (ah->pdev)
+		pdata = ah->pdev->dev.platform_data;
+
+	if (pdata && pdata->eeprom_data && pdata->eeprom_data[61] == AR5K_EEPROM_MAGIC_VALUE) {
+		if (offset >= ATH5K_PLAT_EEP_MAX_WORDS)
+			return false;
+
+		*data = pdata->eeprom_data[offset];
+		return true;
+	}
+
 	/*
 	 * Initialize EEPROM access
 	 */
@@ -123,6 +139,16 @@ static int ath5k_pci_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)
 	u16 data;
 	int octet;
 
+	struct ath5k_platform_data *pdata = NULL;
+
+	if (ah->pdev)
+		pdata = ah->pdev->dev.platform_data;
+
+	if (pdata && pdata->macaddr) {
+		memcpy(mac, pdata->macaddr, ETH_ALEN);
+		return 0;
+	}
+
 	AR5K_EEPROM_READ(0x20, data);
 
 	for (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {
diff --git a/drivers/net/wireless/ath/ath5k/reset.c b/drivers/net/wireless/ath/ath5k/reset.c
index 56d7925..baf0b9d 100644
--- a/drivers/net/wireless/ath/ath5k/reset.c
+++ b/drivers/net/wireless/ath/ath5k/reset.c
@@ -1154,6 +1154,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum nl80211_iftype op_mode,
 	tsf_lo = 0;
 	mode = 0;
 
+#if 0
 	/*
 	 * Sanity check for fast flag
 	 * Fast channel change only available
@@ -1161,6 +1162,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum nl80211_iftype op_mode,
 	 */
 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
 	(ah->ah_radio != AR5K_RF5413))
+#endif
 		fast = false;
 
 	/* Disable sleep clock operation
diff --git a/drivers/net/wireless/ath/ath9k/Kconfig b/drivers/net/wireless/ath/ath9k/Kconfig
index 2021ef2..675eec7 100644
--- a/drivers/net/wireless/ath/ath9k/Kconfig
+++ b/drivers/net/wireless/ath/ath9k/Kconfig
@@ -59,6 +59,19 @@ config ATH9K_AHB
 	  Say Y, if you have a SoC with a compatible built-in
 	  wireless MAC. Say N if unsure.
 
+config ATH9K_UBNTHSR
+	bool "Ubiquiti UniFi Outdoor Plus HSR support"
+	depends on ATH9K
+	---help---
+	  This options enables code to control the HSR RF
+	  filter in the receive path of the Ubiquiti UniFi
+	  Outdoor Plus access point.
+
+	  Say Y if you want to use the access point. The
+	  code will only be used if the device is detected,
+	  so it does not harm other setup other than occupying
+	  a bit of memory.
+
 config ATH9K_DEBUGFS
 	bool "Atheros ath9k debugging"
 	depends on ATH9K && DEBUG_FS
@@ -119,7 +132,7 @@ config ATH9K_DFS_CERTIFIED
 	  except increase code size.
 
 config ATH9K_DYNACK
-	bool "Atheros ath9k ACK timeout estimation algorithm (EXPERIMENTAL)"
+	bool "Atheros ath9k ACK timeout estimation algorithm"
 	depends on ATH9K
 	default n
 	---help---
diff --git a/drivers/net/wireless/ath/ath9k/Makefile b/drivers/net/wireless/ath/ath9k/Makefile
index 98156d5..bb2d7c6 100644
--- a/drivers/net/wireless/ath/ath9k/Makefile
+++ b/drivers/net/wireless/ath/ath9k/Makefile
@@ -17,6 +17,7 @@ ath9k-$(CPTCFG_ATH9K_DFS_CERTIFIED) += dfs.o
 ath9k-$(CPTCFG_ATH9K_TX99) += tx99.o
 ath9k-$(CPTCFG_ATH9K_WOW) += wow.o
 ath9k-$(CPTCFG_ATH9K_HWRNG) += rng.o
+ath9k-$(CPTCFG_ATH9K_UBNTHSR) += hsr.o
 
 ath9k-$(CPTCFG_ATH9K_DEBUGFS) += debug.o
 
diff --git a/drivers/net/wireless/ath/ath9k/ahb.c b/drivers/net/wireless/ath/ath9k/ahb.c
index 63019c3..bfa0258 100644
--- a/drivers/net/wireless/ath/ath9k/ahb.c
+++ b/drivers/net/wireless/ath/ath9k/ahb.c
@@ -20,7 +20,15 @@
 #include <linux/platform_device.h>
 #include <linux/module.h>
 #include <linux/mod_devicetable.h>
+#include <linux/of_device.h>
 #include "ath9k.h"
+#include <linux/ath9k_platform.h>
+
+#ifdef CONFIG_OF
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#include <linux/mtd/mtd.h>
+#endif
 
 static const struct platform_device_id ath9k_platform_id_table[] = {
 	{
@@ -69,6 +77,235 @@ static const struct ath_bus_ops ath_ahb_bus_ops  = {
 	.eeprom_read = ath_ahb_eeprom_read,
 };
 
+#ifdef CONFIG_OF
+
+#define QCA955X_DDR_CTL_CONFIG          0x108
+#define QCA955X_DDR_CTL_CONFIG_ACT_WMAC BIT(23)
+
+static int of_get_wifi_cal(struct device_node *np, struct ath9k_platform_data *pdata)
+{
+#ifdef CONFIG_MTD
+	struct device_node *mtd_np = NULL;
+	size_t retlen;
+	int size, ret;
+	struct mtd_info *mtd;
+	const char *part;
+	const __be32 *list;
+	phandle phandle;
+
+	list = of_get_property(np, "mtd-cal-data", &size);
+	if (!list)
+		return 0;
+
+	if (size != (2 * sizeof(*list)))
+		return 1;
+
+	phandle = be32_to_cpup(list++);
+	if (phandle)
+		mtd_np = of_find_node_by_phandle(phandle);
+
+	if (!mtd_np)
+		return 1;
+
+	part = of_get_property(mtd_np, "label", NULL);
+	if (!part)
+		part = mtd_np->name;
+
+	mtd = get_mtd_device_nm(part);
+	if (IS_ERR(mtd))
+		return 1;
+
+	ret = mtd_read(mtd, be32_to_cpup(list), sizeof(pdata->eeprom_data),
+			&retlen, (u8*)pdata->eeprom_data);
+	put_mtd_device(mtd);
+
+#endif
+	return 0;
+}
+
+static int ar913x_wmac_reset(void)
+{
+	ath79_device_reset_set(AR913X_RESET_AMBA2WMAC);
+	mdelay(10);
+
+	ath79_device_reset_clear(AR913X_RESET_AMBA2WMAC);
+	mdelay(10);
+
+	return 0;
+}
+
+static int ar933x_wmac_reset(void)
+{
+	int retries = 20;
+
+	ath79_device_reset_set(AR933X_RESET_WMAC);
+	ath79_device_reset_clear(AR933X_RESET_WMAC);
+
+	while (1) {
+		u32 bootstrap;
+
+		bootstrap = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+		if ((bootstrap & AR933X_BOOTSTRAP_EEPBUSY) == 0)
+			return 0;
+
+		if (retries-- == 0)
+			break;
+
+		udelay(10000);
+	}
+
+	pr_err("ar933x: WMAC reset timed out");
+	return -ETIMEDOUT;
+}
+
+static int qca955x_wmac_reset(void)
+{
+	int i;
+
+	/* Try to wait for WMAC DDR activity to stop */
+	for (i = 0; i < 10; i++) {
+		if (!(__raw_readl(ath79_ddr_base + QCA955X_DDR_CTL_CONFIG) &
+		    QCA955X_DDR_CTL_CONFIG_ACT_WMAC))
+			break;
+
+		udelay(10);
+	}
+
+	ath79_device_reset_set(QCA955X_RESET_RTC);
+	udelay(10);
+	ath79_device_reset_clear(QCA955X_RESET_RTC);
+	udelay(10);
+
+	return 0;
+}
+
+enum {
+	AR913X_WMAC = 0,
+	AR933X_WMAC,
+	AR934X_WMAC,
+	QCA953X_WMAC,
+	QCA955X_WMAC,
+	QCA956X_WMAC,
+};
+
+static int ar9330_get_soc_revision(void)
+{
+	if (ath79_soc_rev == 1)
+		return ath79_soc_rev;
+
+	return 0;
+}
+
+static int ath79_get_soc_revision(void)
+{
+	return ath79_soc_rev;
+}
+
+static const struct of_ath_ahb_data {
+	u16 dev_id;
+	u32 bootstrap_reg;
+	u32 bootstrap_ref;
+
+	int (*soc_revision)(void);
+	int (*wmac_reset)(void);
+} of_ath_ahb_data[] = {
+	[AR913X_WMAC] = {
+		.dev_id = AR5416_AR9100_DEVID,
+		.wmac_reset = ar913x_wmac_reset,
+
+	},
+	[AR933X_WMAC] = {
+		.dev_id = AR9300_DEVID_AR9330,
+		.bootstrap_reg = AR933X_RESET_REG_BOOTSTRAP,
+		.bootstrap_ref = AR933X_BOOTSTRAP_REF_CLK_40,
+		.soc_revision = ar9330_get_soc_revision,
+		.wmac_reset = ar933x_wmac_reset,
+	},
+	[AR934X_WMAC] = {
+		.dev_id = AR9300_DEVID_AR9340,
+		.bootstrap_reg = AR934X_RESET_REG_BOOTSTRAP,
+		.bootstrap_ref = AR934X_BOOTSTRAP_REF_CLK_40,
+		.soc_revision = ath79_get_soc_revision,
+	},
+	[QCA953X_WMAC] = {
+		.dev_id = AR9300_DEVID_AR953X,
+		.bootstrap_reg = QCA953X_RESET_REG_BOOTSTRAP,
+		.bootstrap_ref = QCA953X_BOOTSTRAP_REF_CLK_40,
+		.soc_revision = ath79_get_soc_revision,
+	},
+	[QCA955X_WMAC] = {
+		.dev_id = AR9300_DEVID_QCA955X,
+		.bootstrap_reg = QCA955X_RESET_REG_BOOTSTRAP,
+		.bootstrap_ref = QCA955X_BOOTSTRAP_REF_CLK_40,
+		.wmac_reset = qca955x_wmac_reset,
+	},
+	[QCA956X_WMAC] = {
+		.dev_id = AR9300_DEVID_QCA956X,
+		.bootstrap_reg = QCA956X_RESET_REG_BOOTSTRAP,
+		.bootstrap_ref = QCA956X_BOOTSTRAP_REF_CLK_40,
+		.soc_revision = ath79_get_soc_revision,
+	},
+};
+
+const struct of_device_id of_ath_ahb_match[] = {
+	{ .compatible = "qca,ar9130-wmac", .data = &of_ath_ahb_data[AR913X_WMAC] },
+	{ .compatible = "qca,ar9330-wmac", .data = &of_ath_ahb_data[AR933X_WMAC] },
+	{ .compatible = "qca,ar9340-wmac", .data = &of_ath_ahb_data[AR934X_WMAC] },
+	{ .compatible = "qca,qca9530-wmac", .data = &of_ath_ahb_data[QCA953X_WMAC] },
+	{ .compatible = "qca,qca9550-wmac", .data = &of_ath_ahb_data[QCA955X_WMAC] },
+	{ .compatible = "qca,qca9560-wmac", .data = &of_ath_ahb_data[QCA956X_WMAC] },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_ath_ahb_match);
+
+static int of_ath_ahb_probe(struct platform_device *pdev)
+{
+	struct ath9k_platform_data *pdata;
+	const struct of_device_id *match;
+	const struct of_ath_ahb_data *data;
+	u8 led_pin;
+
+	match = of_match_device(of_ath_ahb_match, &pdev->dev);
+	data = (const struct of_ath_ahb_data *)match->data;
+
+	pdata = dev_get_platdata(&pdev->dev);
+
+	if (!of_property_read_u8(pdev->dev.of_node, "qca,led-pin", &led_pin))
+		pdata->led_pin = led_pin;
+	else
+		pdata->led_pin = -1;
+
+	if (of_property_read_bool(pdev->dev.of_node, "qca,disable-2ghz"))
+		pdata->disable_2ghz = true;
+
+	if (of_property_read_bool(pdev->dev.of_node, "qca,disable-5ghz"))
+		pdata->disable_5ghz = true;
+
+	if (of_property_read_bool(pdev->dev.of_node, "qca,tx-gain-buffalo"))
+		pdata->tx_gain_buffalo = true;
+
+	if (data->wmac_reset) {
+		data->wmac_reset();
+		pdata->external_reset = data->wmac_reset;
+	}
+
+	if (data->bootstrap_reg && data->bootstrap_ref) {
+		u32 t = ath79_reset_rr(data->bootstrap_reg);
+		if (t & data->bootstrap_ref)
+			pdata->is_clk_25mhz = false;
+		else
+			pdata->is_clk_25mhz = true;
+	}
+
+	pdata->get_mac_revision = data->soc_revision;
+
+	if (of_get_wifi_cal(pdev->dev.of_node, pdata))
+		dev_err(&pdev->dev, "failed to load calibration data from mtd device\n");
+
+	return data->dev_id;
+}
+#endif
+
 static int ath_ahb_probe(struct platform_device *pdev)
 {
 	void __iomem *mem;
@@ -80,6 +317,17 @@ static int ath_ahb_probe(struct platform_device *pdev)
 	int ret = 0;
 	struct ath_hw *ah;
 	char hw_name[64];
+	u16 dev_id;
+
+	if (id)
+		dev_id = id->driver_data;
+
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node)
+		pdev->dev.platform_data = devm_kzalloc(&pdev->dev,
+					sizeof(struct ath9k_platform_data),
+					GFP_KERNEL);
+#endif
 
 	if (!dev_get_platdata(&pdev->dev)) {
 		dev_err(&pdev->dev, "no platform data specified\n");
@@ -122,13 +370,16 @@ static int ath_ahb_probe(struct platform_device *pdev)
 	sc->mem = mem;
 	sc->irq = irq;
 
+#ifdef CONFIG_OF
+	dev_id = of_ath_ahb_probe(pdev);
+#endif
 	ret = request_irq(irq, ath_isr, IRQF_SHARED, "ath9k", sc);
 	if (ret) {
 		dev_err(&pdev->dev, "request_irq failed\n");
 		goto err_free_hw;
 	}
 
-	ret = ath9k_init_device(id->driver_data, sc, &ath_ahb_bus_ops);
+	ret = ath9k_init_device(dev_id, sc, &ath_ahb_bus_ops);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to initialize device\n");
 		goto err_irq;
@@ -159,6 +410,9 @@ static int ath_ahb_remove(struct platform_device *pdev)
 		free_irq(sc->irq, sc);
 		ieee80211_free_hw(sc->hw);
 	}
+#ifdef CONFIG_OF
+	pdev->dev.platform_data = NULL;
+#endif
 
 	return 0;
 }
@@ -168,6 +422,9 @@ static struct platform_driver ath_ahb_driver = {
 	.remove     = ath_ahb_remove,
 	.driver		= {
 		.name	= "ath9k",
+#ifdef CONFIG_OF
+		.of_match_table = of_ath_ahb_match,
+#endif
 	},
 	.id_table    = ath9k_platform_id_table,
 };
diff --git a/drivers/net/wireless/ath/ath9k/ani.h b/drivers/net/wireless/ath/ath9k/ani.h
index c40965b..f66f7ed 100644
--- a/drivers/net/wireless/ath/ath9k/ani.h
+++ b/drivers/net/wireless/ath/ath9k/ani.h
@@ -42,7 +42,7 @@
 #define ATH9K_ANI_PERIOD                  300
 
 /* in ms */
-#define ATH9K_ANI_POLLINTERVAL            1000
+#define ATH9K_ANI_POLLINTERVAL            300
 
 #define ATH9K_SIG_FIRSTEP_SETTING_MIN     0
 #define ATH9K_SIG_FIRSTEP_SETTING_MAX     20
diff --git a/drivers/net/wireless/ath/ath9k/ar5008_phy.c b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
index ef2dd68..7533779 100644
--- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
@@ -953,55 +953,6 @@ static bool ar5008_hw_ani_control_new(struct ath_hw *ah,
 		 * on == 0 means more noise imm
 		 */
 		u32 on = param ? 1 : 0;
-		/*
-		 * make register setting for default
-		 * (weak sig detect ON) come from INI file
-		 */
-		int m1ThreshLow = on ?
-			aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
-		int m2ThreshLow = on ?
-			aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
-		int m1Thresh = on ?
-			aniState->iniDef.m1Thresh : m1Thresh_off;
-		int m2Thresh = on ?
-			aniState->iniDef.m2Thresh : m2Thresh_off;
-		int m2CountThr = on ?
-			aniState->iniDef.m2CountThr : m2CountThr_off;
-		int m2CountThrLow = on ?
-			aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
-		int m1ThreshLowExt = on ?
-			aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
-		int m2ThreshLowExt = on ?
-			aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
-		int m1ThreshExt = on ?
-			aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
-		int m2ThreshExt = on ?
-			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
-			      m1ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
-			      m2ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M1_THRESH, m1Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2_THRESH, m2Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2COUNT_THR, m2CountThr);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
-			      m2CountThrLow);
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW, m1ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW, m2ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH, m1ThreshExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH, m2ThreshExt);
 
 		if (on)
 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
@@ -1324,9 +1275,30 @@ void ar5008_hw_init_rate_txpower(struct ath_hw *ah, int16_t *rate_array,
 	}
 }
 
+static void ar5008_hw_get_adc_entropy(struct ath_hw *ah, u8 *buf, size_t len)
+{
+	int i, j;
+
+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
+	REG_RMW_FIELD(ah, AR_PHY_TEST2, AR_PHY_TEST2_RX_OBS_SEL, 0);
+
+	memset(buf, 0, len);
+	for (i = 0; i < len; i++) {
+		for (j = 0; j < 4; j++) {
+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
+
+			buf[i] <<= 2;
+			buf[i] |= (regval & 1) | ((regval & BIT(9)) >> 8);
+			udelay(1);
+		}
+	}
+}
+
 int ar5008_hw_attach_phy_ops(struct ath_hw *ah)
 {
 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
+	struct ath_hw_ops *ops = ath9k_hw_ops(ah);
 	static const u32 ar5416_cca_regs[6] = {
 		AR_PHY_CCA,
 		AR_PHY_CH1_CCA,
@@ -1341,6 +1313,8 @@ int ar5008_hw_attach_phy_ops(struct ath_hw *ah)
 	if (ret)
 	    return ret;
 
+	ops->get_adc_entropy = ar5008_hw_get_adc_entropy;
+
 	priv_ops->rf_set_freq = ar5008_hw_set_channel;
 	priv_ops->spur_mitigate_freq = ar5008_hw_spur_mitigate;
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9002_phy.h b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
index 2b58245..d20a936 100644
--- a/drivers/net/wireless/ath/ath9k/ar9002_phy.h
+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
@@ -20,6 +20,12 @@
 #define PHY_AGC_CLR             0x10000000
 #define RFSILENT_BB             0x00002000
 
+#define AR_PHY_TEST_BBB_OBS_SEL       0x780000
+#define AR_PHY_TEST_BBB_OBS_SEL_S     19
+
+#define AR_PHY_TEST_RX_OBS_SEL_BIT5_S 23
+#define AR_PHY_TEST_RX_OBS_SEL_BIT5   (1 << AR_PHY_TEST_RX_OBS_SEL_BIT5_S)
+
 #define AR_PHY_TURBO                0x9804
 #define AR_PHY_FC_TURBO_MODE        0x00000001
 #define AR_PHY_FC_TURBO_SHORT       0x00000002
@@ -36,6 +42,9 @@
 
 #define AR_PHY_TEST2			0x9808
 
+#define AR_PHY_TEST2_RX_OBS_SEL        0x3C00
+#define AR_PHY_TEST2_RX_OBS_SEL_S      10
+
 #define AR_PHY_TIMING2           0x9810
 #define AR_PHY_TIMING3           0x9814
 #define AR_PHY_TIMING3_DSC_MAN   0xFFFE0000
@@ -393,6 +402,8 @@
 #define AR_PHY_RFBUS_GRANT       0x9C20
 #define AR_PHY_RFBUS_GRANT_EN    0x00000001
 
+#define AR_PHY_TST_ADC      0x9C24
+
 #define AR_PHY_CHAN_INFO_GAIN_DIFF             0x9CF4
 #define AR_PHY_CHAN_INFO_GAIN_DIFF_UPPER_LIMIT 320
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.c b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
index 68772b5..bf4ae1a 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
@@ -42,20 +42,6 @@ static const int cycpwrThr1_table[] =
 /* level:  0   1   2   3   4   5   6   7   8  */
 	{ -6, -4, -2,  0,  2,  4,  6,  8 };     /* lvl 0-7, default 3 */
 
-/*
- * register values to turn OFDM weak signal detection OFF
- */
-static const int m1ThreshLow_off = 127;
-static const int m2ThreshLow_off = 127;
-static const int m1Thresh_off = 127;
-static const int m2Thresh_off = 127;
-static const int m2CountThr_off =  31;
-static const int m2CountThrLow_off =  63;
-static const int m1ThreshLowExt_off = 127;
-static const int m2ThreshLowExt_off = 127;
-static const int m1ThreshExt_off = 127;
-static const int m2ThreshExt_off = 127;
-
 static const u8 ofdm2pwr[] = {
 	ALL_TARGET_LEGACY_6_24,
 	ALL_TARGET_LEGACY_6_24,
@@ -1095,11 +1081,6 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ath9k_channel *chan = ah->curchan;
 	struct ar5416AniState *aniState = &ah->ani;
-	int m1ThreshLow, m2ThreshLow;
-	int m1Thresh, m2Thresh;
-	int m2CountThr, m2CountThrLow;
-	int m1ThreshLowExt, m2ThreshLowExt;
-	int m1ThreshExt, m2ThreshExt;
 	s32 value, value2;
 
 	switch (cmd & ah->ani_function) {
@@ -1113,61 +1094,6 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
 		 */
 		u32 on = param ? 1 : 0;
 
-		if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
-			goto skip_ws_det;
-
-		m1ThreshLow = on ?
-			aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
-		m2ThreshLow = on ?
-			aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
-		m1Thresh = on ?
-			aniState->iniDef.m1Thresh : m1Thresh_off;
-		m2Thresh = on ?
-			aniState->iniDef.m2Thresh : m2Thresh_off;
-		m2CountThr = on ?
-			aniState->iniDef.m2CountThr : m2CountThr_off;
-		m2CountThrLow = on ?
-			aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
-		m1ThreshLowExt = on ?
-			aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
-		m2ThreshLowExt = on ?
-			aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
-		m1ThreshExt = on ?
-			aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
-		m2ThreshExt = on ?
-			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
-			      m1ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
-			      m2ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M1_THRESH,
-			      m1Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2_THRESH,
-			      m2Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2COUNT_THR,
-			      m2CountThr);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
-			      m2CountThrLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW,
-			      m1ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW,
-			      m2ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH,
-			      m1ThreshExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH,
-			      m2ThreshExt);
-skip_ws_det:
 		if (on)
 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
 				    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);
@@ -1945,6 +1871,26 @@ void ar9003_hw_init_rate_txpower(struct ath_hw *ah, u8 *rate_array,
 	}
 }
 
+static void ar9003_hw_get_adc_entropy(struct ath_hw *ah, u8 *buf, size_t len)
+{
+	int i, j;
+
+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
+	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS, AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
+
+	memset(buf, 0, len);
+	for (i = 0; i < len; i++) {
+		for (j = 0; j < 4; j++) {
+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
+
+			buf[i] <<= 2;
+			buf[i] |= (regval & 1) | ((regval & BIT(10)) >> 9);
+			udelay(1);
+		}
+	}
+}
+
 void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
 {
 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
@@ -1981,6 +1927,7 @@ void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
 	priv_ops->set_radar_params = ar9003_hw_set_radar_params;
 	priv_ops->fast_chan_change = ar9003_hw_fast_chan_change;
 
+	ops->get_adc_entropy = ar9003_hw_get_adc_entropy;
 	ops->antdiv_comb_conf_get = ar9003_hw_antdiv_comb_conf_get;
 	ops->antdiv_comb_conf_set = ar9003_hw_antdiv_comb_conf_set;
 	ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
diff --git a/drivers/net/wireless/ath/ath9k/ath9k.h b/drivers/net/wireless/ath/ath9k/ath9k.h
index 22ebe16..15ea905 100644
--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -24,6 +24,8 @@
 #include <linux/completion.h>
 #include <linux/time.h>
 #include <linux/hw_random.h>
+#include <linux/gpio/driver.h>
+#include <linux/reset.h>
 
 #include "common.h"
 #include "debug.h"
@@ -88,7 +90,7 @@ int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,
 		(_l) &= ((_sz) - 1);		\
 	} while (0)
 
-#define ATH_RXBUF               512
+#define ATH_RXBUF               256
 #define ATH_TXBUF               512
 #define ATH_TXBUF_RESERVE       5
 #define ATH_TXMAXTRY            13
@@ -850,6 +852,9 @@ static inline int ath9k_dump_btcoex(struct ath_softc *sc, u8 *buf, u32 size)
 #ifdef CPTCFG_MAC80211_LEDS
 void ath_init_leds(struct ath_softc *sc);
 void ath_deinit_leds(struct ath_softc *sc);
+int ath_create_gpio_led(struct ath_softc *sc, int gpio, const char *name,
+			const char *trigger, bool active_low);
+
 #else
 static inline void ath_init_leds(struct ath_softc *sc)
 {
@@ -991,6 +996,21 @@ void ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs);
 #define AIRTIME_USE_NEW_QUEUES	BIT(2)
 #define AIRTIME_ACTIVE(flags) (!!(flags & (AIRTIME_USE_TX|AIRTIME_USE_RX)))
 
+struct ath_led {
+	struct list_head list;
+	struct ath_softc *sc;
+	const struct gpio_led *gpio;
+	struct led_classdev cdev;
+};
+
+#ifdef CONFIG_GPIOLIB
+struct ath9k_gpio_chip {
+	struct ath_softc *sc;
+	char label[32];
+	struct gpio_chip gchip;
+};
+#endif
+
 struct ath_softc {
 	struct ieee80211_hw *hw;
 	struct device *dev;
@@ -1004,6 +1024,9 @@ struct ath_softc {
 	struct ath_hw *sc_ah;
 	void __iomem *mem;
 	int irq;
+#ifdef CONFIG_OF
+	struct reset_control *reset;
+#endif
 	spinlock_t sc_serial_rw;
 	spinlock_t sc_pm_lock;
 	spinlock_t sc_pcu_lock;
@@ -1046,9 +1069,12 @@ struct ath_softc {
 	spinlock_t chan_lock;
 
 #ifdef CPTCFG_MAC80211_LEDS
-	bool led_registered;
-	char led_name[32];
-	struct led_classdev led_cdev;
+	const char *led_default_trigger;
+	struct list_head leds;
+#ifdef CONFIG_GPIOLIB
+	struct ath9k_gpio_chip *gpiochip;
+	struct platform_device *btnpdev;	/* gpio-keys-polled */
+#endif
 #endif
 
 #ifdef CPTCFG_ATH9K_DEBUGFS
diff --git a/drivers/net/wireless/ath/ath9k/channel.c b/drivers/net/wireless/ath/ath9k/channel.c
index a03c7d4..2fd5309 100644
--- a/drivers/net/wireless/ath/ath9k/channel.c
+++ b/drivers/net/wireless/ath/ath9k/channel.c
@@ -15,6 +15,8 @@
  */
 
 #include "ath9k.h"
+#include <linux/ath9k_platform.h>
+#include "hsr.h"
 
 /* Set/change channels.  If the channel is really being changed, it's done
  * by reseting the chip.  To accomplish this we must first cleanup any pending
@@ -22,6 +24,7 @@
  */
 static int ath_set_channel(struct ath_softc *sc)
 {
+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ieee80211_hw *hw = sc->hw;
@@ -42,6 +45,11 @@ static int ath_set_channel(struct ath_softc *sc)
 	ath_dbg(common, CONFIG, "Set channel: %d MHz width: %d\n",
 		chan->center_freq, chandef->width);
 
+	if (pdata && pdata->ubnt_hsr) {
+		ath9k_hsr_enable(ah, chandef->width, chan->center_freq);
+		ath9k_hsr_status(ah);
+	}
+
 	/* update survey stats for the old channel before switching */
 	spin_lock_irqsave(&common->cc_lock, flags);
 	ath_update_survey_stats(sc);
diff --git a/drivers/net/wireless/ath/ath9k/common.c b/drivers/net/wireless/ath/ath9k/common.c
index 099f3d4..86d4a50 100644
--- a/drivers/net/wireless/ath/ath9k/common.c
+++ b/drivers/net/wireless/ath/ath9k/common.c
@@ -297,11 +297,13 @@ EXPORT_SYMBOL(ath9k_cmn_get_hw_crypto_keytype);
 /*
  * Update internal channel flags.
  */
-static void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
+static void ath9k_cmn_update_ichannel(struct ath_common *common,
+				      struct ath9k_channel *ichan,
 				      struct cfg80211_chan_def *chandef)
 {
 	struct ieee80211_channel *chan = chandef->chan;
 	u16 flags = 0;
+	int width;
 
 	ichan->channel = chan->center_freq;
 	ichan->chan = chan;
@@ -309,7 +311,19 @@ static void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
 	if (chan->band == NL80211_BAND_5GHZ)
 		flags |= CHANNEL_5GHZ;
 
-	switch (chandef->width) {
+	switch (common->chan_bw) {
+	case 5:
+		width = NL80211_CHAN_WIDTH_5;
+		break;
+	case 10:
+		width = NL80211_CHAN_WIDTH_10;
+		break;
+	default:
+		width = chandef->width;
+		break;
+	}
+
+	switch (width) {
 	case NL80211_CHAN_WIDTH_5:
 		flags |= CHANNEL_QUARTER;
 		break;
@@ -342,10 +356,11 @@ struct ath9k_channel *ath9k_cmn_get_channel(struct ieee80211_hw *hw,
 					    struct cfg80211_chan_def *chandef)
 {
 	struct ieee80211_channel *curchan = chandef->chan;
+	struct ath_common *common = ath9k_hw_common(ah);
 	struct ath9k_channel *channel;
 
 	channel = &ah->channels[curchan->hw_value];
-	ath9k_cmn_update_ichannel(channel, chandef);
+	ath9k_cmn_update_ichannel(common, channel, chandef);
 
 	return channel;
 }
diff --git a/drivers/net/wireless/ath/ath9k/debug.c b/drivers/net/wireless/ath/ath9k/debug.c
index 2a3fc81..f20364b 100644
--- a/drivers/net/wireless/ath/ath9k/debug.c
+++ b/drivers/net/wireless/ath/ath9k/debug.c
@@ -1374,6 +1374,198 @@ void ath9k_deinit_debug(struct ath_softc *sc)
 	ath9k_cmn_spectral_deinit_debug(&sc->spec_priv);
 }
 
+static ssize_t read_file_eeprom(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+	struct ath_common *common = ath9k_hw_common(ah);
+	int bytes = 0;
+	int pos = *ppos;
+	int size = 4096;
+	u16 val;
+	int i;
+
+	if (AR_SREV_9300_20_OR_LATER(ah))
+		size = 16384;
+
+	if (*ppos < 0)
+		return -EINVAL;
+
+	if (count > size - *ppos)
+		count = size - *ppos;
+
+	for (i = *ppos / 2; count > 0; count -= bytes, *ppos += bytes, i++) {
+		void *from = &val;
+
+		if (!common->bus_ops->eeprom_read(common, i, &val))
+			val = 0xffff;
+
+		if (*ppos % 2) {
+			from++;
+			bytes = 1;
+		} else if (count == 1) {
+			bytes = 1;
+		} else {
+			bytes = 2;
+		}
+		copy_to_user(user_buf, from, bytes);
+		user_buf += bytes;
+	}
+	return *ppos - pos;
+}
+
+static const struct file_operations fops_eeprom = {
+	.read = read_file_eeprom,
+	.open = simple_open,
+	.owner = THIS_MODULE
+};
+
+
+static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "0x%08x\n", common->chan_bw);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	unsigned long chan_bw;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &chan_bw))
+		return -EINVAL;
+
+	common->chan_bw = chan_bw;
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	return count;
+}
+
+static const struct file_operations fops_chanbw = {
+	.read = read_file_chan_bw,
+	.write = write_file_chan_bw,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+#ifdef CONFIG_MAC80211_LEDS
+
+static ssize_t write_file_gpio_led(struct file *file, const char __user *ubuf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	char buf[32], *str, *name, *c;
+	ssize_t len;
+	unsigned int gpio;
+	bool active_low = false;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, ubuf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	name = strchr(buf, ',');
+	if (!name)
+		return -EINVAL;
+
+	*(name++) = 0;
+	if (!*name)
+		return -EINVAL;
+
+	c = strchr(name, '\n');
+	if (c)
+		*c = 0;
+
+	str = buf;
+	if (*str == '!') {
+		str++;
+		active_low = true;
+	}
+
+	if (kstrtouint(str, 0, &gpio) < 0)
+		return -EINVAL;
+
+	if (gpio >= sc->sc_ah->caps.num_gpio_pins)
+		return -EINVAL;
+
+	if (ath_create_gpio_led(sc, gpio, name, NULL, active_low) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static const struct file_operations fops_gpio_led = {
+	.write = write_file_gpio_led,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+#endif
+
+
+static ssize_t read_file_diag(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "0x%08lx\n", ah->diag);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_diag(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+	unsigned long diag;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &diag))
+		return -EINVAL;
+
+	ah->diag = diag;
+	ath9k_hw_update_diag(ah);
+
+	return count;
+}
+
+static const struct file_operations fops_diag = {
+	.read = read_file_diag,
+	.write = write_file_diag,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+
 int ath9k_init_debug(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
@@ -1393,6 +1585,16 @@ int ath9k_init_debug(struct ath_hw *ah)
 	ath9k_tx99_init_debug(sc);
 	ath9k_cmn_spectral_init_debug(&sc->spec_priv, sc->debug.debugfs_phy);
 
+	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
+			    &fops_eeprom);
+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_chanbw);
+#ifdef CONFIG_MAC80211_LEDS
+	debugfs_create_file("gpio_led", S_IWUSR,
+			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
+#endif
+	debugfs_create_file("diag", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_diag);
 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
 				    read_file_dma);
 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
diff --git a/drivers/net/wireless/ath/ath9k/dynack.c b/drivers/net/wireless/ath/ath9k/dynack.c
index 6e236a4..f112fa5 100644
--- a/drivers/net/wireless/ath/ath9k/dynack.c
+++ b/drivers/net/wireless/ath/ath9k/dynack.c
@@ -178,11 +178,12 @@ void ath_dynack_sample_tx_ts(struct ath_hw *ah, struct sk_buff *skb,
 			     struct ath_tx_status *ts,
 			     struct ieee80211_sta *sta)
 {
-	u8 ridx;
 	struct ieee80211_hdr *hdr;
 	struct ath_dynack *da = &ah->dynack;
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	u32 dur = ts->duration;
+	u8 ridx;
 
 	if (!da->enabled || (info->flags & IEEE80211_TX_CTL_NO_ACK))
 		return;
@@ -217,14 +218,13 @@ void ath_dynack_sample_tx_ts(struct ath_hw *ah, struct sk_buff *skb,
 	ridx = ts->ts_rateindex;
 
 	da->st_rbf.ts[da->st_rbf.t_rb].tstamp = ts->ts_tstamp;
-	da->st_rbf.ts[da->st_rbf.t_rb].dur = ts->duration;
 	ether_addr_copy(da->st_rbf.addr[da->st_rbf.t_rb].h_dest, hdr->addr1);
 	ether_addr_copy(da->st_rbf.addr[da->st_rbf.t_rb].h_src, hdr->addr2);
 
 	if (!(info->status.rates[ridx].flags & IEEE80211_TX_RC_MCS)) {
-		u32 phy, sifs;
 		const struct ieee80211_rate *rate;
 		struct ieee80211_tx_rate *rates = info->status.rates;
+		u32 phy;
 
 		rate = &common->sbands[info->band].bitrates[rates[ridx].idx];
 		if (info->band == NL80211_BAND_2GHZ &&
@@ -233,19 +233,18 @@ void ath_dynack_sample_tx_ts(struct ath_hw *ah, struct sk_buff *skb,
 		else
 			phy = WLAN_RC_PHY_OFDM;
 
-		sifs = ath_dynack_get_sifs(ah, phy);
-		da->st_rbf.ts[da->st_rbf.t_rb].dur -= sifs;
+		dur -= ath_dynack_get_sifs(ah, phy);
 	}
-
-	ath_dbg(common, DYNACK, "{%pM} tx sample %u [dur %u][h %u-t %u]\n",
-		hdr->addr1, da->st_rbf.ts[da->st_rbf.t_rb].tstamp,
-		da->st_rbf.ts[da->st_rbf.t_rb].dur, da->st_rbf.h_rb,
-		(da->st_rbf.t_rb + 1) % ATH_DYN_BUF);
+	da->st_rbf.ts[da->st_rbf.t_rb].dur = dur;
 
 	INCR(da->st_rbf.t_rb, ATH_DYN_BUF);
 	if (da->st_rbf.t_rb == da->st_rbf.h_rb)
 		INCR(da->st_rbf.h_rb, ATH_DYN_BUF);
 
+	ath_dbg(common, DYNACK, "{%pM} tx sample %u [dur %u][h %u-t %u]\n",
+		hdr->addr1, ts->ts_tstamp, dur, da->st_rbf.h_rb,
+		da->st_rbf.t_rb);
+
 	ath_dynack_compute_to(ah);
 
 	spin_unlock_bh(&da->qlock);
@@ -272,14 +271,13 @@ void ath_dynack_sample_ack_ts(struct ath_hw *ah, struct sk_buff *skb,
 	spin_lock_bh(&da->qlock);
 	da->ack_rbf.tstamp[da->ack_rbf.t_rb] = ts;
 
-	ath_dbg(common, DYNACK, "rx sample %u [h %u-t %u]\n",
-		da->ack_rbf.tstamp[da->ack_rbf.t_rb],
-		da->ack_rbf.h_rb, (da->ack_rbf.t_rb + 1) % ATH_DYN_BUF);
-
 	INCR(da->ack_rbf.t_rb, ATH_DYN_BUF);
 	if (da->ack_rbf.t_rb == da->ack_rbf.h_rb)
 		INCR(da->ack_rbf.h_rb, ATH_DYN_BUF);
 
+	ath_dbg(common, DYNACK, "rx sample %u [h %u-t %u]\n",
+		ts, da->ack_rbf.h_rb, da->ack_rbf.t_rb);
+
 	ath_dynack_compute_to(ah);
 
 	spin_unlock_bh(&da->qlock);
diff --git a/drivers/net/wireless/ath/ath9k/gpio.c b/drivers/net/wireless/ath/ath9k/gpio.c
index a8101c9..37a796b 100644
--- a/drivers/net/wireless/ath/ath9k/gpio.c
+++ b/drivers/net/wireless/ath/ath9k/gpio.c
@@ -15,13 +15,211 @@
  */
 
 #include "ath9k.h"
+#include <linux/ath9k_platform.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/gpio_keys.h>
+
+#ifdef CPTCFG_MAC80211_LEDS
+
+#ifdef CONFIG_GPIOLIB
+
+/***************/
+/*  GPIO Chip  */
+/***************/
+
+/* gpio_chip handler : set GPIO to input */
+static int ath9k_gpio_pin_cfg_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
+						  gchip);
+
+	ath9k_hw_gpio_request_in(gc->sc->sc_ah, offset, "ath9k-gpio");
+
+	return 0;
+}
+
+/* gpio_chip handler : set GPIO to output */
+static int ath9k_gpio_pin_cfg_output(struct gpio_chip *chip, unsigned offset,
+				     int value)
+{
+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
+						  gchip);
+
+	ath9k_hw_gpio_request_out(gc->sc->sc_ah, offset, "ath9k-gpio",
+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_set_gpio(gc->sc->sc_ah, offset, value);
+
+	return 0;
+}
+
+/* gpio_chip handler : query GPIO direction (0=out, 1=in) */
+static int ath9k_gpio_pin_get_dir(struct gpio_chip *chip, unsigned offset)
+{
+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
+						  gchip);
+	struct ath_hw *ah = gc->sc->sc_ah;
+
+	return !((REG_READ(ah, AR_GPIO_OE_OUT) >> (offset * 2)) & 3);
+}
+
+/* gpio_chip handler : get GPIO pin value */
+static int ath9k_gpio_pin_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
+						  gchip);
+
+	return ath9k_hw_gpio_get(gc->sc->sc_ah, offset);
+}
+
+/* gpio_chip handler : set GPIO pin to value */
+static void ath9k_gpio_pin_set(struct gpio_chip *chip, unsigned offset,
+			       int value)
+{
+	struct ath9k_gpio_chip *gc = container_of(chip, struct ath9k_gpio_chip,
+						  gchip);
+
+	ath9k_hw_set_gpio(gc->sc->sc_ah, offset, value);
+}
+
+/* register GPIO chip */
+static void ath9k_register_gpio_chip(struct ath_softc *sc)
+{
+	struct ath9k_gpio_chip *gc;
+	struct ath_hw *ah = sc->sc_ah;
+
+	gc = kzalloc(sizeof(struct ath9k_gpio_chip), GFP_KERNEL);
+	if (!gc)
+		return;
+
+	gc->sc = sc;
+	snprintf(gc->label, sizeof(gc->label), "ath9k-%s",
+		 wiphy_name(sc->hw->wiphy));
+#ifdef CONFIG_OF
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0)
+	gc->gchip.parent = sc->dev;
+#else
+	gc->gchip.dev = sc->dev;
+#endif
+#endif
+	gc->gchip.label = gc->label;
+	gc->gchip.base = -1;	/* determine base automatically */
+	gc->gchip.ngpio = ah->caps.num_gpio_pins;
+	gc->gchip.direction_input = ath9k_gpio_pin_cfg_input;
+	gc->gchip.direction_output = ath9k_gpio_pin_cfg_output;
+	gc->gchip.get_direction = ath9k_gpio_pin_get_dir;
+	gc->gchip.get = ath9k_gpio_pin_get;
+	gc->gchip.set = ath9k_gpio_pin_set;
+
+	if (gpiochip_add(&gc->gchip)) {
+		kfree(gc);
+		return;
+	}
+
+#ifdef CONFIG_OF
+	gc->gchip.owner = NULL;
+#endif
+	sc->gpiochip = gc;
+}
+
+/* remove GPIO chip */
+static void ath9k_unregister_gpio_chip(struct ath_softc *sc)
+{
+	struct ath9k_gpio_chip *gc = sc->gpiochip;
+
+	if (!gc)
+		return;
+
+	gpiochip_remove(&gc->gchip);
+	kfree(gc);
+	sc->gpiochip = NULL;
+}
+
+/******************/
+/*  GPIO Buttons  */
+/******************/
+
+/* add GPIO buttons */
+static void ath9k_init_buttons(struct ath_softc *sc)
+{
+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
+	struct platform_device *pdev;
+	struct gpio_keys_platform_data gkpdata;
+	struct gpio_keys_button *bt;
+	int i;
+
+	if (!sc->gpiochip)
+		return;
+
+	if (!pdata || !pdata->btns || !pdata->num_btns)
+		return;
+
+	bt = devm_kmemdup(sc->dev, pdata->btns,
+			  pdata->num_btns * sizeof(struct gpio_keys_button),
+			  GFP_KERNEL);
+	if (!bt)
+		return;
+
+	for (i = 0; i < pdata->num_btns; i++) {
+		if (pdata->btns[i].gpio == sc->sc_ah->led_pin)
+				sc->sc_ah->led_pin = -1;
+
+		ath9k_hw_gpio_request_in(sc->sc_ah, pdata->btns[i].gpio,
+					 "ath9k-gpio");
+		bt[i].gpio = sc->gpiochip->gchip.base + pdata->btns[i].gpio;
+	}
+
+	memset(&gkpdata, 0, sizeof(struct gpio_keys_platform_data));
+	gkpdata.buttons = bt;
+	gkpdata.nbuttons = pdata->num_btns;
+	gkpdata.poll_interval = pdata->btn_poll_interval;
+
+	pdev = platform_device_register_data(sc->dev, "gpio-keys-polled",
+					     PLATFORM_DEVID_AUTO, &gkpdata,
+					     sizeof(gkpdata));
+	if (!IS_ERR_OR_NULL(pdev))
+		sc->btnpdev = pdev;
+	else {
+		sc->btnpdev = NULL;
+		devm_kfree(sc->dev, bt);
+	}
+}
+
+/* remove GPIO buttons */
+static void ath9k_deinit_buttons(struct ath_softc *sc)
+{
+	if (!sc->gpiochip || !sc->btnpdev)
+		return;
+
+	platform_device_unregister(sc->btnpdev);
+
+	sc->btnpdev = NULL;
+}
+
+#else /* CONFIG_GPIOLIB */
+
+static inline void ath9k_register_gpio_chip(struct ath_softc *sc)
+{
+}
+
+static inline void ath9k_unregister_gpio_chip(struct ath_softc *sc)
+{
+}
+
+static inline void ath9k_init_buttons(struct ath_softc *sc)
+{
+}
+
+static inline void ath9k_deinit_buttons(struct ath_softc *sc)
+{
+}
+
+#endif /* CONFIG_GPIOLIB */
 
 /********************************/
 /*	 LED functions		*/
 /********************************/
 
-#ifdef CPTCFG_MAC80211_LEDS
-
 static void ath_fill_led_pin(struct ath_softc *sc)
 {
 	struct ath_hw *ah = sc->sc_ah;
@@ -39,62 +237,171 @@ static void ath_fill_led_pin(struct ath_softc *sc)
 		else
 			ah->led_pin = ATH_LED_PIN_DEF;
 	}
+}
+
+static void ath_led_brightness(struct led_classdev *led_cdev,
+			       enum led_brightness brightness)
+{
+	struct ath_led *led = container_of(led_cdev, struct ath_led, cdev);
+	struct ath_softc *sc = led->sc;
+
+	ath9k_ps_wakeup(sc);
+	ath9k_hw_set_gpio(sc->sc_ah, led->gpio->gpio,
+			  (brightness != LED_OFF) ^ led->gpio->active_low);
+	ath9k_ps_restore(sc);
+}
+
+static int ath_add_led(struct ath_softc *sc, struct ath_led *led)
+{
+	const struct gpio_led *gpio = led->gpio;
+	int ret;
+
+	led->cdev.name = gpio->name;
+	led->cdev.default_trigger = gpio->default_trigger;
+	led->cdev.brightness_set = ath_led_brightness;
+
+	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &led->cdev);
+	if (ret < 0)
+		return ret;
+
+	led->sc = sc;
+	list_add(&led->list, &sc->leds);
 
 	/* Configure gpio for output */
-	ath9k_hw_gpio_request_out(ah, ah->led_pin, "ath9k-led",
+	ath9k_hw_gpio_request_out(sc->sc_ah, gpio->gpio, gpio->name,
 				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 
-	/* LED off, active low */
-	ath9k_hw_set_gpio(ah, ah->led_pin, ah->config.led_active_high ? 0 : 1);
+	/* Set default LED state */
+	if (gpio->default_state == LEDS_GPIO_DEFSTATE_ON)
+		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, !gpio->active_low);
+	else
+		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
+
+#ifdef CONFIG_GPIOLIB
+	/* If there is GPIO chip configured, reserve LED pin */
+	if (sc->gpiochip)
+		gpio_request(sc->gpiochip->gchip.base + gpio->gpio, gpio->name);
+#endif
+
+	return 0;
 }
 
-static void ath_led_brightness(struct led_classdev *led_cdev,
-			       enum led_brightness brightness)
+int ath_create_gpio_led(struct ath_softc *sc, int gpio_num, const char *name,
+			const char *trigger, bool active_low)
 {
-	struct ath_softc *sc = container_of(led_cdev, struct ath_softc, led_cdev);
-	u32 val = (brightness == LED_OFF);
+	struct ath_led *led;
+	struct gpio_led *gpio;
+	char *_name;
+	int ret;
+
+	led = kzalloc(sizeof(*led) + sizeof(*gpio) + strlen(name) + 1,
+		      GFP_KERNEL);
+	if (!led)
+		return -ENOMEM;
 
-	if (sc->sc_ah->config.led_active_high)
-		val = !val;
+	led->gpio = gpio = (struct gpio_led *) (led + 1);
+	_name = (char *) (led->gpio + 1);
 
-	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, val);
+	strcpy(_name, name);
+	gpio->name = _name;
+	gpio->gpio = gpio_num;
+	gpio->active_low = active_low;
+	gpio->default_trigger = trigger;
+
+	ret = ath_add_led(sc, led);
+	if (unlikely(ret < 0))
+		kfree(led);
+
+	return ret;
 }
 
-void ath_deinit_leds(struct ath_softc *sc)
+static int ath_create_platform_led(struct ath_softc *sc,
+				   const struct gpio_led *gpio)
 {
-	if (!sc->led_registered)
-		return;
+	struct ath_led *led;
+	int ret;
 
-	ath_led_brightness(&sc->led_cdev, LED_OFF);
-	led_classdev_unregister(&sc->led_cdev);
+	led = kzalloc(sizeof(*led), GFP_KERNEL);
+	if (!led)
+		return -ENOMEM;
 
-	ath9k_hw_gpio_free(sc->sc_ah, sc->sc_ah->led_pin);
+	led->gpio = gpio;
+	ret = ath_add_led(sc, led);
+	if (ret < 0)
+		kfree(led);
+
+	return ret;
+}
+
+void ath_deinit_leds(struct ath_softc *sc)
+{
+	struct ath_led *led;
+
+	ath9k_deinit_buttons(sc);
+	while (!list_empty(&sc->leds)) {
+		led = list_first_entry(&sc->leds, struct ath_led, list);
+#ifdef CONFIG_GPIOLIB
+		/* If there is GPIO chip configured, free LED pin */
+		if (sc->gpiochip)
+			gpio_free(sc->gpiochip->gchip.base + led->gpio->gpio);
+#endif
+		list_del(&led->list);
+		ath_led_brightness(&led->cdev, LED_OFF);
+		led_classdev_unregister(&led->cdev);
+		ath9k_hw_gpio_free(sc->sc_ah, led->gpio->gpio);
+		kfree(led);
+	}
+	ath9k_unregister_gpio_chip(sc);
 }
 
 void ath_init_leds(struct ath_softc *sc)
 {
-	int ret;
+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
+	struct device_node *np = sc->dev->of_node;
+	char led_name[32];
+	const char *trigger;
+	int i;
+
+	INIT_LIST_HEAD(&sc->leds);
 
 	if (AR_SREV_9100(sc->sc_ah))
 		return;
 
+	if (!np)
+		ath9k_register_gpio_chip(sc);
+
+	/* setup gpio controller only if requested and skip the led_pin setup */
+	if (of_property_read_bool(np, "gpio-controller")) {
+		ath9k_register_gpio_chip(sc);
+		return;
+	}
+
 	ath_fill_led_pin(sc);
+	ath9k_init_buttons(sc);
 
-	if (!ath9k_led_blink)
-		sc->led_cdev.default_trigger =
-			ieee80211_get_radio_led_name(sc->hw);
+	if (pdata && pdata->leds && pdata->num_leds)
+		for (i = 0; i < pdata->num_leds; i++) {
+			if (pdata->leds[i].gpio == sc->sc_ah->led_pin)
+				sc->sc_ah->led_pin = -1;
 
-	snprintf(sc->led_name, sizeof(sc->led_name),
-		"ath9k-%s", wiphy_name(sc->hw->wiphy));
-	sc->led_cdev.name = sc->led_name;
-	sc->led_cdev.brightness_set = ath_led_brightness;
+			ath_create_platform_led(sc, &pdata->leds[i]);
+		}
 
-	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &sc->led_cdev);
-	if (ret < 0)
+	if (sc->sc_ah->led_pin < 0)
 		return;
 
-	sc->led_registered = true;
+	snprintf(led_name, sizeof(led_name), "ath9k-%s",
+		 wiphy_name(sc->hw->wiphy));
+
+	if (ath9k_led_blink)
+		trigger = sc->led_default_trigger;
+	else
+		trigger = ieee80211_get_radio_led_name(sc->hw);
+
+	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger,
+			   !sc->sc_ah->config.led_active_high);
 }
+
 #endif
 
 /*******************/
diff --git a/drivers/net/wireless/ath/ath9k/hsr.c b/drivers/net/wireless/ath/ath9k/hsr.c
new file mode 100644
index 0000000..7d12d91
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/hsr.c
@@ -0,0 +1,247 @@
+/*
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2015 Kirill Berezin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/bitops.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <asm/unaligned.h>
+
+#include "hw.h"
+#include "ath9k.h"
+
+#define HSR_GPIO_CSN 8
+#define HSR_GPIO_CLK 6
+#define HSR_GPIO_DOUT 7
+#define HSR_GPIO_DIN 5
+
+/* delays are in useconds */
+#define HSR_DELAY_HALF_TICK 100
+#define HSR_DELAY_PRE_WRITE 75
+#define HSR_DELAY_FINAL 20000
+#define HSR_DELAY_TRAILING 200
+
+void ath9k_hsr_init(struct ath_hw *ah)
+{
+	ath9k_hw_gpio_request_in(ah, HSR_GPIO_DIN, NULL);
+	ath9k_hw_gpio_request_out(ah, HSR_GPIO_CSN, NULL,
+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_gpio_request_out(ah, HSR_GPIO_CLK, NULL,
+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_gpio_request_out(ah, HSR_GPIO_DOUT, NULL,
+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CSN, 1);
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CLK, 0);
+	ath9k_hw_set_gpio(ah, HSR_GPIO_DOUT, 0);
+
+	udelay(HSR_DELAY_TRAILING);
+}
+
+static u32 ath9k_hsr_write_byte(struct ath_hw *ah, int delay, u32 value)
+{
+	struct ath_common *common = ath9k_hw_common(ah);
+	int i;
+	u32 rval = 0;
+
+	udelay(delay);
+
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CLK, 0);
+	udelay(HSR_DELAY_HALF_TICK);
+
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CSN, 0);
+	udelay(HSR_DELAY_HALF_TICK);
+
+	for (i = 0; i < 8; ++i) {
+		rval = rval << 1;
+
+		/* pattern is left to right, that is 7-th bit runs first */
+		ath9k_hw_set_gpio(ah, HSR_GPIO_DOUT, (value >> (7 - i)) & 0x1);
+		udelay(HSR_DELAY_HALF_TICK);
+
+		ath9k_hw_set_gpio(ah, HSR_GPIO_CLK, 1);
+		udelay(HSR_DELAY_HALF_TICK);
+
+		rval |= ath9k_hw_gpio_get(ah, HSR_GPIO_DIN);
+
+		ath9k_hw_set_gpio(ah, HSR_GPIO_CLK, 0);
+		udelay(HSR_DELAY_HALF_TICK);
+	}
+
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CSN, 1);
+	udelay(HSR_DELAY_HALF_TICK);
+
+	ath_dbg(common, CONFIG, "ath9k_hsr_write_byte: write byte %d return value is %d %c\n",
+		value, rval, rval > 32 ? rval : '-');
+
+	return rval & 0xff;
+}
+
+static int ath9k_hsr_write_a_chain(struct ath_hw *ah, char *chain, int items)
+{
+	int status = 0;
+	int i = 0;
+	int err;
+
+	/* a preamble */
+	ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+	status = ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+
+	/* clear HSR's reply buffer */
+	if (status) {
+		int loop = 0;
+
+		for (loop = 0; (loop < 42) && status; ++loop)
+			status = ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE,
+						      0);
+
+		if (loop >= 42) {
+			ATH_DBG_WARN(1,
+				     "ath9k_hsr_write_a_chain: can't clear an output buffer after a 42 cycles.\n");
+			return -1;
+		}
+	}
+
+	for (i = 0; (i < items) && (chain[i] != 0); ++i)
+		ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, (u32)chain[i]);
+
+	ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+	mdelay(HSR_DELAY_FINAL / 1000);
+
+	/* reply */
+	memset(chain, 0, items);
+
+	ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+	udelay(HSR_DELAY_TRAILING);
+
+	for (i = 0; i < (items - 1); ++i) {
+		u32 ret;
+
+		ret = ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+		if (ret != 0)
+			chain[i] = (char)ret;
+		else
+			break;
+
+		udelay(HSR_DELAY_TRAILING);
+	}
+
+	if (i <= 1)
+		return 0;
+
+	err = kstrtoint(chain + 1, 10, &i);
+	if (err)
+		return err;
+
+	return i;
+}
+
+int ath9k_hsr_disable(struct ath_hw *ah)
+{
+	char cmd[10] = {'b', '4', '0', 0, 0, 0, 0, 0, 0, 0};
+	int ret;
+
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if ((ret > 0) && (*cmd == 'B'))
+		return 0;
+
+	return -1;
+}
+
+int ath9k_hsr_enable(struct ath_hw *ah, int bw, int fq)
+{
+	char cmd[10];
+	int ret;
+
+	/* Bandwidth argument is 0 sometimes. Assume default 802.11bgn
+	 * 20MHz on invalid values
+	 */
+	if ((bw != 5) && (bw != 10) && (bw != 20) && (bw != 40))
+		bw = 20;
+
+	memset(cmd, 0, sizeof(cmd));
+	*cmd = 'b';
+	snprintf(cmd + 1, 3, "%02d", bw);
+
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if ((*cmd != 'B') || (ret != bw)) {
+		ATH_DBG_WARN(1,
+			     "ath9k_hsr_enable: failed changing bandwidth -> set (%d,%d) reply (%d, %d)\n",
+			     'b', bw, *cmd, ret);
+		return -1;
+	}
+
+	memset(cmd, 0, sizeof(cmd));
+	*cmd = 'x';
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if (*cmd != 'X') {
+		ATH_DBG_WARN(1,
+			     "ath9k_hsr_enable: failed 'x' command -> reply (%d, %d)\n",
+			     *cmd, ret);
+		return -1;
+	}
+
+	memset(cmd, 0, sizeof(cmd));
+	*cmd = 'm';
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if (*cmd != 'M') {
+		ATH_DBG_WARN(1,
+			     "ath9k_hsr_enable: failed 'm' command -> reply (%d, %d)\n",
+			     *cmd, ret);
+		return  -1;
+	}
+
+	memset(cmd, 0, sizeof(cmd));
+	*cmd = 'f';
+	snprintf(cmd + 1, 6, "%05d", fq);
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if ((*cmd != 'F') && (ret != fq)) {
+		ATH_DBG_WARN(1,
+			     "ath9k_hsr_enable: failed set frequency -> reply (%d, %d)\n",
+			     *cmd, ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+int ath9k_hsr_status(struct ath_hw *ah)
+{
+	char cmd[10] = {'s', 0, 0, 0, 0, 0, 0, 0, 0, 0};
+	int ret;
+
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if (*cmd != 'S') {
+		ATH_DBG_WARN(1, "ath9k_hsr_status: returned %d,%d\n", *cmd,
+			     ret);
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/ath/ath9k/hsr.h b/drivers/net/wireless/ath/ath9k/hsr.h
new file mode 100644
index 0000000..78af444
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/hsr.h
@@ -0,0 +1,48 @@
+/*
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2015 Kirill Berezin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef HSR_H
+#define HSR_H
+
+#ifdef CPTCFG_ATH9K_UBNTHSR
+
+void ath9k_hsr_init(struct ath_hw *ah);
+int ath9k_hsr_disable(struct ath_hw *ah);
+int ath9k_hsr_enable(struct ath_hw *ah, int bw, int fq);
+int ath9k_hsr_status(struct ath_hw *ah);
+
+#else
+static inline void ath9k_hsr_init(struct ath_hw *ah) {}
+
+static inline int ath9k_hsr_enable(struct ath_hw *ah, int bw, int fq)
+{
+	return 0;
+}
+
+static inline int ath9k_hsr_disable(struct ath_hw *ah) { return 0; }
+static inline int ath9k_hsr_status(struct ath_hw *ah) { return 0; }
+
+#endif
+
+#endif /* HSR_H */
diff --git a/drivers/net/wireless/ath/ath9k/hw-ops.h b/drivers/net/wireless/ath/ath9k/hw-ops.h
index 174d716..605abe1 100644
--- a/drivers/net/wireless/ath/ath9k/hw-ops.h
+++ b/drivers/net/wireless/ath/ath9k/hw-ops.h
@@ -100,6 +100,12 @@ static inline void ath9k_hw_tx99_set_txpower(struct ath_hw *ah, u8 power)
 		ath9k_hw_ops(ah)->tx99_set_txpower(ah, power);
 }
 
+static inline void ath9k_hw_get_adc_entropy(struct ath_hw *ah,
+		u8 *buf, size_t len)
+{
+	ath9k_hw_ops(ah)->get_adc_entropy(ah, buf, len);
+}
+
 #ifdef CPTCFG_ATH9K_BTCOEX_SUPPORT
 
 static inline void ath9k_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
diff --git a/drivers/net/wireless/ath/ath9k/hw.c b/drivers/net/wireless/ath/ath9k/hw.c
index 9523697..1161f67 100644
--- a/drivers/net/wireless/ath/ath9k/hw.c
+++ b/drivers/net/wireless/ath/ath9k/hw.c
@@ -248,6 +248,19 @@ void ath9k_hw_get_channel_centers(struct ath_hw *ah,
 		centers->synth_center + (extoff * HT40_CHANNEL_CENTER_SHIFT);
 }
 
+static inline void ath9k_hw_disable_pll_lock_detect(struct ath_hw *ah)
+{
+	/* On AR9330 and AR9340 devices, some PHY registers must be
+	 * tuned to gain better stability/performance. These registers
+	 * might be changed while doing wlan reset so the registers must
+	 * be reprogrammed after each reset.
+	 */
+	REG_CLR_BIT(ah, AR_PHY_USB_CTRL1, BIT(20));
+	REG_RMW(ah, AR_PHY_USB_CTRL2,
+		(1 << 21) | (0xf << 22),
+		(1 << 21) | (0x3 << 22));
+}
+
 /******************/
 /* Chip Revisions */
 /******************/
@@ -392,13 +405,8 @@ static void ath9k_hw_init_config(struct ath_hw *ah)
 
 	ah->config.rx_intr_mitigation = true;
 
-	if (AR_SREV_9300_20_OR_LATER(ah)) {
-		ah->config.rimt_last = 500;
-		ah->config.rimt_first = 2000;
-	} else {
-		ah->config.rimt_last = 250;
-		ah->config.rimt_first = 700;
-	}
+	ah->config.rimt_last = 250;
+	ah->config.rimt_first = 500;
 
 	if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
 		ah->config.pll_pwrsave = 7;
@@ -654,6 +662,7 @@ int ath9k_hw_init(struct ath_hw *ah)
 
 	/* These are all the AR5008/AR9001/AR9002/AR9003 hardware family of chipsets */
 	switch (ah->hw_version.devid) {
+	case AR9300_DEVID_INVALID:
 	case AR5416_DEVID_PCI:
 	case AR5416_DEVID_PCIE:
 	case AR5416_AR9100_DEVID:
@@ -1298,39 +1307,56 @@ void ath9k_hw_get_delta_slope_vals(struct ath_hw *ah, u32 coef_scaled,
 	*coef_exponent = coef_exp - 16;
 }
 
-/* AR9330 WAR:
- * call external reset function to reset WMAC if:
- * - doing a cold reset
- * - we have pending frames in the TX queues.
- */
-static bool ath9k_hw_ar9330_reset_war(struct ath_hw *ah, int type)
+static bool ath9k_hw_need_external_reset(struct ath_hw *ah, int type)
 {
-	int i, npend = 0;
+	int i;
 
-	for (i = 0; i < AR_NUM_QCU; i++) {
-		npend = ath9k_hw_numtxpending(ah, i);
-		if (npend)
-			break;
+	if (type == ATH9K_RESET_COLD)
+		return true;
+
+	if (AR_SREV_9550(ah))
+		return true;
+
+	/* AR9330 WAR:
+	 * call external reset function to reset WMAC if:
+	 * - doing a cold reset
+	 * - we have pending frames in the TX queues.
+	 */
+	if (AR_SREV_9330(ah)) {
+		for (i = 0; i < AR_NUM_QCU; i++) {
+			if (ath9k_hw_numtxpending(ah, i))
+				return true;
+		}
 	}
 
-	if (ah->external_reset &&
-	    (npend || type == ATH9K_RESET_COLD)) {
-		int reset_err = 0;
+	return false;
+}
 
-		ath_dbg(ath9k_hw_common(ah), RESET,
-			"reset MAC via external reset\n");
+static bool ath9k_hw_external_reset(struct ath_hw *ah, int type)
+{
+	int err;
 
-		reset_err = ah->external_reset();
-		if (reset_err) {
-			ath_err(ath9k_hw_common(ah),
-				"External reset failed, err=%d\n",
-				reset_err);
-			return false;
-		}
+	if (!ah->external_reset || !ath9k_hw_need_external_reset(ah, type))
+		return true;
 
-		REG_WRITE(ah, AR_RTC_RESET, 1);
+	ath_dbg(ath9k_hw_common(ah), RESET,
+		"reset MAC via external reset\n");
+
+	err = ah->external_reset();
+	if (err) {
+		ath_err(ath9k_hw_common(ah),
+			"External reset failed, err=%d\n", err);
+		return false;
 	}
 
+	if (AR_SREV_9550(ah)) {
+		REG_WRITE(ah, AR_RTC_RESET, 0);
+		udelay(10);
+	}
+
+	REG_WRITE(ah, AR_RTC_RESET, 1);
+	udelay(10);
+
 	return true;
 }
 
@@ -1383,24 +1409,24 @@ static bool ath9k_hw_set_reset(struct ath_hw *ah, int type)
 			rst_flags |= AR_RTC_RC_MAC_COLD;
 	}
 
-	if (AR_SREV_9330(ah)) {
-		if (!ath9k_hw_ar9330_reset_war(ah, type))
-			return false;
-	}
-
 	if (ath9k_hw_mci_is_enabled(ah))
 		ar9003_mci_check_gpm_offset(ah);
 
 	/* DMA HALT added to resolve ar9300 and ar9580 bus error during
-	 * RTC_RC reg read
+	 * RTC_RC reg read. Also needed for AR9550 external reset
 	 */
-	if (AR_SREV_9300(ah) || AR_SREV_9580(ah)) {
+	if (AR_SREV_9300(ah) || AR_SREV_9580(ah) || AR_SREV_9550(ah)) {
 		REG_SET_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
 		ath9k_hw_wait(ah, AR_CFG, AR_CFG_HALT_ACK, AR_CFG_HALT_ACK,
 			      20 * AH_WAIT_TIMEOUT);
-		REG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
 	}
 
+	if (!AR_SREV_9100(ah))
+		ath9k_hw_external_reset(ah, type);
+
+	if (AR_SREV_9300(ah) || AR_SREV_9580(ah))
+		REG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
+
 	REG_WRITE(ah, AR_RTC_RC, rst_flags);
 
 	REGWRITE_BUFFER_FLUSH(ah);
@@ -1421,8 +1447,15 @@ static bool ath9k_hw_set_reset(struct ath_hw *ah, int type)
 	if (!AR_SREV_9100(ah))
 		REG_WRITE(ah, AR_RC, 0);
 
-	if (AR_SREV_9100(ah))
+	if (AR_SREV_9100(ah)) {
+		/* Reset the AHB-WMAC interface */
+		if (ah->external_reset)
+			ah->external_reset();
 		udelay(50);
+	}
+
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
 
 	return true;
 }
@@ -1523,6 +1556,9 @@ static bool ath9k_hw_chip_reset(struct ath_hw *ah,
 		ar9003_hw_internal_regulator_apply(ah);
 	ath9k_hw_init_pll(ah, chan);
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return true;
 }
 
@@ -1830,8 +1866,14 @@ static int ath9k_hw_do_fastcc(struct ath_hw *ah, struct ath9k_channel *chan)
 	if (AR_SREV_9271(ah))
 		ar9002_hw_load_ani_reg(ah, chan);
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return 0;
 fail:
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return -EINVAL;
 }
 
@@ -1852,6 +1894,20 @@ u32 ath9k_hw_get_tsf_offset(struct timespec64 *last, struct timespec64 *cur)
 }
 EXPORT_SYMBOL(ath9k_hw_get_tsf_offset);
 
+void ath9k_hw_update_diag(struct ath_hw *ah)
+{
+	if (test_bit(ATH_DIAG_DISABLE_RX, &ah->diag))
+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
+	else
+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
+
+	if (test_bit(ATH_DIAG_DISABLE_TX, &ah->diag))
+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
+	else
+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
+}
+EXPORT_SYMBOL(ath9k_hw_update_diag);
+
 int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 		   struct ath9k_hw_cal_data *caldata, bool fastcc)
 {
@@ -2060,6 +2116,7 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 		ar9003_hw_disable_phy_restart(ah);
 
 	ath9k_hw_apply_gpio_override(ah);
+	ath9k_hw_update_diag(ah);
 
 	if (AR_SREV_9565(ah) && common->bt_ant_diversity)
 		REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);
@@ -2070,6 +2127,9 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 		ath9k_hw_set_radar_params(ah);
 	}
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return 0;
 }
 EXPORT_SYMBOL(ath9k_hw_reset);
@@ -2941,7 +3001,8 @@ void ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,
 {
 	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
 	struct ieee80211_channel *channel;
-	int chan_pwr, new_pwr;
+	int chan_pwr, new_pwr, max_gain;
+	int ant_gain, ant_reduction = 0;
 	u16 ctl = NO_CTL;
 
 	if (!chan)
@@ -2953,9 +3014,18 @@ void ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,
 	channel = chan->chan;
 	chan_pwr = min_t(int, channel->max_power * 2, MAX_RATE_POWER);
 	new_pwr = min_t(int, chan_pwr, reg->power_limit);
+	max_gain = chan_pwr - new_pwr + channel->max_antenna_gain * 2;
+
+	ant_gain = get_antenna_gain(ah, chan);
+	if (ant_gain > max_gain)
+		ant_reduction = ant_gain - max_gain;
+
+	/* FCC allows maximum antenna gain of 3 dBi */
+	if (reg->region == NL80211_DFS_FCC)
+		ant_reduction = max_t(int, ant_reduction - 6, 0);
 
 	ah->eep_ops->set_txpower(ah, chan, ctl,
-				 get_antenna_gain(ah, chan), new_pwr, test);
+				 ant_reduction, new_pwr, test);
 }
 
 void ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test)
diff --git a/drivers/net/wireless/ath/ath9k/hw.h b/drivers/net/wireless/ath/ath9k/hw.h
index 74f2e58..3375658 100644
--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -36,6 +36,7 @@
 
 #define ATHEROS_VENDOR_ID	0x168c
 
+#define AR9300_DEVID_INVALID	0xabcd
 #define AR5416_DEVID_PCI	0x0023
 #define AR5416_DEVID_PCIE	0x0024
 #define AR9160_DEVID_PCI	0x0027
@@ -519,6 +520,12 @@ enum {
 	ATH9K_RESET_COLD,
 };
 
+enum {
+	ATH_DIAG_DISABLE_RX,
+	ATH_DIAG_DISABLE_TX,
+	ATH_DIAG_TRIGGER_ERROR,
+};
+
 struct ath9k_hw_version {
 	u32 magic;
 	u16 devid;
@@ -714,6 +721,7 @@ struct ath_spec_scan {
  * @config_pci_powersave:
  * @calibrate: periodic calibration for NF, ANI, IQ, ADC gain, ADC-DC
  *
+ * @get_adc_entropy: get entropy from the raw ADC I/Q output
  * @spectral_scan_config: set parameters for spectral scan and enable/disable it
  * @spectral_scan_trigger: trigger a spectral scan run
  * @spectral_scan_wait: wait for a spectral scan run to finish
@@ -736,6 +744,7 @@ struct ath_hw_ops {
 			struct ath_hw_antcomb_conf *antconf);
 	void (*antdiv_comb_conf_set)(struct ath_hw *ah,
 			struct ath_hw_antcomb_conf *antconf);
+	void (*get_adc_entropy)(struct ath_hw *ah, u8 *buf, size_t len);
 	void (*spectral_scan_config)(struct ath_hw *ah,
 				     struct ath_spec_scan *param);
 	void (*spectral_scan_trigger)(struct ath_hw *ah);
@@ -807,6 +816,8 @@ struct ath_hw {
 	u32 ah_flags;
 	s16 nf_override;
 
+	unsigned long diag;
+
 	bool reset_power_on;
 	bool htc_reset_init;
 
@@ -1072,6 +1083,7 @@ void ath9k_hw_check_nav(struct ath_hw *ah);
 bool ath9k_hw_check_alive(struct ath_hw *ah);
 
 bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
+void ath9k_hw_update_diag(struct ath_hw *ah);
 
 /* Generic hw timer primitives */
 struct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,
diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c
index 078fc5c..97f8fc6 100644
--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -48,7 +48,7 @@ int ath9k_modparam_nohwcrypt;
 module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
 MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
 
-int ath9k_led_blink;
+int ath9k_led_blink = 1;
 module_param_named(blink, ath9k_led_blink, int, 0444);
 MODULE_PARM_DESC(blink, "Enable LED blink on activity");
 
@@ -627,6 +627,12 @@ static int ath9k_of_init(struct ath_softc *sc)
 
 	ath_dbg(common, CONFIG, "parsing configuration from OF node\n");
 
+	if (of_property_read_bool(np, "qca,disable-2ghz"))
+		ah->disable_2ghz = true;
+
+	if (of_property_read_bool(np, "qca,disable-5ghz"))
+		ah->disable_5ghz = true;
+
 	if (of_property_read_bool(np, "qca,no-eeprom")) {
 		/* ath9k-eeprom-<bus>-<id>.bin */
 		scnprintf(eeprom_name, sizeof(eeprom_name),
@@ -821,7 +827,8 @@ static void ath9k_init_txpower_limits(struct ath_softc *sc)
 	if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
 		ath9k_init_band_txpower(sc, NL80211_BAND_5GHZ);
 
-	ah->curchan = curchan;
+	if (curchan)
+		ah->curchan = curchan;
 }
 
 static const struct ieee80211_iface_limit if_limits[] = {
@@ -833,6 +840,7 @@ static const struct ieee80211_iface_limit if_limits[] = {
 				 BIT(NL80211_IFTYPE_AP) },
 	{ .max = 1,	.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
 				 BIT(NL80211_IFTYPE_P2P_GO) },
+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
 };
 
 #ifdef CPTCFG_WIRELESS_WDS
@@ -1015,6 +1023,18 @@ static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
 	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
 }
 
+static void ath_get_initial_entropy(struct ath_softc *sc)
+{
+	struct ath_hw *ah = sc->sc_ah;
+	char buf[256];
+
+	/* reuse last channel initialized by the tx power test */
+	ath9k_hw_reset(ah, ah->curchan, NULL, false);
+
+	ath9k_hw_get_adc_entropy(ah, buf, sizeof(buf));
+	add_device_randomness(buf, sizeof(buf));
+}
+
 int ath9k_init_device(u16 devid, struct ath_softc *sc,
 		    const struct ath_bus_ops *bus_ops)
 {
@@ -1055,11 +1075,13 @@ int ath9k_init_device(u16 devid, struct ath_softc *sc,
 
 #ifdef CPTCFG_MAC80211_LEDS
 	/* must be initialized before ieee80211_register_hw */
-	sc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
+	sc->led_default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
 		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_tpt_blink,
 		ARRAY_SIZE(ath9k_tpt_blink));
 #endif
 
+	ath_get_initial_entropy(sc);
+
 	/* Register with mac80211 */
 	error = ieee80211_register_hw(hw);
 	if (error)
@@ -1143,25 +1165,25 @@ static int __init ath9k_init(void)
 {
 	int error;
 
-	error = ath_pci_init();
+	error = ath_ahb_init();
 	if (error < 0) {
-		pr_err("No PCI devices found, driver not installed\n");
 		error = -ENODEV;
 		goto err_out;
 	}
 
-	error = ath_ahb_init();
+	error = ath_pci_init();
 	if (error < 0) {
+		pr_err("No PCI devices found, driver not installed\n");
 		error = -ENODEV;
-		goto err_pci_exit;
+		goto err_ahb_exit;
 	}
 
 	dmi_check_system(ath9k_quirks);
 
 	return 0;
 
- err_pci_exit:
-	ath_pci_exit();
+ err_ahb_exit:
+	ath_ahb_exit();
  err_out:
 	return error;
 }
diff --git a/drivers/net/wireless/ath/ath9k/mac.c b/drivers/net/wireless/ath/ath9k/mac.c
index 58d02c1..c9d2bf3 100644
--- a/drivers/net/wireless/ath/ath9k/mac.c
+++ b/drivers/net/wireless/ath/ath9k/mac.c
@@ -678,13 +678,18 @@ void ath9k_hw_startpcureceive(struct ath_hw *ah, bool is_scanning)
 
 	ath9k_ani_reset(ah, is_scanning);
 
-	REG_CLR_BIT(ah, AR_DIAG_SW, (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));
+	REG_CLR_BIT(ah, AR_DIAG_SW,
+		    AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT | AR_DIAG_FORCE_RX_CLEAR);
 }
 EXPORT_SYMBOL(ath9k_hw_startpcureceive);
 
 void ath9k_hw_abortpcurecv(struct ath_hw *ah)
 {
-	REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_ABORT | AR_DIAG_RX_DIS);
+	u32 reg = AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT;
+
+	if (!IS_ENABLED(CPTCFG_ATH9K_TX99))
+		reg |= AR_DIAG_FORCE_RX_CLEAR;
+	REG_SET_BIT(ah, AR_DIAG_SW, reg);
 
 	ath9k_hw_disable_mib_counters(ah);
 }
diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c
index 3d9c5a2..9a0fb4d 100644
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -16,8 +16,10 @@
 
 #include <linux/nl80211.h>
 #include <linux/delay.h>
+#include <linux/ath9k_platform.h>
 #include "ath9k.h"
 #include "btcoex.h"
+#include "hsr.h"
 
 u8 ath9k_parse_mpdudensity(u8 mpdudensity)
 {
@@ -528,6 +530,11 @@ irqreturn_t ath_isr(int irq, void *dev)
 	if (test_bit(ATH_OP_HW_RESET, &common->op_flags))
 		return IRQ_HANDLED;
 
+	if (test_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag)) {
+		status |= ATH9K_INT_FATAL;
+		clear_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag);
+	}
+
 	/*
 	 * If there are no status bits set, then this interrupt was not
 	 * for me (should have been caught above).
@@ -644,6 +651,7 @@ void ath_reset_work(struct work_struct *work)
 static int ath9k_start(struct ieee80211_hw *hw)
 {
 	struct ath_softc *sc = hw->priv;
+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ieee80211_channel *curchan = sc->cur_chan->chandef.chan;
@@ -722,6 +730,11 @@ static int ath9k_start(struct ieee80211_hw *hw)
 					  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 	}
 
+	if (pdata && pdata->ubnt_hsr) {
+		ath9k_hsr_init(ah);
+		ath9k_hsr_disable(ah);
+	}
+
 	/*
 	 * Reset key cache to sane defaults (all entries cleared) instead of
 	 * semi-random values after suspend/resume.
@@ -1251,8 +1264,6 @@ static int ath9k_add_interface(struct ieee80211_hw *hw,
 	struct ath_vif *avp = (void *)vif->drv_priv;
 	struct ath_node *an = &avp->mcast_node;
 
-	mutex_lock(&sc->mutex);
-
 	if (IS_ENABLED(CPTCFG_ATH9K_TX99)) {
 		if (sc->cur_chan->nvifs >= 1) {
 			mutex_unlock(&sc->mutex);
@@ -1261,6 +1272,8 @@ static int ath9k_add_interface(struct ieee80211_hw *hw,
 		sc->tx99_vif = vif;
 	}
 
+	mutex_lock(&sc->mutex);
+
 	ath_dbg(common, CONFIG, "Attach a VIF of type: %d\n", vif->type);
 	sc->cur_chan->nvifs++;
 
diff --git a/drivers/net/wireless/ath/ath9k/pci.c b/drivers/net/wireless/ath/ath9k/pci.c
index caca0ac..119f1ab 100644
--- a/drivers/net/wireless/ath/ath9k/pci.c
+++ b/drivers/net/wireless/ath/ath9k/pci.c
@@ -774,6 +774,7 @@ static const struct pci_device_id ath_pci_id_table[] = {
 	  .driver_data = ATH9K_PCI_BT_ANT_DIV },
 #endif
 
+	{ PCI_VDEVICE(ATHEROS, 0xabcd) }, /* PCI-E  internal chip default ID */
 	{ 0 }
 };
 
diff --git a/drivers/net/wireless/ath/ath9k/phy.h b/drivers/net/wireless/ath/ath9k/phy.h
index 4a1b992..af667a3 100644
--- a/drivers/net/wireless/ath/ath9k/phy.h
+++ b/drivers/net/wireless/ath/ath9k/phy.h
@@ -48,6 +48,9 @@
 #define AR_PHY_PLL_CONTROL 0x16180
 #define AR_PHY_PLL_MODE 0x16184
 
+#define AR_PHY_USB_CTRL1	0x16c84
+#define AR_PHY_USB_CTRL2	0x16c88
+
 enum ath9k_ant_div_comb_lna_conf {
 	ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2,
 	ATH_ANT_DIV_COMB_LNA2,
diff --git a/drivers/net/wireless/ath/ath9k/tx99.c b/drivers/net/wireless/ath/ath9k/tx99.c
index ce50d8f..95544ce 100644
--- a/drivers/net/wireless/ath/ath9k/tx99.c
+++ b/drivers/net/wireless/ath/ath9k/tx99.c
@@ -56,11 +56,6 @@ static struct sk_buff *ath9k_build_tx99_skb(struct ath_softc *sc)
 	struct sk_buff *skb;
 	struct ath_vif *avp;
 
-	if (!sc->tx99_vif)
-		return NULL;
-
-	avp = (struct ath_vif *)sc->tx99_vif->drv_priv;
-
 	skb = alloc_skb(len, GFP_KERNEL);
 	if (!skb)
 		return NULL;
@@ -77,7 +72,10 @@ static struct sk_buff *ath9k_build_tx99_skb(struct ath_softc *sc)
 	memcpy(hdr->addr2, hw->wiphy->perm_addr, ETH_ALEN);
 	memcpy(hdr->addr3, hw->wiphy->perm_addr, ETH_ALEN);
 
-	hdr->seq_ctrl |= cpu_to_le16(avp->seq_no);
+	if (sc->tx99_vif) {
+		avp = (struct ath_vif *) sc->tx99_vif->drv_priv;
+		hdr->seq_ctrl |= cpu_to_le16(avp->seq_no);
+	}
 
 	tx_info = IEEE80211_SKB_CB(skb);
 	memset(tx_info, 0, sizeof(*tx_info));
diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index ca2392c..e263400 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -24,6 +24,7 @@
 #include "regd_common.h"
 
 static int __ath_regd_init(struct ath_regulatory *reg);
+static struct reg_dmn_pair_mapping *ath_get_regpair(int regdmn);
 
 /*
  * This is a set of common rules used by our world regulatory domains.
@@ -43,7 +44,8 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 					 NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
+#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
+				REG_RULE(5260-10, 5350+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
 #define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
@@ -61,64 +63,79 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 #define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
 				ATH9K_5GHZ_5725_5850
 
+#define REGD_RULES(...) \
+	.reg_rules = { __VA_ARGS__ }, \
+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
+
 /* Can be used for:
  * 0x60, 0x61, 0x62 */
 static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
-	.n_reg_rules = 5,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH9K_2GHZ_ALL,
 		ATH9K_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x63 and 0x65 */
 static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH9K_2GHZ_CH01_11,
 		ATH9K_2GHZ_CH12_13,
 		ATH9K_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x64 only */
 static const struct ieee80211_regdomain ath_world_regdom_64 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH9K_2GHZ_CH01_11,
 		ATH9K_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x66 and 0x69 */
 static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH9K_2GHZ_CH01_11,
 		ATH9K_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
 static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH9K_2GHZ_CH01_11,
 		ATH9K_2GHZ_CH12_13,
 		ATH9K_5GHZ_ALL,
-	}
+	)
 };
 
+static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
+{
+	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
+}
+
+static bool is_default_regd(struct ath_regulatory *reg)
+{
+	return ath_regd_get_eepromRD(reg) == CTRY_DEFAULT;
+}
+
 static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return true;
+
 	if (IS_ENABLED(CPTCFG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
 		return true;
 
+	if (is_default_regd(reg))
+		return true;
+
 	switch (reg->country_code) {
 	case CTRY_UNITED_STATES:
 	case CTRY_JAPAN1:
@@ -188,6 +205,8 @@ static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 
 static bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return true;
 	if (!IS_ENABLED(CPTCFG_ATH_REG_DYNAMIC_USER_REG_HINTS))
 		return false;
 	if (!dynamic_country_user_possible(reg))
@@ -202,11 +221,6 @@ static inline bool is_wwr_sku(u16 regd)
 		(regd == WORLD));
 }
 
-static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
-{
-	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
-}
-
 bool ath_is_world_regd(struct ath_regulatory *reg)
 {
 	return is_wwr_sku(ath_regd_get_eepromRD(reg));
@@ -345,6 +359,9 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
 		if (!wiphy->bands[band])
 			continue;
@@ -378,6 +395,9 @@ ath_reg_apply_ir_flags(struct wiphy *wiphy,
 {
 	struct ieee80211_supported_band *sband;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	sband = wiphy->bands[NL80211_BAND_2GHZ];
 	if (!sband)
 		return;
@@ -407,6 +427,9 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy,
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	if (!wiphy->bands[NL80211_BAND_5GHZ])
 		return;
 
@@ -639,6 +662,13 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
+
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return 0;
+
+	if (is_default_regd(reg))
+		return 0;
+
 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
 				   REGULATORY_CUSTOM_REG;
 
diff --git a/drivers/net/wireless/ath/regd.h b/drivers/net/wireless/ath/regd.h
index d73e45e..75ddaef 100644
--- a/drivers/net/wireless/ath/regd.h
+++ b/drivers/net/wireless/ath/regd.h
@@ -185,7 +185,9 @@ enum CountryCode {
 	CTRY_UKRAINE = 804,
 	CTRY_UNITED_KINGDOM = 826,
 	CTRY_UNITED_STATES = 840,
+	CTRY_UNITED_STATES2 = 841,
 	CTRY_UNITED_STATES_FCC49 = 842,
+	CTRY_UNITED_STATES3 = 843,
 	CTRY_URUGUAY = 858,
 	CTRY_UZBEKISTAN = 860,
 	CTRY_VENEZUELA = 862,
diff --git a/drivers/net/wireless/ath/regd_common.h b/drivers/net/wireless/ath/regd_common.h
index 4021e37..364011e 100644
--- a/drivers/net/wireless/ath/regd_common.h
+++ b/drivers/net/wireless/ath/regd_common.h
@@ -32,6 +32,7 @@ enum EnumRd {
 	FCC2_WORLD = 0x21,
 	FCC2_ETSIC = 0x22,
 	FCC6_WORLD = 0x23,
+	FCC3_FCCA_2 = 0x2A,
 	FRANCE_RES = 0x31,
 	FCC3_FCCA = 0x3A,
 	FCC3_WORLD = 0x3B,
@@ -172,6 +173,7 @@ static struct reg_dmn_pair_mapping regDomainPairs[] = {
 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC3_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
@@ -483,6 +485,9 @@ static struct country_code_to_enum_rd allCountries[] = {
 	{CTRY_UAE, NULL1_WORLD, "AE"},
 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
+	{CTRY_UNITED_STATES2, FCC3_FCCA, "US"},
+	{CTRY_UNITED_STATES3, FCC3_FCCA, "US"},
 	/* This "PS" is for US public safety actually... to support this we
 	 * would need to assign new special alpha2 to CRDA db as with the world
 	 * regdomain and use another alpha2 */
diff --git a/drivers/net/wireless/broadcom/b43/Kconfig b/drivers/net/wireless/broadcom/b43/Kconfig
index b4a8a93..267e841 100644
--- a/drivers/net/wireless/broadcom/b43/Kconfig
+++ b/drivers/net/wireless/broadcom/b43/Kconfig
@@ -61,21 +61,21 @@ endchoice
 config B43_PCI_AUTOSELECT
 	bool
 	depends on B43 && SSB_PCIHOST_POSSIBLE
-	select SSB_PCIHOST
-	select SSB_B43_PCI_BRIDGE
+	depends on SSB_PCIHOST
+	depends on SSB_B43_PCI_BRIDGE
 	default y
 
 # Auto-select SSB PCICORE driver, if possible
 config B43_PCICORE_AUTOSELECT
 	bool
 	depends on B43 && SSB_DRIVER_PCICORE_POSSIBLE
-	select SSB_DRIVER_PCICORE
+	depends on SSB_DRIVER_PCICORE
 	default y
 
 config B43_SDIO
 	bool "Broadcom 43xx SDIO device support"
 	depends on B43 && B43_SSB && SSB_SDIOHOST_POSSIBLE
-	select SSB_SDIOHOST
+	depends on SSB_SDIOHOST
 	---help---
 	  Broadcom 43xx device support for Soft-MAC SDIO devices.
 
@@ -94,13 +94,13 @@ config B43_SDIO
 config B43_BCMA_PIO
 	bool
 	depends on B43 && B43_BCMA
-	select BCMA_BLOCKIO
+	depends on BCMA_BLOCKIO
 	default y
 
 config B43_PIO
 	bool
 	depends on B43 && B43_SSB
-	select SSB_BLOCKIO
+	depends on SSB_BLOCKIO
 	default y
 
 config B43_PHY_G
diff --git a/drivers/net/wireless/broadcom/b43/main.c b/drivers/net/wireless/broadcom/b43/main.c
index 28e12aa..55e9aa6 100644
--- a/drivers/net/wireless/broadcom/b43/main.c
+++ b/drivers/net/wireless/broadcom/b43/main.c
@@ -2876,7 +2876,7 @@ static struct ssb_device *b43_ssb_gpio_dev(struct b43_wldev *dev)
 {
 	struct ssb_bus *bus = dev->dev->sdev->bus;
 
-#ifdef CPTCFG_SSB_DRIVER_PCICORE
+#ifdef CONFIG_SSB_DRIVER_PCICORE
 	return (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);
 #else
 	return bus->chipco.dev;
@@ -4893,7 +4893,7 @@ static int b43_wireless_core_init(struct b43_wldev *dev)
 	}
 	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
 		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
-#if defined(CPTCFG_B43_SSB) && defined(CPTCFG_SSB_DRIVER_PCICORE)
+#if defined(CPTCFG_B43_SSB) && defined(CONFIG_SSB_DRIVER_PCICORE)
 	if (dev->dev->bus_type == B43_BUS_SSB &&
 	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
 	    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)
diff --git a/drivers/net/wireless/broadcom/b43legacy/Kconfig b/drivers/net/wireless/broadcom/b43legacy/Kconfig
index 3463d2b..9f10813 100644
--- a/drivers/net/wireless/broadcom/b43legacy/Kconfig
+++ b/drivers/net/wireless/broadcom/b43legacy/Kconfig
@@ -2,7 +2,7 @@ config B43LEGACY
 	tristate "Broadcom 43xx-legacy wireless support (mac80211 stack)"
 	depends on m
 	depends on SSB_POSSIBLE && MAC80211 && HAS_DMA
-	select SSB
+	depends on SSB
 	depends on FW_LOADER
 	---help---
 	  b43legacy is a driver for 802.11b devices from Broadcom (BCM4301 and
@@ -24,15 +24,15 @@ config B43LEGACY
 config B43LEGACY_PCI_AUTOSELECT
 	bool
 	depends on B43LEGACY && SSB_PCIHOST_POSSIBLE
-	select SSB_PCIHOST
-	select SSB_B43_PCI_BRIDGE
+	depends on SSB_PCIHOST
+	depends on SSB_B43_PCI_BRIDGE
 	default y
 
 # Auto-select SSB PCICORE driver, if possible
 config B43LEGACY_PCICORE_AUTOSELECT
 	bool
 	depends on B43LEGACY && SSB_DRIVER_PCICORE_POSSIBLE
-	select SSB_DRIVER_PCICORE
+	depends on SSB_DRIVER_PCICORE
 	default y
 
 # LED support
diff --git a/drivers/net/wireless/broadcom/b43legacy/main.c b/drivers/net/wireless/broadcom/b43legacy/main.c
index 43b2577..a110397 100644
--- a/drivers/net/wireless/broadcom/b43legacy/main.c
+++ b/drivers/net/wireless/broadcom/b43legacy/main.c
@@ -1937,7 +1937,7 @@ static int b43legacy_gpio_init(struct b43legacy_wldev *dev)
 	if (dev->dev->id.revision >= 2)
 		mask  |= 0x0010; /* FIXME: This is redundant. */
 
-#ifdef CPTCFG_SSB_DRIVER_PCICORE
+#ifdef CONFIG_SSB_DRIVER_PCICORE
 	pcidev = bus->pcicore.dev;
 #endif
 	gpiodev = bus->chipco.dev ? : pcidev;
@@ -1956,7 +1956,7 @@ static void b43legacy_gpio_cleanup(struct b43legacy_wldev *dev)
 	struct ssb_bus *bus = dev->dev->bus;
 	struct ssb_device *gpiodev, *pcidev = NULL;
 
-#ifdef CPTCFG_SSB_DRIVER_PCICORE
+#ifdef CONFIG_SSB_DRIVER_PCICORE
 	pcidev = bus->pcicore.dev;
 #endif
 	gpiodev = bus->chipco.dev ? : pcidev;
diff --git a/drivers/net/wireless/broadcom/brcm80211/Kconfig b/drivers/net/wireless/broadcom/brcm80211/Kconfig
index 4520df9..1320268 100644
--- a/drivers/net/wireless/broadcom/brcm80211/Kconfig
+++ b/drivers/net/wireless/broadcom/brcm80211/Kconfig
@@ -7,7 +7,7 @@ config BRCMSMAC
 	depends on m
 	depends on MAC80211
 	depends on BCMA_POSSIBLE
-	select BCMA
+	depends on BCMA
 	select NEW_LEDS if BCMA_DRIVER_GPIO
 	select LEDS_CLASS if BCMA_DRIVER_GPIO
 	select BRCMUTIL
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/Makefile b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/Makefile
index 831c7e5..61b3f08 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/Makefile
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/Makefile
@@ -42,6 +42,6 @@ brcmsmac-y := \
 	brcms_trace_events.o \
 	debug.o
 
-brcmsmac-$(CPTCFG_BCMA_DRIVER_GPIO) += led.o
+brcmsmac-$(CONFIG_BCMA_DRIVER_GPIO) += led.o
 
 obj-$(CPTCFG_BRCMSMAC)	+= brcmsmac.o
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/led.h b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/led.h
index 09a5bc0..17a0b1f 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/led.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/led.h
@@ -22,7 +22,7 @@ struct brcms_led {
 	bool active_low;
 };
 
-#ifdef CPTCFG_BCMA_DRIVER_GPIO
+#ifdef CONFIG_BCMA_DRIVER_GPIO
 void brcms_led_unregister(struct brcms_info *wl);
 int brcms_led_register(struct brcms_info *wl);
 #else
diff --git a/drivers/net/wireless/intel/ipw2x00/ipw2200.c b/drivers/net/wireless/intel/ipw2x00/ipw2200.c
index a71f5f4..d89d91e 100644
--- a/drivers/net/wireless/intel/ipw2x00/ipw2200.c
+++ b/drivers/net/wireless/intel/ipw2x00/ipw2200.c
@@ -11498,6 +11498,15 @@ static const struct attribute_group ipw_attribute_group = {
 	.attrs = ipw_sysfs_entries,
 };
 
+#if LINUX_VERSION_IS_LESS(4,10,0)
+static int __change_mtu(struct net_device *ndev, int new_mtu){
+	if (new_mtu < 68 || new_mtu > LIBIPW_DATA_LEN)
+		return -EINVAL;
+	ndev->mtu = new_mtu;
+	return 0;
+}
+#endif
+
 #ifdef CPTCFG_IPW2200_PROMISCUOUS
 static int ipw_prom_open(struct net_device *dev)
 {
@@ -11546,15 +11555,6 @@ static netdev_tx_t ipw_prom_hard_start_xmit(struct sk_buff *skb,
 	return NETDEV_TX_OK;
 }
 
-#if LINUX_VERSION_IS_LESS(4,10,0)
-static int __change_mtu(struct net_device *ndev, int new_mtu){
-	if (new_mtu < 68 || new_mtu > LIBIPW_DATA_LEN)
-		return -EINVAL;
-	ndev->mtu = new_mtu;
-	return 0;
-}
-#endif
-
 static const struct net_device_ops ipw_prom_netdev_ops = {
 #if LINUX_VERSION_IS_LESS(4,10,0)
 	.ndo_change_mtu = __change_mtu,
diff --git a/include/linux/ath5k_platform.h b/include/linux/ath5k_platform.h
new file mode 100644
index 0000000..ec85224
--- /dev/null
+++ b/include/linux/ath5k_platform.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2008 Atheros Communications Inc.
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LINUX_ATH5K_PLATFORM_H
+#define _LINUX_ATH5K_PLATFORM_H
+
+#define ATH5K_PLAT_EEP_MAX_WORDS	2048
+
+struct ath5k_platform_data {
+	u16 *eeprom_data;
+	u8 *macaddr;
+};
+
+#endif /* _LINUX_ATH5K_PLATFORM_H */
diff --git a/include/linux/ath9k_platform.h b/include/linux/ath9k_platform.h
index 76860a4..f1f2ad4 100644
--- a/include/linux/ath9k_platform.h
+++ b/include/linux/ath9k_platform.h
@@ -46,6 +46,15 @@ struct ath9k_platform_data {
 	int (*external_reset)(void);
 
 	bool use_eeprom;
+
+	int num_leds;
+	const struct gpio_led *leds;
+
+	unsigned num_btns;
+	const struct gpio_keys_button *btns;
+	unsigned btn_poll_interval;
+
+	bool ubnt_hsr;
 };
 
 #endif /* _LINUX_ATH9K_PLATFORM_H */
diff --git a/include/linux/bcma/bcma.h b/include/linux/bcma/bcma.h
deleted file mode 100644
index 676e745..0000000
--- a/include/linux/bcma/bcma.h
+++ /dev/null
@@ -1,494 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_H_
-#define LINUX_BCMA_H_
-
-#include <linux/pci.h>
-#include <linux/mod_devicetable.h>
-
-#include <linux/bcma/bcma_driver_arm_c9.h>
-#include <linux/bcma/bcma_driver_chipcommon.h>
-#include <linux/bcma/bcma_driver_pci.h>
-#include <linux/bcma/bcma_driver_pcie2.h>
-#include <linux/bcma/bcma_driver_mips.h>
-#include <linux/bcma/bcma_driver_gmac_cmn.h>
-#include <linux/ssb/ssb.h> /* SPROM sharing */
-
-#include <linux/bcma/bcma_regs.h>
-
-struct bcma_device;
-struct bcma_bus;
-
-enum bcma_hosttype {
-	BCMA_HOSTTYPE_PCI,
-	BCMA_HOSTTYPE_SDIO,
-	BCMA_HOSTTYPE_SOC,
-};
-
-struct bcma_chipinfo {
-	u16 id;
-	u8 rev;
-	u8 pkg;
-};
-
-struct bcma_boardinfo {
-	u16 vendor;
-	u16 type;
-};
-
-enum bcma_clkmode {
-	BCMA_CLKMODE_FAST,
-	BCMA_CLKMODE_DYNAMIC,
-};
-
-struct bcma_host_ops {
-	u8 (*read8)(struct bcma_device *core, u16 offset);
-	u16 (*read16)(struct bcma_device *core, u16 offset);
-	u32 (*read32)(struct bcma_device *core, u16 offset);
-	void (*write8)(struct bcma_device *core, u16 offset, u8 value);
-	void (*write16)(struct bcma_device *core, u16 offset, u16 value);
-	void (*write32)(struct bcma_device *core, u16 offset, u32 value);
-#ifdef CPTCFG_BCMA_BLOCKIO
-	void (*block_read)(struct bcma_device *core, void *buffer,
-			   size_t count, u16 offset, u8 reg_width);
-	void (*block_write)(struct bcma_device *core, const void *buffer,
-			    size_t count, u16 offset, u8 reg_width);
-#endif
-	/* Agent ops */
-	u32 (*aread32)(struct bcma_device *core, u16 offset);
-	void (*awrite32)(struct bcma_device *core, u16 offset, u32 value);
-};
-
-/* Core manufacturers */
-#define BCMA_MANUF_ARM			0x43B
-#define BCMA_MANUF_MIPS			0x4A7
-#define BCMA_MANUF_BCM			0x4BF
-
-/* Core class values. */
-#define BCMA_CL_SIM			0x0
-#define BCMA_CL_EROM			0x1
-#define BCMA_CL_CORESIGHT		0x9
-#define BCMA_CL_VERIF			0xB
-#define BCMA_CL_OPTIMO			0xD
-#define BCMA_CL_GEN			0xE
-#define BCMA_CL_PRIMECELL		0xF
-
-/* Core-ID values. */
-#define BCMA_CORE_OOB_ROUTER		0x367	/* Out of band */
-#define BCMA_CORE_4706_CHIPCOMMON	0x500
-#define BCMA_CORE_NS_PCIEG2		0x501
-#define BCMA_CORE_NS_DMA		0x502
-#define BCMA_CORE_NS_SDIO3		0x503
-#define BCMA_CORE_NS_USB20		0x504
-#define BCMA_CORE_NS_USB30		0x505
-#define BCMA_CORE_NS_A9JTAG		0x506
-#define BCMA_CORE_NS_DDR23		0x507
-#define BCMA_CORE_NS_ROM		0x508
-#define BCMA_CORE_NS_NAND		0x509
-#define BCMA_CORE_NS_QSPI		0x50A
-#define BCMA_CORE_NS_CHIPCOMMON_B	0x50B
-#define BCMA_CORE_4706_SOC_RAM		0x50E
-#define BCMA_CORE_ARMCA9		0x510
-#define BCMA_CORE_4706_MAC_GBIT		0x52D
-#define BCMA_CORE_AMEMC			0x52E	/* DDR1/2 memory controller core */
-#define BCMA_CORE_ALTA			0x534	/* I2S core */
-#define BCMA_CORE_4706_MAC_GBIT_COMMON	0x5DC
-#define BCMA_CORE_DDR23_PHY		0x5DD
-#define BCMA_CORE_INVALID		0x700
-#define BCMA_CORE_CHIPCOMMON		0x800
-#define BCMA_CORE_ILINE20		0x801
-#define BCMA_CORE_SRAM			0x802
-#define BCMA_CORE_SDRAM			0x803
-#define BCMA_CORE_PCI			0x804
-#define BCMA_CORE_MIPS			0x805
-#define BCMA_CORE_ETHERNET		0x806
-#define BCMA_CORE_V90			0x807
-#define BCMA_CORE_USB11_HOSTDEV		0x808
-#define BCMA_CORE_ADSL			0x809
-#define BCMA_CORE_ILINE100		0x80A
-#define BCMA_CORE_IPSEC			0x80B
-#define BCMA_CORE_UTOPIA		0x80C
-#define BCMA_CORE_PCMCIA		0x80D
-#define BCMA_CORE_INTERNAL_MEM		0x80E
-#define BCMA_CORE_MEMC_SDRAM		0x80F
-#define BCMA_CORE_OFDM			0x810
-#define BCMA_CORE_EXTIF			0x811
-#define BCMA_CORE_80211			0x812
-#define BCMA_CORE_PHY_A			0x813
-#define BCMA_CORE_PHY_B			0x814
-#define BCMA_CORE_PHY_G			0x815
-#define BCMA_CORE_MIPS_3302		0x816
-#define BCMA_CORE_USB11_HOST		0x817
-#define BCMA_CORE_USB11_DEV		0x818
-#define BCMA_CORE_USB20_HOST		0x819
-#define BCMA_CORE_USB20_DEV		0x81A
-#define BCMA_CORE_SDIO_HOST		0x81B
-#define BCMA_CORE_ROBOSWITCH		0x81C
-#define BCMA_CORE_PARA_ATA		0x81D
-#define BCMA_CORE_SATA_XORDMA		0x81E
-#define BCMA_CORE_ETHERNET_GBIT		0x81F
-#define BCMA_CORE_PCIE			0x820
-#define BCMA_CORE_PHY_N			0x821
-#define BCMA_CORE_SRAM_CTL		0x822
-#define BCMA_CORE_MINI_MACPHY		0x823
-#define BCMA_CORE_ARM_1176		0x824
-#define BCMA_CORE_ARM_7TDMI		0x825
-#define BCMA_CORE_PHY_LP		0x826
-#define BCMA_CORE_PMU			0x827
-#define BCMA_CORE_PHY_SSN		0x828
-#define BCMA_CORE_SDIO_DEV		0x829
-#define BCMA_CORE_ARM_CM3		0x82A
-#define BCMA_CORE_PHY_HT		0x82B
-#define BCMA_CORE_MIPS_74K		0x82C
-#define BCMA_CORE_MAC_GBIT		0x82D
-#define BCMA_CORE_DDR12_MEM_CTL		0x82E
-#define BCMA_CORE_PCIE_RC		0x82F	/* PCIe Root Complex */
-#define BCMA_CORE_OCP_OCP_BRIDGE	0x830
-#define BCMA_CORE_SHARED_COMMON		0x831
-#define BCMA_CORE_OCP_AHB_BRIDGE	0x832
-#define BCMA_CORE_SPI_HOST		0x833
-#define BCMA_CORE_I2S			0x834
-#define BCMA_CORE_SDR_DDR1_MEM_CTL	0x835	/* SDR/DDR1 memory controller core */
-#define BCMA_CORE_SHIM			0x837	/* SHIM component in ubus/6362 */
-#define BCMA_CORE_PHY_AC		0x83B
-#define BCMA_CORE_PCIE2			0x83C	/* PCI Express Gen2 */
-#define BCMA_CORE_USB30_DEV		0x83D
-#define BCMA_CORE_ARM_CR4		0x83E
-#define BCMA_CORE_GCI			0x840
-#define BCMA_CORE_CMEM			0x846	/* CNDS DDR2/3 memory controller */
-#define BCMA_CORE_ARM_CA7		0x847
-#define BCMA_CORE_SYS_MEM		0x849
-#define BCMA_CORE_DEFAULT		0xFFF
-
-#define BCMA_MAX_NR_CORES		16
-#define BCMA_CORE_SIZE			0x1000
-
-/* Chip IDs of PCIe devices */
-#define BCMA_CHIP_ID_BCM4313	0x4313
-#define BCMA_CHIP_ID_BCM43142	43142
-#define BCMA_CHIP_ID_BCM43131	43131
-#define BCMA_CHIP_ID_BCM43217	43217
-#define BCMA_CHIP_ID_BCM43222	43222
-#define BCMA_CHIP_ID_BCM43224	43224
-#define  BCMA_PKG_ID_BCM43224_FAB_CSM	0x8
-#define  BCMA_PKG_ID_BCM43224_FAB_SMIC	0xa
-#define BCMA_CHIP_ID_BCM43225	43225
-#define BCMA_CHIP_ID_BCM43227	43227
-#define BCMA_CHIP_ID_BCM43228	43228
-#define BCMA_CHIP_ID_BCM43421	43421
-#define BCMA_CHIP_ID_BCM43428	43428
-#define BCMA_CHIP_ID_BCM43431	43431
-#define BCMA_CHIP_ID_BCM43460	43460
-#define BCMA_CHIP_ID_BCM4331	0x4331
-#define BCMA_CHIP_ID_BCM6362	0x6362
-#define BCMA_CHIP_ID_BCM4360	0x4360
-#define BCMA_CHIP_ID_BCM4352	0x4352
-
-/* Chip IDs of SoCs */
-#define BCMA_CHIP_ID_BCM4706	0x5300
-#define  BCMA_PKG_ID_BCM4706L	1
-#define BCMA_CHIP_ID_BCM4716	0x4716
-#define  BCMA_PKG_ID_BCM4716	8
-#define  BCMA_PKG_ID_BCM4717	9
-#define  BCMA_PKG_ID_BCM4718	10
-#define BCMA_CHIP_ID_BCM47162	47162
-#define BCMA_CHIP_ID_BCM4748	0x4748
-#define BCMA_CHIP_ID_BCM4749	0x4749
-#define BCMA_CHIP_ID_BCM5356	0x5356
-#define BCMA_CHIP_ID_BCM5357	0x5357
-#define  BCMA_PKG_ID_BCM5358	9
-#define  BCMA_PKG_ID_BCM47186	10
-#define  BCMA_PKG_ID_BCM5357	11
-#define BCMA_CHIP_ID_BCM53572	53572
-#define  BCMA_PKG_ID_BCM47188	9
-#define BCMA_CHIP_ID_BCM4707	53010
-#define  BCMA_PKG_ID_BCM4707	1
-#define  BCMA_PKG_ID_BCM4708	2
-#define  BCMA_PKG_ID_BCM4709	0
-#define BCMA_CHIP_ID_BCM47094	53030
-#define BCMA_CHIP_ID_BCM53018	53018
-#define BCMA_CHIP_ID_BCM53573	53573
-#define  BCMA_PKG_ID_BCM53573	0
-#define  BCMA_PKG_ID_BCM47189	1
-
-/* Board types (on PCI usually equals to the subsystem dev id) */
-/* BCM4313 */
-#define BCMA_BOARD_TYPE_BCM94313BU	0X050F
-#define BCMA_BOARD_TYPE_BCM94313HM	0X0510
-#define BCMA_BOARD_TYPE_BCM94313EPA	0X0511
-#define BCMA_BOARD_TYPE_BCM94313HMG	0X051C
-/* BCM4716 */
-#define BCMA_BOARD_TYPE_BCM94716NR2	0X04CD
-/* BCM43224 */
-#define BCMA_BOARD_TYPE_BCM943224X21	0X056E
-#define BCMA_BOARD_TYPE_BCM943224X21_FCC	0X00D1
-#define BCMA_BOARD_TYPE_BCM943224X21B	0X00E9
-#define BCMA_BOARD_TYPE_BCM943224M93	0X008B
-#define BCMA_BOARD_TYPE_BCM943224M93A	0X0090
-#define BCMA_BOARD_TYPE_BCM943224X16	0X0093
-#define BCMA_BOARD_TYPE_BCM94322X9	0X008D
-#define BCMA_BOARD_TYPE_BCM94322M35E	0X008E
-/* BCM43228 */
-#define BCMA_BOARD_TYPE_BCM943228BU8	0X0540
-#define BCMA_BOARD_TYPE_BCM943228BU9	0X0541
-#define BCMA_BOARD_TYPE_BCM943228BU	0X0542
-#define BCMA_BOARD_TYPE_BCM943227HM4L	0X0543
-#define BCMA_BOARD_TYPE_BCM943227HMB	0X0544
-#define BCMA_BOARD_TYPE_BCM943228HM4L	0X0545
-#define BCMA_BOARD_TYPE_BCM943228SD	0X0573
-/* BCM4331 */
-#define BCMA_BOARD_TYPE_BCM94331X19	0X00D6
-#define BCMA_BOARD_TYPE_BCM94331X28	0X00E4
-#define BCMA_BOARD_TYPE_BCM94331X28B	0X010E
-#define BCMA_BOARD_TYPE_BCM94331PCIEBT3AX	0X00E4
-#define BCMA_BOARD_TYPE_BCM94331X12_2G	0X00EC
-#define BCMA_BOARD_TYPE_BCM94331X12_5G	0X00ED
-#define BCMA_BOARD_TYPE_BCM94331X29B	0X00EF
-#define BCMA_BOARD_TYPE_BCM94331CSAX	0X00EF
-#define BCMA_BOARD_TYPE_BCM94331X19C	0X00F5
-#define BCMA_BOARD_TYPE_BCM94331X33	0X00F4
-#define BCMA_BOARD_TYPE_BCM94331BU	0X0523
-#define BCMA_BOARD_TYPE_BCM94331S9BU	0X0524
-#define BCMA_BOARD_TYPE_BCM94331MC	0X0525
-#define BCMA_BOARD_TYPE_BCM94331MCI	0X0526
-#define BCMA_BOARD_TYPE_BCM94331PCIEBT4	0X0527
-#define BCMA_BOARD_TYPE_BCM94331HM	0X0574
-#define BCMA_BOARD_TYPE_BCM94331PCIEDUAL	0X059B
-#define BCMA_BOARD_TYPE_BCM94331MCH5	0X05A9
-#define BCMA_BOARD_TYPE_BCM94331CS	0X05C6
-#define BCMA_BOARD_TYPE_BCM94331CD	0X05DA
-/* BCM53572 */
-#define BCMA_BOARD_TYPE_BCM953572BU	0X058D
-#define BCMA_BOARD_TYPE_BCM953572NR2	0X058E
-#define BCMA_BOARD_TYPE_BCM947188NR2	0X058F
-#define BCMA_BOARD_TYPE_BCM953572SDRNR2	0X0590
-/* BCM43142 */
-#define BCMA_BOARD_TYPE_BCM943142HM	0X05E0
-
-struct bcma_device {
-	struct bcma_bus *bus;
-	struct bcma_device_id id;
-
-	struct device dev;
-	struct device *dma_dev;
-
-	unsigned int irq;
-	bool dev_registered;
-
-	u8 core_index;
-	u8 core_unit;
-
-	u32 addr;
-	u32 addr_s[8];
-	u32 wrap;
-
-	void __iomem *io_addr;
-	void __iomem *io_wrap;
-
-	void *drvdata;
-	struct list_head list;
-};
-
-static inline void *bcma_get_drvdata(struct bcma_device *core)
-{
-	return core->drvdata;
-}
-static inline void bcma_set_drvdata(struct bcma_device *core, void *drvdata)
-{
-	core->drvdata = drvdata;
-}
-
-struct bcma_driver {
-	const char *name;
-	const struct bcma_device_id *id_table;
-
-	int (*probe)(struct bcma_device *dev);
-	void (*remove)(struct bcma_device *dev);
-	int (*suspend)(struct bcma_device *dev);
-	int (*resume)(struct bcma_device *dev);
-	void (*shutdown)(struct bcma_device *dev);
-
-	struct device_driver drv;
-};
-extern
-int __bcma_driver_register(struct bcma_driver *drv, struct module *owner);
-#define bcma_driver_register(drv) \
-	__bcma_driver_register(drv, THIS_MODULE)
-
-extern void bcma_driver_unregister(struct bcma_driver *drv);
-
-/* module_bcma_driver() - Helper macro for drivers that don't do
- * anything special in module init/exit.  This eliminates a lot of
- * boilerplate.  Each module may only use this macro once, and
- * calling it replaces module_init() and module_exit()
- */
-#define module_bcma_driver(__bcma_driver) \
-	module_driver(__bcma_driver, bcma_driver_register, \
-			bcma_driver_unregister)
-
-/* Set a fallback SPROM.
- * See kdoc at the function definition for complete documentation. */
-extern int bcma_arch_register_fallback_sprom(
-		int (*sprom_callback)(struct bcma_bus *bus,
-		struct ssb_sprom *out));
-
-struct bcma_bus {
-	/* The MMIO area. */
-	void __iomem *mmio;
-
-	const struct bcma_host_ops *ops;
-
-	enum bcma_hosttype hosttype;
-	bool host_is_pcie2; /* Used for BCMA_HOSTTYPE_PCI only */
-	union {
-		/* Pointer to the PCI bus (only for BCMA_HOSTTYPE_PCI) */
-		struct pci_dev *host_pci;
-		/* Pointer to the SDIO device (only for BCMA_HOSTTYPE_SDIO) */
-		struct sdio_func *host_sdio;
-		/* Pointer to platform device (only for BCMA_HOSTTYPE_SOC) */
-		struct platform_device *host_pdev;
-	};
-
-	struct bcma_chipinfo chipinfo;
-
-	struct bcma_boardinfo boardinfo;
-
-	struct bcma_device *mapped_core;
-	struct list_head cores;
-	u8 nr_cores;
-	u8 num;
-
-	struct bcma_drv_cc drv_cc;
-	struct bcma_drv_cc_b drv_cc_b;
-	struct bcma_drv_pci drv_pci[2];
-	struct bcma_drv_pcie2 drv_pcie2;
-	struct bcma_drv_mips drv_mips;
-	struct bcma_drv_gmac_cmn drv_gmac_cmn;
-
-	/* We decided to share SPROM struct with SSB as long as we do not need
-	 * any hacks for BCMA. This simplifies drivers code. */
-	struct ssb_sprom sprom;
-};
-
-static inline u32 bcma_read8(struct bcma_device *core, u16 offset)
-{
-	return core->bus->ops->read8(core, offset);
-}
-static inline u32 bcma_read16(struct bcma_device *core, u16 offset)
-{
-	return core->bus->ops->read16(core, offset);
-}
-static inline u32 bcma_read32(struct bcma_device *core, u16 offset)
-{
-	return core->bus->ops->read32(core, offset);
-}
-static inline
-void bcma_write8(struct bcma_device *core, u16 offset, u32 value)
-{
-	core->bus->ops->write8(core, offset, value);
-}
-static inline
-void bcma_write16(struct bcma_device *core, u16 offset, u32 value)
-{
-	core->bus->ops->write16(core, offset, value);
-}
-static inline
-void bcma_write32(struct bcma_device *core, u16 offset, u32 value)
-{
-	core->bus->ops->write32(core, offset, value);
-}
-#ifdef CPTCFG_BCMA_BLOCKIO
-static inline void bcma_block_read(struct bcma_device *core, void *buffer,
-				   size_t count, u16 offset, u8 reg_width)
-{
-	core->bus->ops->block_read(core, buffer, count, offset, reg_width);
-}
-static inline void bcma_block_write(struct bcma_device *core,
-				    const void *buffer, size_t count,
-				    u16 offset, u8 reg_width)
-{
-	core->bus->ops->block_write(core, buffer, count, offset, reg_width);
-}
-#endif
-static inline u32 bcma_aread32(struct bcma_device *core, u16 offset)
-{
-	return core->bus->ops->aread32(core, offset);
-}
-static inline
-void bcma_awrite32(struct bcma_device *core, u16 offset, u32 value)
-{
-	core->bus->ops->awrite32(core, offset, value);
-}
-
-static inline void bcma_mask32(struct bcma_device *cc, u16 offset, u32 mask)
-{
-	bcma_write32(cc, offset, bcma_read32(cc, offset) & mask);
-}
-static inline void bcma_set32(struct bcma_device *cc, u16 offset, u32 set)
-{
-	bcma_write32(cc, offset, bcma_read32(cc, offset) | set);
-}
-static inline void bcma_maskset32(struct bcma_device *cc,
-				  u16 offset, u32 mask, u32 set)
-{
-	bcma_write32(cc, offset, (bcma_read32(cc, offset) & mask) | set);
-}
-static inline void bcma_mask16(struct bcma_device *cc, u16 offset, u16 mask)
-{
-	bcma_write16(cc, offset, bcma_read16(cc, offset) & mask);
-}
-static inline void bcma_set16(struct bcma_device *cc, u16 offset, u16 set)
-{
-	bcma_write16(cc, offset, bcma_read16(cc, offset) | set);
-}
-static inline void bcma_maskset16(struct bcma_device *cc,
-				  u16 offset, u16 mask, u16 set)
-{
-	bcma_write16(cc, offset, (bcma_read16(cc, offset) & mask) | set);
-}
-
-extern struct bcma_device *bcma_find_core_unit(struct bcma_bus *bus, u16 coreid,
-					       u8 unit);
-static inline struct bcma_device *bcma_find_core(struct bcma_bus *bus,
-						 u16 coreid)
-{
-	return bcma_find_core_unit(bus, coreid, 0);
-}
-
-#ifdef CPTCFG_BCMA_HOST_PCI
-extern void bcma_host_pci_up(struct bcma_bus *bus);
-extern void bcma_host_pci_down(struct bcma_bus *bus);
-extern int bcma_host_pci_irq_ctl(struct bcma_bus *bus,
-				 struct bcma_device *core, bool enable);
-#else
-static inline void bcma_host_pci_up(struct bcma_bus *bus)
-{
-}
-static inline void bcma_host_pci_down(struct bcma_bus *bus)
-{
-}
-static inline int bcma_host_pci_irq_ctl(struct bcma_bus *bus,
-					struct bcma_device *core, bool enable)
-{
-	if (bus->hosttype == BCMA_HOSTTYPE_PCI)
-		return -ENOTSUPP;
-	return 0;
-}
-#endif
-
-extern bool bcma_core_is_enabled(struct bcma_device *core);
-extern void bcma_core_disable(struct bcma_device *core, u32 flags);
-extern int bcma_core_enable(struct bcma_device *core, u32 flags);
-extern void bcma_core_set_clockmode(struct bcma_device *core,
-				    enum bcma_clkmode clkmode);
-extern void bcma_core_pll_ctl(struct bcma_device *core, u32 req, u32 status,
-			      bool on);
-extern u32 bcma_chipco_pll_read(struct bcma_drv_cc *cc, u32 offset);
-#define BCMA_DMA_TRANSLATION_MASK	0xC0000000
-#define  BCMA_DMA_TRANSLATION_NONE	0x00000000
-#define  BCMA_DMA_TRANSLATION_DMA32_CMT	0x40000000 /* Client Mode Translation for 32-bit DMA */
-#define  BCMA_DMA_TRANSLATION_DMA64_CMT	0x80000000 /* Client Mode Translation for 64-bit DMA */
-extern u32 bcma_core_dma_translation(struct bcma_device *core);
-
-extern unsigned int bcma_core_irq(struct bcma_device *core, int num);
-
-#endif /* LINUX_BCMA_H_ */
diff --git a/include/linux/bcma/bcma_driver_arm_c9.h b/include/linux/bcma/bcma_driver_arm_c9.h
deleted file mode 100644
index 688cf59..0000000
--- a/include/linux/bcma/bcma_driver_arm_c9.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_ARM_C9_H_
-#define LINUX_BCMA_DRIVER_ARM_C9_H_
-
-/* DMU (Device Management Unit) */
-#define BCMA_DMU_CRU_USB2_CONTROL			0x0164
-#define  BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_NDIV_MASK	0x00000FFC
-#define  BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_NDIV_SHIFT	2
-#define  BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_PDIV_MASK	0x00007000
-#define  BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_PDIV_SHIFT	12
-#define BCMA_DMU_CRU_CLKSET_KEY				0x0180
-#define BCMA_DMU_CRU_STRAPS_CTRL			0x02A0
-#define  BCMA_DMU_CRU_STRAPS_CTRL_USB3			0x00000010
-#define  BCMA_DMU_CRU_STRAPS_CTRL_4BYTE			0x00008000
-
-#endif /* LINUX_BCMA_DRIVER_ARM_C9_H_ */
diff --git a/include/linux/bcma/bcma_driver_chipcommon.h b/include/linux/bcma/bcma_driver_chipcommon.h
deleted file mode 100644
index d758dde..0000000
--- a/include/linux/bcma/bcma_driver_chipcommon.h
+++ /dev/null
@@ -1,716 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_CC_H_
-#define LINUX_BCMA_DRIVER_CC_H_
-
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-
-/** ChipCommon core registers. **/
-#define BCMA_CC_ID			0x0000
-#define  BCMA_CC_ID_ID			0x0000FFFF
-#define  BCMA_CC_ID_ID_SHIFT		0
-#define  BCMA_CC_ID_REV			0x000F0000
-#define  BCMA_CC_ID_REV_SHIFT		16
-#define  BCMA_CC_ID_PKG			0x00F00000
-#define  BCMA_CC_ID_PKG_SHIFT		20
-#define  BCMA_CC_ID_NRCORES		0x0F000000
-#define  BCMA_CC_ID_NRCORES_SHIFT	24
-#define  BCMA_CC_ID_TYPE		0xF0000000
-#define  BCMA_CC_ID_TYPE_SHIFT		28
-#define BCMA_CC_CAP			0x0004		/* Capabilities */
-#define  BCMA_CC_CAP_NRUART		0x00000003	/* # of UARTs */
-#define  BCMA_CC_CAP_MIPSEB		0x00000004	/* MIPS in BigEndian Mode */
-#define  BCMA_CC_CAP_UARTCLK		0x00000018	/* UART clock select */
-#define   BCMA_CC_CAP_UARTCLK_INT	0x00000008	/* UARTs are driven by internal divided clock */
-#define  BCMA_CC_CAP_UARTGPIO		0x00000020	/* UARTs on GPIO 15-12 */
-#define  BCMA_CC_CAP_EXTBUS		0x000000C0	/* External buses present */
-#define  BCMA_CC_CAP_FLASHT		0x00000700	/* Flash Type */
-#define   BCMA_CC_FLASHT_NONE		0x00000000	/* No flash */
-#define   BCMA_CC_FLASHT_STSER		0x00000100	/* ST serial flash */
-#define   BCMA_CC_FLASHT_ATSER		0x00000200	/* Atmel serial flash */
-#define   BCMA_CC_FLASHT_NAND		0x00000300	/* NAND flash */
-#define	  BCMA_CC_FLASHT_PARA		0x00000700	/* Parallel flash */
-#define  BCMA_CC_CAP_PLLT		0x00038000	/* PLL Type */
-#define   BCMA_PLLTYPE_NONE		0x00000000
-#define   BCMA_PLLTYPE_1		0x00010000	/* 48Mhz base, 3 dividers */
-#define   BCMA_PLLTYPE_2		0x00020000	/* 48Mhz, 4 dividers */
-#define   BCMA_PLLTYPE_3		0x00030000	/* 25Mhz, 2 dividers */
-#define   BCMA_PLLTYPE_4		0x00008000	/* 48Mhz, 4 dividers */
-#define   BCMA_PLLTYPE_5		0x00018000	/* 25Mhz, 4 dividers */
-#define   BCMA_PLLTYPE_6		0x00028000	/* 100/200 or 120/240 only */
-#define   BCMA_PLLTYPE_7		0x00038000	/* 25Mhz, 4 dividers */
-#define  BCMA_CC_CAP_PCTL		0x00040000	/* Power Control */
-#define  BCMA_CC_CAP_OTPS		0x00380000	/* OTP size */
-#define  BCMA_CC_CAP_OTPS_SHIFT		19
-#define  BCMA_CC_CAP_OTPS_BASE		5
-#define  BCMA_CC_CAP_JTAGM		0x00400000	/* JTAG master present */
-#define  BCMA_CC_CAP_BROM		0x00800000	/* Internal boot ROM active */
-#define  BCMA_CC_CAP_64BIT		0x08000000	/* 64-bit Backplane */
-#define  BCMA_CC_CAP_PMU		0x10000000	/* PMU available (rev >= 20) */
-#define  BCMA_CC_CAP_ECI		0x20000000	/* ECI available (rev >= 20) */
-#define  BCMA_CC_CAP_SPROM		0x40000000	/* SPROM present */
-#define  BCMA_CC_CAP_NFLASH		0x80000000	/* NAND flash present (rev >= 35 or BCM4706?) */
-#define BCMA_CC_CORECTL			0x0008
-#define  BCMA_CC_CORECTL_UARTCLK0	0x00000001	/* Drive UART with internal clock */
-#define	 BCMA_CC_CORECTL_SE		0x00000002	/* sync clk out enable (corerev >= 3) */
-#define  BCMA_CC_CORECTL_UARTCLKEN	0x00000008	/* UART clock enable (rev >= 21) */
-#define BCMA_CC_BIST			0x000C
-#define BCMA_CC_OTPS			0x0010		/* OTP status */
-#define	 BCMA_CC_OTPS_PROGFAIL		0x80000000
-#define	 BCMA_CC_OTPS_PROTECT		0x00000007
-#define	 BCMA_CC_OTPS_HW_PROTECT	0x00000001
-#define	 BCMA_CC_OTPS_SW_PROTECT	0x00000002
-#define	 BCMA_CC_OTPS_CID_PROTECT	0x00000004
-#define  BCMA_CC_OTPS_GU_PROG_IND	0x00000F00	/* General Use programmed indication */
-#define  BCMA_CC_OTPS_GU_PROG_IND_SHIFT	8
-#define  BCMA_CC_OTPS_GU_PROG_HW	0x00000100	/* HW region programmed */
-#define BCMA_CC_OTPC			0x0014		/* OTP control */
-#define	 BCMA_CC_OTPC_RECWAIT		0xFF000000
-#define	 BCMA_CC_OTPC_PROGWAIT		0x00FFFF00
-#define	 BCMA_CC_OTPC_PRW_SHIFT		8
-#define	 BCMA_CC_OTPC_MAXFAIL		0x00000038
-#define	 BCMA_CC_OTPC_VSEL		0x00000006
-#define	 BCMA_CC_OTPC_SELVL		0x00000001
-#define BCMA_CC_OTPP			0x0018		/* OTP prog */
-#define	 BCMA_CC_OTPP_COL		0x000000FF
-#define	 BCMA_CC_OTPP_ROW		0x0000FF00
-#define	 BCMA_CC_OTPP_ROW_SHIFT		8
-#define	 BCMA_CC_OTPP_READERR		0x10000000
-#define	 BCMA_CC_OTPP_VALUE		0x20000000
-#define	 BCMA_CC_OTPP_READ		0x40000000
-#define	 BCMA_CC_OTPP_START		0x80000000
-#define	 BCMA_CC_OTPP_BUSY		0x80000000
-#define BCMA_CC_OTPL			0x001C		/* OTP layout */
-#define  BCMA_CC_OTPL_GURGN_OFFSET	0x00000FFF	/* offset of general use region */
-#define BCMA_CC_IRQSTAT			0x0020
-#define BCMA_CC_IRQMASK			0x0024
-#define	 BCMA_CC_IRQ_GPIO		0x00000001	/* gpio intr */
-#define	 BCMA_CC_IRQ_EXT		0x00000002	/* ro: ext intr pin (corerev >= 3) */
-#define	 BCMA_CC_IRQ_WDRESET		0x80000000	/* watchdog reset occurred */
-#define BCMA_CC_CHIPCTL			0x0028		/* Rev >= 11 only */
-#define BCMA_CC_CHIPSTAT		0x002C		/* Rev >= 11 only */
-#define  BCMA_CC_CHIPST_4313_SPROM_PRESENT	1
-#define  BCMA_CC_CHIPST_4313_OTP_PRESENT	2
-#define  BCMA_CC_CHIPST_4331_SPROM_PRESENT	2
-#define  BCMA_CC_CHIPST_4331_OTP_PRESENT	4
-#define  BCMA_CC_CHIPST_43228_ILP_DIV_EN	0x00000001
-#define  BCMA_CC_CHIPST_43228_OTP_PRESENT	0x00000002
-#define  BCMA_CC_CHIPST_43228_SERDES_REFCLK_PADSEL	0x00000004
-#define  BCMA_CC_CHIPST_43228_SDIO_MODE		0x00000008
-#define  BCMA_CC_CHIPST_43228_SDIO_OTP_PRESENT	0x00000010
-#define  BCMA_CC_CHIPST_43228_SDIO_RESET	0x00000020
-#define  BCMA_CC_CHIPST_4706_PKG_OPTION		BIT(0) /* 0: full-featured package 1: low-cost package */
-#define  BCMA_CC_CHIPST_4706_SFLASH_PRESENT	BIT(1) /* 0: parallel, 1: serial flash is present */
-#define  BCMA_CC_CHIPST_4706_SFLASH_TYPE	BIT(2) /* 0: 8b-p/ST-s flash, 1: 16b-p/Atmal-s flash */
-#define  BCMA_CC_CHIPST_4706_MIPS_BENDIAN	BIT(3) /* 0: little, 1: big endian */
-#define  BCMA_CC_CHIPST_4706_PCIE1_DISABLE	BIT(5) /* PCIE1 enable strap pin */
-#define  BCMA_CC_CHIPST_5357_NAND_BOOT		BIT(4) /* NAND boot, valid for CC rev 38 and/or BCM5357 */
-#define  BCMA_CC_CHIPST_4360_XTAL_40MZ		0x00000001
-#define BCMA_CC_JCMD			0x0030		/* Rev >= 10 only */
-#define  BCMA_CC_JCMD_START		0x80000000
-#define  BCMA_CC_JCMD_BUSY		0x80000000
-#define  BCMA_CC_JCMD_PAUSE		0x40000000
-#define  BCMA_CC_JCMD0_ACC_MASK		0x0000F000
-#define  BCMA_CC_JCMD0_ACC_IRDR		0x00000000
-#define  BCMA_CC_JCMD0_ACC_DR		0x00001000
-#define  BCMA_CC_JCMD0_ACC_IR		0x00002000
-#define  BCMA_CC_JCMD0_ACC_RESET	0x00003000
-#define  BCMA_CC_JCMD0_ACC_IRPDR	0x00004000
-#define  BCMA_CC_JCMD0_ACC_PDR		0x00005000
-#define  BCMA_CC_JCMD0_IRW_MASK		0x00000F00
-#define  BCMA_CC_JCMD_ACC_MASK		0x000F0000	/* Changes for corerev 11 */
-#define  BCMA_CC_JCMD_ACC_IRDR		0x00000000
-#define  BCMA_CC_JCMD_ACC_DR		0x00010000
-#define  BCMA_CC_JCMD_ACC_IR		0x00020000
-#define  BCMA_CC_JCMD_ACC_RESET		0x00030000
-#define  BCMA_CC_JCMD_ACC_IRPDR		0x00040000
-#define  BCMA_CC_JCMD_ACC_PDR		0x00050000
-#define  BCMA_CC_JCMD_IRW_MASK		0x00001F00
-#define  BCMA_CC_JCMD_IRW_SHIFT		8
-#define  BCMA_CC_JCMD_DRW_MASK		0x0000003F
-#define BCMA_CC_JIR			0x0034		/* Rev >= 10 only */
-#define BCMA_CC_JDR			0x0038		/* Rev >= 10 only */
-#define BCMA_CC_JCTL			0x003C		/* Rev >= 10 only */
-#define  BCMA_CC_JCTL_FORCE_CLK		4		/* Force clock */
-#define  BCMA_CC_JCTL_EXT_EN		2		/* Enable external targets */
-#define  BCMA_CC_JCTL_EN		1		/* Enable Jtag master */
-#define BCMA_CC_FLASHCTL		0x0040
-/* Start/busy bit in flashcontrol */
-#define  BCMA_CC_FLASHCTL_OPCODE	0x000000ff
-#define  BCMA_CC_FLASHCTL_ACTION	0x00000700
-#define  BCMA_CC_FLASHCTL_CS_ACTIVE	0x00001000	/* Chip Select Active, rev >= 20 */
-#define  BCMA_CC_FLASHCTL_START		0x80000000
-#define  BCMA_CC_FLASHCTL_BUSY		BCMA_CC_FLASHCTL_START
-/* Flashcontrol action + opcodes for ST flashes */
-#define  BCMA_CC_FLASHCTL_ST_WREN	0x0006		/* Write Enable */
-#define  BCMA_CC_FLASHCTL_ST_WRDIS	0x0004		/* Write Disable */
-#define  BCMA_CC_FLASHCTL_ST_RDSR	0x0105		/* Read Status Register */
-#define  BCMA_CC_FLASHCTL_ST_WRSR	0x0101		/* Write Status Register */
-#define  BCMA_CC_FLASHCTL_ST_READ	0x0303		/* Read Data Bytes */
-#define  BCMA_CC_FLASHCTL_ST_PP		0x0302		/* Page Program */
-#define  BCMA_CC_FLASHCTL_ST_SE		0x02d8		/* Sector Erase */
-#define  BCMA_CC_FLASHCTL_ST_BE		0x00c7		/* Bulk Erase */
-#define  BCMA_CC_FLASHCTL_ST_DP		0x00b9		/* Deep Power-down */
-#define  BCMA_CC_FLASHCTL_ST_RES	0x03ab		/* Read Electronic Signature */
-#define  BCMA_CC_FLASHCTL_ST_CSA	0x1000		/* Keep chip select asserted */
-#define  BCMA_CC_FLASHCTL_ST_SSE	0x0220		/* Sub-sector Erase */
-/* Flashcontrol action + opcodes for Atmel flashes */
-#define  BCMA_CC_FLASHCTL_AT_READ			0x07e8
-#define  BCMA_CC_FLASHCTL_AT_PAGE_READ			0x07d2
-#define  BCMA_CC_FLASHCTL_AT_STATUS			0x01d7
-#define  BCMA_CC_FLASHCTL_AT_BUF1_WRITE			0x0384
-#define  BCMA_CC_FLASHCTL_AT_BUF2_WRITE			0x0387
-#define  BCMA_CC_FLASHCTL_AT_BUF1_ERASE_PROGRAM		0x0283
-#define  BCMA_CC_FLASHCTL_AT_BUF2_ERASE_PROGRAM		0x0286
-#define  BCMA_CC_FLASHCTL_AT_BUF1_PROGRAM		0x0288
-#define  BCMA_CC_FLASHCTL_AT_BUF2_PROGRAM		0x0289
-#define  BCMA_CC_FLASHCTL_AT_PAGE_ERASE			0x0281
-#define  BCMA_CC_FLASHCTL_AT_BLOCK_ERASE		0x0250
-#define  BCMA_CC_FLASHCTL_AT_BUF1_WRITE_ERASE_PROGRAM	0x0382
-#define  BCMA_CC_FLASHCTL_AT_BUF2_WRITE_ERASE_PROGRAM	0x0385
-#define  BCMA_CC_FLASHCTL_AT_BUF1_LOAD			0x0253
-#define  BCMA_CC_FLASHCTL_AT_BUF2_LOAD			0x0255
-#define  BCMA_CC_FLASHCTL_AT_BUF1_COMPARE		0x0260
-#define  BCMA_CC_FLASHCTL_AT_BUF2_COMPARE		0x0261
-#define  BCMA_CC_FLASHCTL_AT_BUF1_REPROGRAM		0x0258
-#define  BCMA_CC_FLASHCTL_AT_BUF2_REPROGRAM		0x0259
-#define BCMA_CC_FLASHADDR		0x0044
-#define BCMA_CC_FLASHDATA		0x0048
-/* Status register bits for ST flashes */
-#define  BCMA_CC_FLASHDATA_ST_WIP	0x01		/* Write In Progress */
-#define  BCMA_CC_FLASHDATA_ST_WEL	0x02		/* Write Enable Latch */
-#define  BCMA_CC_FLASHDATA_ST_BP_MASK	0x1c		/* Block Protect */
-#define  BCMA_CC_FLASHDATA_ST_BP_SHIFT	2
-#define  BCMA_CC_FLASHDATA_ST_SRWD	0x80		/* Status Register Write Disable */
-/* Status register bits for Atmel flashes */
-#define  BCMA_CC_FLASHDATA_AT_READY	0x80
-#define  BCMA_CC_FLASHDATA_AT_MISMATCH	0x40
-#define  BCMA_CC_FLASHDATA_AT_ID_MASK	0x38
-#define  BCMA_CC_FLASHDATA_AT_ID_SHIFT	3
-#define BCMA_CC_BCAST_ADDR		0x0050
-#define BCMA_CC_BCAST_DATA		0x0054
-#define BCMA_CC_GPIOPULLUP		0x0058		/* Rev >= 20 only */
-#define BCMA_CC_GPIOPULLDOWN		0x005C		/* Rev >= 20 only */
-#define BCMA_CC_GPIOIN			0x0060
-#define BCMA_CC_GPIOOUT			0x0064
-#define BCMA_CC_GPIOOUTEN		0x0068
-#define BCMA_CC_GPIOCTL			0x006C
-#define BCMA_CC_GPIOPOL			0x0070
-#define BCMA_CC_GPIOIRQ			0x0074
-#define BCMA_CC_WATCHDOG		0x0080
-#define BCMA_CC_GPIOTIMER		0x0088		/* LED powersave (corerev >= 16) */
-#define  BCMA_CC_GPIOTIMER_OFFTIME	0x0000FFFF
-#define  BCMA_CC_GPIOTIMER_OFFTIME_SHIFT	0
-#define  BCMA_CC_GPIOTIMER_ONTIME	0xFFFF0000
-#define  BCMA_CC_GPIOTIMER_ONTIME_SHIFT	16
-#define BCMA_CC_GPIOTOUTM		0x008C		/* LED powersave (corerev >= 16) */
-#define BCMA_CC_CLOCK_N			0x0090
-#define BCMA_CC_CLOCK_SB		0x0094
-#define BCMA_CC_CLOCK_PCI		0x0098
-#define BCMA_CC_CLOCK_M2		0x009C
-#define BCMA_CC_CLOCK_MIPS		0x00A0
-#define BCMA_CC_CLKDIV			0x00A4		/* Rev >= 3 only */
-#define	 BCMA_CC_CLKDIV_SFLASH		0x0F000000
-#define	 BCMA_CC_CLKDIV_SFLASH_SHIFT	24
-#define	 BCMA_CC_CLKDIV_OTP		0x000F0000
-#define	 BCMA_CC_CLKDIV_OTP_SHIFT	16
-#define	 BCMA_CC_CLKDIV_JTAG		0x00000F00
-#define	 BCMA_CC_CLKDIV_JTAG_SHIFT	8
-#define	 BCMA_CC_CLKDIV_UART		0x000000FF
-#define BCMA_CC_CAP_EXT			0x00AC		/* Capabilities */
-#define  BCMA_CC_CAP_EXT_SECI_PRESENT	0x00000001
-#define  BCMA_CC_CAP_EXT_GSIO_PRESENT	0x00000002
-#define  BCMA_CC_CAP_EXT_GCI_PRESENT	0x00000004
-#define  BCMA_CC_CAP_EXT_SECI_PUART_PRESENT		0x00000008    /* UART present */
-#define  BCMA_CC_CAP_EXT_AOB_PRESENT	0x00000040
-#define BCMA_CC_PLLONDELAY		0x00B0		/* Rev >= 4 only */
-#define BCMA_CC_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
-#define BCMA_CC_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
-#define  BCMA_CC_SLOWCLKCTL_SRC		0x00000007	/* slow clock source mask */
-#define	  BCMA_CC_SLOWCLKCTL_SRC_LPO	0x00000000	/* source of slow clock is LPO */
-#define   BCMA_CC_SLOWCLKCTL_SRC_XTAL	0x00000001	/* source of slow clock is crystal */
-#define	  BCMA_CC_SLOECLKCTL_SRC_PCI	0x00000002	/* source of slow clock is PCI */
-#define  BCMA_CC_SLOWCLKCTL_LPOFREQ	0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
-#define  BCMA_CC_SLOWCLKCTL_LPOPD	0x00000400	/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
-#define  BCMA_CC_SLOWCLKCTL_FSLOW	0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
-#define  BCMA_CC_SLOWCLKCTL_IPLL	0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
-#define  BCMA_CC_SLOWCLKCTL_ENXTAL	0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
-#define  BCMA_CC_SLOWCLKCTL_XTALPU	0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
-#define  BCMA_CC_SLOWCLKCTL_CLKDIV	0xFFFF0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
-#define  BCMA_CC_SLOWCLKCTL_CLKDIV_SHIFT	16
-#define BCMA_CC_SYSCLKCTL		0x00C0		/* Rev >= 3 only */
-#define	 BCMA_CC_SYSCLKCTL_IDLPEN	0x00000001	/* ILPen: Enable Idle Low Power */
-#define	 BCMA_CC_SYSCLKCTL_ALPEN	0x00000002	/* ALPen: Enable Active Low Power */
-#define	 BCMA_CC_SYSCLKCTL_PLLEN	0x00000004	/* ForcePLLOn */
-#define	 BCMA_CC_SYSCLKCTL_FORCEALP	0x00000008	/* Force ALP (or HT if ALPen is not set */
-#define	 BCMA_CC_SYSCLKCTL_FORCEHT	0x00000010	/* Force HT */
-#define  BCMA_CC_SYSCLKCTL_CLKDIV	0xFFFF0000	/* ClkDiv  (ILP = 1/(4+divisor)) */
-#define  BCMA_CC_SYSCLKCTL_CLKDIV_SHIFT	16
-#define BCMA_CC_CLKSTSTR		0x00C4		/* Rev >= 3 only */
-#define BCMA_CC_EROM			0x00FC
-#define BCMA_CC_PCMCIA_CFG		0x0100
-#define BCMA_CC_PCMCIA_MEMWAIT		0x0104
-#define BCMA_CC_PCMCIA_ATTRWAIT		0x0108
-#define BCMA_CC_PCMCIA_IOWAIT		0x010C
-#define BCMA_CC_IDE_CFG			0x0110
-#define BCMA_CC_IDE_MEMWAIT		0x0114
-#define BCMA_CC_IDE_ATTRWAIT		0x0118
-#define BCMA_CC_IDE_IOWAIT		0x011C
-#define BCMA_CC_PROG_CFG		0x0120
-#define BCMA_CC_PROG_WAITCNT		0x0124
-#define BCMA_CC_FLASH_CFG		0x0128
-#define  BCMA_CC_FLASH_CFG_DS		0x0010	/* Data size, 0=8bit, 1=16bit */
-#define BCMA_CC_FLASH_WAITCNT		0x012C
-#define BCMA_CC_SROM_CONTROL		0x0190
-#define  BCMA_CC_SROM_CONTROL_START	0x80000000
-#define  BCMA_CC_SROM_CONTROL_BUSY	0x80000000
-#define  BCMA_CC_SROM_CONTROL_OPCODE	0x60000000
-#define  BCMA_CC_SROM_CONTROL_OP_READ	0x00000000
-#define  BCMA_CC_SROM_CONTROL_OP_WRITE	0x20000000
-#define  BCMA_CC_SROM_CONTROL_OP_WRDIS	0x40000000
-#define  BCMA_CC_SROM_CONTROL_OP_WREN	0x60000000
-#define  BCMA_CC_SROM_CONTROL_OTPSEL	0x00000010
-#define  BCMA_CC_SROM_CONTROL_LOCK	0x00000008
-#define  BCMA_CC_SROM_CONTROL_SIZE_MASK	0x00000006
-#define  BCMA_CC_SROM_CONTROL_SIZE_1K	0x00000000
-#define  BCMA_CC_SROM_CONTROL_SIZE_4K	0x00000002
-#define  BCMA_CC_SROM_CONTROL_SIZE_16K	0x00000004
-#define  BCMA_CC_SROM_CONTROL_SIZE_SHIFT	1
-#define  BCMA_CC_SROM_CONTROL_PRESENT	0x00000001
-/* Block 0x140 - 0x190 registers are chipset specific */
-#define BCMA_CC_4706_FLASHSCFG		0x18C		/* Flash struct configuration */
-#define  BCMA_CC_4706_FLASHSCFG_MASK	0x000000ff
-#define  BCMA_CC_4706_FLASHSCFG_SF1	0x00000001	/* 2nd serial flash present */
-#define  BCMA_CC_4706_FLASHSCFG_PF1	0x00000002	/* 2nd parallel flash present */
-#define  BCMA_CC_4706_FLASHSCFG_SF1_TYPE	0x00000004	/* 2nd serial flash type : 0 : ST, 1 : Atmel */
-#define  BCMA_CC_4706_FLASHSCFG_NF1	0x00000008	/* 2nd NAND flash present */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_MASK	0x000000f0
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_4MB	0x00000010	/* 4MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_8MB	0x00000020	/* 8MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_16MB	0x00000030	/* 16MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_32MB	0x00000040	/* 32MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_64MB	0x00000050	/* 64MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_128MB	0x00000060	/* 128MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_256MB	0x00000070	/* 256MB */
-/* NAND flash registers for BCM4706 (corerev = 31) */
-#define BCMA_CC_NFLASH_CTL		0x01A0
-#define  BCMA_CC_NFLASH_CTL_ERR		0x08000000
-#define BCMA_CC_NFLASH_CONF		0x01A4
-#define BCMA_CC_NFLASH_COL_ADDR		0x01A8
-#define BCMA_CC_NFLASH_ROW_ADDR		0x01AC
-#define BCMA_CC_NFLASH_DATA		0x01B0
-#define BCMA_CC_NFLASH_WAITCNT0		0x01B4
-/* 0x1E0 is defined as shared BCMA_CLKCTLST */
-#define BCMA_CC_HW_WORKAROUND		0x01E4 /* Hardware workaround (rev >= 20) */
-#define BCMA_CC_UART0_DATA		0x0300
-#define BCMA_CC_UART0_IMR		0x0304
-#define BCMA_CC_UART0_FCR		0x0308
-#define BCMA_CC_UART0_LCR		0x030C
-#define BCMA_CC_UART0_MCR		0x0310
-#define BCMA_CC_UART0_LSR		0x0314
-#define BCMA_CC_UART0_MSR		0x0318
-#define BCMA_CC_UART0_SCRATCH		0x031C
-#define BCMA_CC_UART1_DATA		0x0400
-#define BCMA_CC_UART1_IMR		0x0404
-#define BCMA_CC_UART1_FCR		0x0408
-#define BCMA_CC_UART1_LCR		0x040C
-#define BCMA_CC_UART1_MCR		0x0410
-#define BCMA_CC_UART1_LSR		0x0414
-#define BCMA_CC_UART1_MSR		0x0418
-#define BCMA_CC_UART1_SCRATCH		0x041C
-/* PMU registers (rev >= 20) */
-#define BCMA_CC_PMU_CTL			0x0600 /* PMU control */
-#define  BCMA_CC_PMU_CTL_ILP_DIV	0xFFFF0000 /* ILP div mask */
-#define  BCMA_CC_PMU_CTL_ILP_DIV_SHIFT	16
-#define  BCMA_CC_PMU_CTL_RES		0x00006000 /* reset control mask */
-#define  BCMA_CC_PMU_CTL_RES_SHIFT	13
-#define  BCMA_CC_PMU_CTL_RES_RELOAD	0x2	/* reload POR values */
-#define  BCMA_CC_PMU_CTL_PLL_UPD	0x00000400
-#define  BCMA_CC_PMU_CTL_NOILPONW	0x00000200 /* No ILP on wait */
-#define  BCMA_CC_PMU_CTL_HTREQEN	0x00000100 /* HT req enable */
-#define  BCMA_CC_PMU_CTL_ALPREQEN	0x00000080 /* ALP req enable */
-#define  BCMA_CC_PMU_CTL_XTALFREQ	0x0000007C /* Crystal freq */
-#define  BCMA_CC_PMU_CTL_XTALFREQ_SHIFT	2
-#define  BCMA_CC_PMU_CTL_ILPDIVEN	0x00000002 /* ILP div enable */
-#define  BCMA_CC_PMU_CTL_LPOSEL		0x00000001 /* LPO sel */
-#define BCMA_CC_PMU_CAP			0x0604 /* PMU capabilities */
-#define  BCMA_CC_PMU_CAP_REVISION	0x000000FF /* Revision mask */
-#define BCMA_CC_PMU_STAT		0x0608 /* PMU status */
-#define  BCMA_CC_PMU_STAT_EXT_LPO_AVAIL	0x00000100
-#define  BCMA_CC_PMU_STAT_WDRESET	0x00000080
-#define  BCMA_CC_PMU_STAT_INTPEND	0x00000040 /* Interrupt pending */
-#define  BCMA_CC_PMU_STAT_SBCLKST	0x00000030 /* Backplane clock status? */
-#define  BCMA_CC_PMU_STAT_HAVEALP	0x00000008 /* ALP available */
-#define  BCMA_CC_PMU_STAT_HAVEHT	0x00000004 /* HT available */
-#define  BCMA_CC_PMU_STAT_RESINIT	0x00000003 /* Res init */
-#define BCMA_CC_PMU_RES_STAT		0x060C /* PMU res status */
-#define BCMA_CC_PMU_RES_PEND		0x0610 /* PMU res pending */
-#define BCMA_CC_PMU_TIMER		0x0614 /* PMU timer */
-#define BCMA_CC_PMU_MINRES_MSK		0x0618 /* PMU min res mask */
-#define BCMA_CC_PMU_MAXRES_MSK		0x061C /* PMU max res mask */
-#define BCMA_CC_PMU_RES_TABSEL		0x0620 /* PMU res table sel */
-#define BCMA_CC_PMU_RES_DEPMSK		0x0624 /* PMU res dep mask */
-#define BCMA_CC_PMU_RES_UPDNTM		0x0628 /* PMU res updown timer */
-#define BCMA_CC_PMU_RES_TIMER		0x062C /* PMU res timer */
-#define BCMA_CC_PMU_CLKSTRETCH		0x0630 /* PMU clockstretch */
-#define BCMA_CC_PMU_WATCHDOG		0x0634 /* PMU watchdog */
-#define BCMA_CC_PMU_RES_REQTS		0x0640 /* PMU res req timer sel */
-#define BCMA_CC_PMU_RES_REQT		0x0644 /* PMU res req timer */
-#define BCMA_CC_PMU_RES_REQM		0x0648 /* PMU res req mask */
-#define BCMA_CC_PMU_CHIPCTL_ADDR	0x0650
-#define BCMA_CC_PMU_CHIPCTL_DATA	0x0654
-#define BCMA_CC_PMU_REGCTL_ADDR		0x0658
-#define BCMA_CC_PMU_REGCTL_DATA		0x065C
-#define BCMA_CC_PMU_PLLCTL_ADDR		0x0660
-#define BCMA_CC_PMU_PLLCTL_DATA		0x0664
-#define BCMA_CC_PMU_STRAPOPT		0x0668 /* (corerev >= 28) */
-#define BCMA_CC_PMU_XTAL_FREQ		0x066C /* (pmurev >= 10) */
-#define  BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK	0x00001FFF
-#define  BCMA_CC_PMU_XTAL_FREQ_MEASURE_MASK	0x80000000
-#define  BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT	31
-#define BCMA_CC_SPROM			0x0800 /* SPROM beginning */
-/* NAND flash MLC controller registers (corerev >= 38) */
-#define BCMA_CC_NAND_REVISION		0x0C00
-#define BCMA_CC_NAND_CMD_START		0x0C04
-#define BCMA_CC_NAND_CMD_ADDR_X		0x0C08
-#define BCMA_CC_NAND_CMD_ADDR		0x0C0C
-#define BCMA_CC_NAND_CMD_END_ADDR	0x0C10
-#define BCMA_CC_NAND_CS_NAND_SELECT	0x0C14
-#define BCMA_CC_NAND_CS_NAND_XOR	0x0C18
-#define BCMA_CC_NAND_SPARE_RD0		0x0C20
-#define BCMA_CC_NAND_SPARE_RD4		0x0C24
-#define BCMA_CC_NAND_SPARE_RD8		0x0C28
-#define BCMA_CC_NAND_SPARE_RD12		0x0C2C
-#define BCMA_CC_NAND_SPARE_WR0		0x0C30
-#define BCMA_CC_NAND_SPARE_WR4		0x0C34
-#define BCMA_CC_NAND_SPARE_WR8		0x0C38
-#define BCMA_CC_NAND_SPARE_WR12		0x0C3C
-#define BCMA_CC_NAND_ACC_CONTROL	0x0C40
-#define BCMA_CC_NAND_CONFIG		0x0C48
-#define BCMA_CC_NAND_TIMING_1		0x0C50
-#define BCMA_CC_NAND_TIMING_2		0x0C54
-#define BCMA_CC_NAND_SEMAPHORE		0x0C58
-#define BCMA_CC_NAND_DEVID		0x0C60
-#define BCMA_CC_NAND_DEVID_X		0x0C64
-#define BCMA_CC_NAND_BLOCK_LOCK_STATUS	0x0C68
-#define BCMA_CC_NAND_INTFC_STATUS	0x0C6C
-#define BCMA_CC_NAND_ECC_CORR_ADDR_X	0x0C70
-#define BCMA_CC_NAND_ECC_CORR_ADDR	0x0C74
-#define BCMA_CC_NAND_ECC_UNC_ADDR_X	0x0C78
-#define BCMA_CC_NAND_ECC_UNC_ADDR	0x0C7C
-#define BCMA_CC_NAND_READ_ERROR_COUNT	0x0C80
-#define BCMA_CC_NAND_CORR_STAT_THRESHOLD	0x0C84
-#define BCMA_CC_NAND_READ_ADDR_X	0x0C90
-#define BCMA_CC_NAND_READ_ADDR		0x0C94
-#define BCMA_CC_NAND_PAGE_PROGRAM_ADDR_X	0x0C98
-#define BCMA_CC_NAND_PAGE_PROGRAM_ADDR	0x0C9C
-#define BCMA_CC_NAND_COPY_BACK_ADDR_X	0x0CA0
-#define BCMA_CC_NAND_COPY_BACK_ADDR	0x0CA4
-#define BCMA_CC_NAND_BLOCK_ERASE_ADDR_X	0x0CA8
-#define BCMA_CC_NAND_BLOCK_ERASE_ADDR	0x0CAC
-#define BCMA_CC_NAND_INV_READ_ADDR_X	0x0CB0
-#define BCMA_CC_NAND_INV_READ_ADDR	0x0CB4
-#define BCMA_CC_NAND_BLK_WR_PROTECT	0x0CC0
-#define BCMA_CC_NAND_ACC_CONTROL_CS1	0x0CD0
-#define BCMA_CC_NAND_CONFIG_CS1		0x0CD4
-#define BCMA_CC_NAND_TIMING_1_CS1	0x0CD8
-#define BCMA_CC_NAND_TIMING_2_CS1	0x0CDC
-#define BCMA_CC_NAND_SPARE_RD16		0x0D30
-#define BCMA_CC_NAND_SPARE_RD20		0x0D34
-#define BCMA_CC_NAND_SPARE_RD24		0x0D38
-#define BCMA_CC_NAND_SPARE_RD28		0x0D3C
-#define BCMA_CC_NAND_CACHE_ADDR		0x0D40
-#define BCMA_CC_NAND_CACHE_DATA		0x0D44
-#define BCMA_CC_NAND_CTRL_CONFIG	0x0D48
-#define BCMA_CC_NAND_CTRL_STATUS	0x0D4C
-
-/* Divider allocation in 4716/47162/5356 */
-#define BCMA_CC_PMU5_MAINPLL_CPU	1
-#define BCMA_CC_PMU5_MAINPLL_MEM	2
-#define BCMA_CC_PMU5_MAINPLL_SSB	3
-
-/* PLL usage in 4716/47162 */
-#define BCMA_CC_PMU4716_MAINPLL_PLL0	12
-
-/* PLL usage in 5356/5357 */
-#define BCMA_CC_PMU5356_MAINPLL_PLL0	0
-#define BCMA_CC_PMU5357_MAINPLL_PLL0	0
-
-/* 4706 PMU */
-#define BCMA_CC_PMU4706_MAINPLL_PLL0	0
-#define BCMA_CC_PMU6_4706_PROCPLL_OFF	4	/* The CPU PLL */
-#define  BCMA_CC_PMU6_4706_PROC_P2DIV_MASK	0x000f0000
-#define  BCMA_CC_PMU6_4706_PROC_P2DIV_SHIFT	16
-#define  BCMA_CC_PMU6_4706_PROC_P1DIV_MASK	0x0000f000
-#define  BCMA_CC_PMU6_4706_PROC_P1DIV_SHIFT	12
-#define  BCMA_CC_PMU6_4706_PROC_NDIV_INT_MASK	0x00000ff8
-#define  BCMA_CC_PMU6_4706_PROC_NDIV_INT_SHIFT	3
-#define  BCMA_CC_PMU6_4706_PROC_NDIV_MODE_MASK	0x00000007
-#define  BCMA_CC_PMU6_4706_PROC_NDIV_MODE_SHIFT	0
-
-/* PMU rev 15 */
-#define BCMA_CC_PMU15_PLL_PLLCTL0	0
-#define  BCMA_CC_PMU15_PLL_PC0_CLKSEL_MASK	0x00000003
-#define  BCMA_CC_PMU15_PLL_PC0_CLKSEL_SHIFT	0
-#define  BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK	0x003FFFFC
-#define  BCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT	2
-#define  BCMA_CC_PMU15_PLL_PC0_PRESCALE_MASK	0x00C00000
-#define  BCMA_CC_PMU15_PLL_PC0_PRESCALE_SHIFT	22
-#define  BCMA_CC_PMU15_PLL_PC0_KPCTRL_MASK	0x07000000
-#define  BCMA_CC_PMU15_PLL_PC0_KPCTRL_SHIFT	24
-#define  BCMA_CC_PMU15_PLL_PC0_FCNTCTRL_MASK	0x38000000
-#define  BCMA_CC_PMU15_PLL_PC0_FCNTCTRL_SHIFT	27
-#define  BCMA_CC_PMU15_PLL_PC0_FDCMODE_MASK	0x40000000
-#define  BCMA_CC_PMU15_PLL_PC0_FDCMODE_SHIFT	30
-#define  BCMA_CC_PMU15_PLL_PC0_CTRLBIAS_MASK	0x80000000
-#define  BCMA_CC_PMU15_PLL_PC0_CTRLBIAS_SHIFT	31
-
-/* ALP clock on pre-PMU chips */
-#define BCMA_CC_PMU_ALP_CLOCK		20000000
-/* HT clock for systems with PMU-enabled chipcommon */
-#define BCMA_CC_PMU_HT_CLOCK		80000000
-
-/* PMU rev 5 (& 6) */
-#define BCMA_CC_PPL_P1P2_OFF		0
-#define BCMA_CC_PPL_P1_MASK		0x0f000000
-#define BCMA_CC_PPL_P1_SHIFT		24
-#define BCMA_CC_PPL_P2_MASK		0x00f00000
-#define BCMA_CC_PPL_P2_SHIFT		20
-#define BCMA_CC_PPL_M14_OFF		1
-#define BCMA_CC_PPL_MDIV_MASK		0x000000ff
-#define BCMA_CC_PPL_MDIV_WIDTH		8
-#define BCMA_CC_PPL_NM5_OFF		2
-#define BCMA_CC_PPL_NDIV_MASK		0xfff00000
-#define BCMA_CC_PPL_NDIV_SHIFT		20
-#define BCMA_CC_PPL_FMAB_OFF		3
-#define BCMA_CC_PPL_MRAT_MASK		0xf0000000
-#define BCMA_CC_PPL_MRAT_SHIFT		28
-#define BCMA_CC_PPL_ABRAT_MASK		0x08000000
-#define BCMA_CC_PPL_ABRAT_SHIFT		27
-#define BCMA_CC_PPL_FDIV_MASK		0x07ffffff
-#define BCMA_CC_PPL_PLLCTL_OFF		4
-#define BCMA_CC_PPL_PCHI_OFF		5
-#define BCMA_CC_PPL_PCHI_MASK		0x0000003f
-
-#define BCMA_CC_PMU_PLL_CTL0		0
-#define BCMA_CC_PMU_PLL_CTL1		1
-#define BCMA_CC_PMU_PLL_CTL2		2
-#define BCMA_CC_PMU_PLL_CTL3		3
-#define BCMA_CC_PMU_PLL_CTL4		4
-#define BCMA_CC_PMU_PLL_CTL5		5
-
-#define BCMA_CC_PMU1_PLL0_PC0_P1DIV_MASK	0x00f00000
-#define BCMA_CC_PMU1_PLL0_PC0_P1DIV_SHIFT	20
-
-#define BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK	0x1ff00000
-#define BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT	20
-
-#define BCMA_CCB_MII_MNG_CTL		0x0000
-#define BCMA_CCB_MII_MNG_CMD_DATA	0x0004
-
-/* BCM4331 ChipControl numbers. */
-#define BCMA_CHIPCTL_4331_BT_COEXIST		BIT(0)	/* 0 disable */
-#define BCMA_CHIPCTL_4331_SECI			BIT(1)	/* 0 SECI is disabled (JATG functional) */
-#define BCMA_CHIPCTL_4331_EXT_LNA		BIT(2)	/* 0 disable */
-#define BCMA_CHIPCTL_4331_SPROM_GPIO13_15	BIT(3)	/* sprom/gpio13-15 mux */
-#define BCMA_CHIPCTL_4331_EXTPA_EN		BIT(4)	/* 0 ext pa disable, 1 ext pa enabled */
-#define BCMA_CHIPCTL_4331_GPIOCLK_ON_SPROMCS	BIT(5)	/* set drive out GPIO_CLK on sprom_cs pin */
-#define BCMA_CHIPCTL_4331_PCIE_MDIO_ON_SPROMCS	BIT(6)	/* use sprom_cs pin as PCIE mdio interface */
-#define BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5	BIT(7)	/* aband extpa will be at gpio2/5 and sprom_dout */
-#define BCMA_CHIPCTL_4331_OVR_PIPEAUXCLKEN	BIT(8)	/* override core control on pipe_AuxClkEnable */
-#define BCMA_CHIPCTL_4331_OVR_PIPEAUXPWRDOWN	BIT(9)	/* override core control on pipe_AuxPowerDown */
-#define BCMA_CHIPCTL_4331_PCIE_AUXCLKEN		BIT(10)	/* pcie_auxclkenable */
-#define BCMA_CHIPCTL_4331_PCIE_PIPE_PLLDOWN	BIT(11)	/* pcie_pipe_pllpowerdown */
-#define BCMA_CHIPCTL_4331_EXTPA_EN2		BIT(12)	/* 0 ext pa disable, 1 ext pa enabled */
-#define BCMA_CHIPCTL_4331_BT_SHD0_ON_GPIO4	BIT(16)	/* enable bt_shd0 at gpio4 */
-#define BCMA_CHIPCTL_4331_BT_SHD1_ON_GPIO5	BIT(17)	/* enable bt_shd1 at gpio5 */
-
-/* 43224 chip-specific ChipControl register bits */
-#define BCMA_CCTRL_43224_GPIO_TOGGLE		0x8000		/* gpio[3:0] pins as btcoex or s/w gpio */
-#define BCMA_CCTRL_43224A0_12MA_LED_DRIVE	0x00F000F0	/* 12 mA drive strength */
-#define BCMA_CCTRL_43224B0_12MA_LED_DRIVE	0xF0		/* 12 mA drive strength for later 43224s */
-
-/* 4313 Chip specific ChipControl register bits */
-#define BCMA_CCTRL_4313_12MA_LED_DRIVE		0x00000007	/* 12 mA drive strengh for later 4313 */
-
-/* BCM5357 ChipControl register bits */
-#define BCMA_CHIPCTL_5357_EXTPA			BIT(14)
-#define BCMA_CHIPCTL_5357_ANT_MUX_2O3		BIT(15)
-#define BCMA_CHIPCTL_5357_NFLASH		BIT(16)
-#define BCMA_CHIPCTL_5357_I2S_PINS_ENABLE	BIT(18)
-#define BCMA_CHIPCTL_5357_I2CSPI_PINS_ENABLE	BIT(19)
-
-#define BCMA_RES_4314_LPLDO_PU			BIT(0)
-#define BCMA_RES_4314_PMU_SLEEP_DIS		BIT(1)
-#define BCMA_RES_4314_PMU_BG_PU			BIT(2)
-#define BCMA_RES_4314_CBUCK_LPOM_PU		BIT(3)
-#define BCMA_RES_4314_CBUCK_PFM_PU		BIT(4)
-#define BCMA_RES_4314_CLDO_PU			BIT(5)
-#define BCMA_RES_4314_LPLDO2_LVM		BIT(6)
-#define BCMA_RES_4314_WL_PMU_PU			BIT(7)
-#define BCMA_RES_4314_LNLDO_PU			BIT(8)
-#define BCMA_RES_4314_LDO3P3_PU			BIT(9)
-#define BCMA_RES_4314_OTP_PU			BIT(10)
-#define BCMA_RES_4314_XTAL_PU			BIT(11)
-#define BCMA_RES_4314_WL_PWRSW_PU		BIT(12)
-#define BCMA_RES_4314_LQ_AVAIL			BIT(13)
-#define BCMA_RES_4314_LOGIC_RET			BIT(14)
-#define BCMA_RES_4314_MEM_SLEEP			BIT(15)
-#define BCMA_RES_4314_MACPHY_RET		BIT(16)
-#define BCMA_RES_4314_WL_CORE_READY		BIT(17)
-#define BCMA_RES_4314_ILP_REQ			BIT(18)
-#define BCMA_RES_4314_ALP_AVAIL			BIT(19)
-#define BCMA_RES_4314_MISC_PWRSW_PU		BIT(20)
-#define BCMA_RES_4314_SYNTH_PWRSW_PU		BIT(21)
-#define BCMA_RES_4314_RX_PWRSW_PU		BIT(22)
-#define BCMA_RES_4314_RADIO_PU			BIT(23)
-#define BCMA_RES_4314_VCO_LDO_PU		BIT(24)
-#define BCMA_RES_4314_AFE_LDO_PU		BIT(25)
-#define BCMA_RES_4314_RX_LDO_PU			BIT(26)
-#define BCMA_RES_4314_TX_LDO_PU			BIT(27)
-#define BCMA_RES_4314_HT_AVAIL			BIT(28)
-#define BCMA_RES_4314_MACPHY_CLK_AVAIL		BIT(29)
-
-/* Data for the PMU, if available.
- * Check availability with ((struct bcma_chipcommon)->capabilities & BCMA_CC_CAP_PMU)
- */
-struct bcma_chipcommon_pmu {
-	struct bcma_device *core;	/* Can be separated core or just ChipCommon one */
-	u8 rev;			/* PMU revision */
-	u32 crystalfreq;	/* The active crystal frequency (in kHz) */
-};
-
-#ifdef CPTCFG_BCMA_PFLASH
-struct bcma_pflash {
-	bool present;
-};
-#endif
-
-#ifdef CPTCFG_BCMA_SFLASH
-struct mtd_info;
-
-struct bcma_sflash {
-	bool present;
-	u32 blocksize;
-	u16 numblocks;
-	u32 size;
-};
-#endif
-
-#ifdef CPTCFG_BCMA_NFLASH
-struct bcma_nflash {
-	bool present;
-	bool boot;		/* This is the flash the SoC boots from */
-};
-#endif
-
-#ifdef CPTCFG_BCMA_DRIVER_MIPS
-struct bcma_serial_port {
-	void *regs;
-	unsigned long clockspeed;
-	unsigned int irq;
-	unsigned int baud_base;
-	unsigned int reg_shift;
-};
-#endif /* CPTCFG_BCMA_DRIVER_MIPS */
-
-struct bcma_drv_cc {
-	struct bcma_device *core;
-	u32 status;
-	u32 capabilities;
-	u32 capabilities_ext;
-	u8 setup_done:1;
-	u8 early_setup_done:1;
-	/* Fast Powerup Delay constant */
-	u16 fast_pwrup_delay;
-	struct bcma_chipcommon_pmu pmu;
-#ifdef CPTCFG_BCMA_PFLASH
-	struct bcma_pflash pflash;
-#endif
-#ifdef CPTCFG_BCMA_SFLASH
-	struct bcma_sflash sflash;
-#endif
-#ifdef CPTCFG_BCMA_NFLASH
-	struct bcma_nflash nflash;
-#endif
-
-#ifdef CPTCFG_BCMA_DRIVER_MIPS
-	int nr_serial_ports;
-	struct bcma_serial_port serial_ports[4];
-#endif /* CPTCFG_BCMA_DRIVER_MIPS */
-	u32 ticks_per_ms;
-	struct platform_device *watchdog;
-
-	/* Lock for GPIO register access. */
-	spinlock_t gpio_lock;
-#ifdef CPTCFG_BCMA_DRIVER_GPIO
-	struct gpio_chip gpio;
-#endif
-};
-
-struct bcma_drv_cc_b {
-	struct bcma_device *core;
-	u8 setup_done:1;
-	void __iomem *mii;
-};
-
-/* Register access */
-#define bcma_cc_read32(cc, offset) \
-	bcma_read32((cc)->core, offset)
-#define bcma_cc_write32(cc, offset, val) \
-	bcma_write32((cc)->core, offset, val)
-
-#define bcma_cc_mask32(cc, offset, mask) \
-	bcma_cc_write32(cc, offset, bcma_cc_read32(cc, offset) & (mask))
-#define bcma_cc_set32(cc, offset, set) \
-	bcma_cc_write32(cc, offset, bcma_cc_read32(cc, offset) | (set))
-#define bcma_cc_maskset32(cc, offset, mask, set) \
-	bcma_cc_write32(cc, offset, (bcma_cc_read32(cc, offset) & (mask)) | (set))
-
-/* PMU registers access */
-#define bcma_pmu_read32(cc, offset) \
-	bcma_read32((cc)->pmu.core, offset)
-#define bcma_pmu_write32(cc, offset, val) \
-	bcma_write32((cc)->pmu.core, offset, val)
-
-#define bcma_pmu_mask32(cc, offset, mask) \
-	bcma_pmu_write32(cc, offset, bcma_pmu_read32(cc, offset) & (mask))
-#define bcma_pmu_set32(cc, offset, set) \
-	bcma_pmu_write32(cc, offset, bcma_pmu_read32(cc, offset) | (set))
-#define bcma_pmu_maskset32(cc, offset, mask, set) \
-	bcma_pmu_write32(cc, offset, (bcma_pmu_read32(cc, offset) & (mask)) | (set))
-
-extern u32 bcma_chipco_watchdog_timer_set(struct bcma_drv_cc *cc, u32 ticks);
-
-extern u32 bcma_chipco_get_alp_clock(struct bcma_drv_cc *cc);
-
-void bcma_chipco_irq_mask(struct bcma_drv_cc *cc, u32 mask, u32 value);
-
-u32 bcma_chipco_irq_status(struct bcma_drv_cc *cc, u32 mask);
-
-/* Chipcommon GPIO pin access. */
-u32 bcma_chipco_gpio_in(struct bcma_drv_cc *cc, u32 mask);
-u32 bcma_chipco_gpio_out(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_outen(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_control(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_intmask(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_polarity(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_pullup(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_pulldown(struct bcma_drv_cc *cc, u32 mask, u32 value);
-
-/* PMU support */
-extern void bcma_chipco_pll_write(struct bcma_drv_cc *cc, u32 offset,
-				  u32 value);
-extern void bcma_chipco_pll_maskset(struct bcma_drv_cc *cc, u32 offset,
-				    u32 mask, u32 set);
-extern void bcma_chipco_chipctl_maskset(struct bcma_drv_cc *cc,
-					u32 offset, u32 mask, u32 set);
-extern void bcma_chipco_regctl_maskset(struct bcma_drv_cc *cc,
-				       u32 offset, u32 mask, u32 set);
-extern void bcma_pmu_spuravoid_pllupdate(struct bcma_drv_cc *cc, int spuravoid);
-
-extern u32 bcma_pmu_get_bus_clock(struct bcma_drv_cc *cc);
-
-void bcma_chipco_b_mii_write(struct bcma_drv_cc_b *ccb, u32 offset, u32 value);
-
-#endif /* LINUX_BCMA_DRIVER_CC_H_ */
diff --git a/include/linux/bcma/bcma_driver_gmac_cmn.h b/include/linux/bcma/bcma_driver_gmac_cmn.h
deleted file mode 100644
index 420e222..0000000
--- a/include/linux/bcma/bcma_driver_gmac_cmn.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_GMAC_CMN_H_
-#define LINUX_BCMA_DRIVER_GMAC_CMN_H_
-
-#include <linux/types.h>
-
-#define BCMA_GMAC_CMN_STAG0		0x000
-#define BCMA_GMAC_CMN_STAG1		0x004
-#define BCMA_GMAC_CMN_STAG2		0x008
-#define BCMA_GMAC_CMN_STAG3		0x00C
-#define BCMA_GMAC_CMN_PARSER_CTL	0x020
-#define BCMA_GMAC_CMN_MIB_MAX_LEN	0x024
-#define BCMA_GMAC_CMN_PHY_ACCESS	0x100
-#define  BCMA_GMAC_CMN_PA_DATA_MASK	0x0000ffff
-#define  BCMA_GMAC_CMN_PA_ADDR_MASK	0x001f0000
-#define  BCMA_GMAC_CMN_PA_ADDR_SHIFT	16
-#define  BCMA_GMAC_CMN_PA_REG_MASK	0x1f000000
-#define  BCMA_GMAC_CMN_PA_REG_SHIFT	24
-#define  BCMA_GMAC_CMN_PA_WRITE		0x20000000
-#define  BCMA_GMAC_CMN_PA_START		0x40000000
-#define BCMA_GMAC_CMN_PHY_CTL		0x104
-#define  BCMA_GMAC_CMN_PC_EPA_MASK	0x0000001f
-#define  BCMA_GMAC_CMN_PC_MCT_MASK	0x007f0000
-#define  BCMA_GMAC_CMN_PC_MCT_SHIFT	16
-#define  BCMA_GMAC_CMN_PC_MTE		0x00800000
-#define BCMA_GMAC_CMN_GMAC0_RGMII_CTL	0x110
-#define BCMA_GMAC_CMN_CFP_ACCESS	0x200
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA0	0x210
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA1	0x214
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA2	0x218
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA3	0x21C
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA4	0x220
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA5	0x224
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA6	0x228
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA7	0x22C
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK0	0x230
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK1	0x234
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK2	0x238
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK3	0x23C
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK4	0x240
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK5	0x244
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK6	0x248
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK7	0x24C
-#define BCMA_GMAC_CMN_CFP_ACTION_DATA	0x250
-#define BCMA_GMAC_CMN_TCAM_BIST_CTL	0x2A0
-#define BCMA_GMAC_CMN_TCAM_BIST_STATUS	0x2A4
-#define BCMA_GMAC_CMN_TCAM_CMP_STATUS	0x2A8
-#define BCMA_GMAC_CMN_TCAM_DISABLE	0x2AC
-#define BCMA_GMAC_CMN_TCAM_TEST_CTL	0x2F0
-#define BCMA_GMAC_CMN_UDF_0_A3_A0	0x300
-#define BCMA_GMAC_CMN_UDF_0_A7_A4	0x304
-#define BCMA_GMAC_CMN_UDF_0_A8		0x308
-#define BCMA_GMAC_CMN_UDF_1_A3_A0	0x310
-#define BCMA_GMAC_CMN_UDF_1_A7_A4	0x314
-#define BCMA_GMAC_CMN_UDF_1_A8		0x318
-#define BCMA_GMAC_CMN_UDF_2_A3_A0	0x320
-#define BCMA_GMAC_CMN_UDF_2_A7_A4	0x324
-#define BCMA_GMAC_CMN_UDF_2_A8		0x328
-#define BCMA_GMAC_CMN_UDF_0_B3_B0	0x330
-#define BCMA_GMAC_CMN_UDF_0_B7_B4	0x334
-#define BCMA_GMAC_CMN_UDF_0_B8		0x338
-#define BCMA_GMAC_CMN_UDF_1_B3_B0	0x340
-#define BCMA_GMAC_CMN_UDF_1_B7_B4	0x344
-#define BCMA_GMAC_CMN_UDF_1_B8		0x348
-#define BCMA_GMAC_CMN_UDF_2_B3_B0	0x350
-#define BCMA_GMAC_CMN_UDF_2_B7_B4	0x354
-#define BCMA_GMAC_CMN_UDF_2_B8		0x358
-#define BCMA_GMAC_CMN_UDF_0_C3_C0	0x360
-#define BCMA_GMAC_CMN_UDF_0_C7_C4	0x364
-#define BCMA_GMAC_CMN_UDF_0_C8		0x368
-#define BCMA_GMAC_CMN_UDF_1_C3_C0	0x370
-#define BCMA_GMAC_CMN_UDF_1_C7_C4	0x374
-#define BCMA_GMAC_CMN_UDF_1_C8		0x378
-#define BCMA_GMAC_CMN_UDF_2_C3_C0	0x380
-#define BCMA_GMAC_CMN_UDF_2_C7_C4	0x384
-#define BCMA_GMAC_CMN_UDF_2_C8		0x388
-#define BCMA_GMAC_CMN_UDF_0_D3_D0	0x390
-#define BCMA_GMAC_CMN_UDF_0_D7_D4	0x394
-#define BCMA_GMAC_CMN_UDF_0_D11_D8	0x394
-
-struct bcma_drv_gmac_cmn {
-	struct bcma_device *core;
-
-	/* Drivers accessing BCMA_GMAC_CMN_PHY_ACCESS and
-	 * BCMA_GMAC_CMN_PHY_CTL need to take that mutex first. */
-	struct mutex phy_mutex;
-};
-
-/* Register access */
-#define gmac_cmn_read16(gc, offset)		bcma_read16((gc)->core, offset)
-#define gmac_cmn_read32(gc, offset)		bcma_read32((gc)->core, offset)
-#define gmac_cmn_write16(gc, offset, val)	bcma_write16((gc)->core, offset, val)
-#define gmac_cmn_write32(gc, offset, val)	bcma_write32((gc)->core, offset, val)
-
-#endif /* LINUX_BCMA_DRIVER_GMAC_CMN_H_ */
diff --git a/include/linux/bcma/bcma_driver_mips.h b/include/linux/bcma/bcma_driver_mips.h
deleted file mode 100644
index 798013f..0000000
--- a/include/linux/bcma/bcma_driver_mips.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_MIPS_H_
-#define LINUX_BCMA_DRIVER_MIPS_H_
-
-#define BCMA_MIPS_IPSFLAG		0x0F08
-/* which sbflags get routed to mips interrupt 1 */
-#define  BCMA_MIPS_IPSFLAG_IRQ1		0x0000003F
-#define  BCMA_MIPS_IPSFLAG_IRQ1_SHIFT	0
-/* which sbflags get routed to mips interrupt 2 */
-#define  BCMA_MIPS_IPSFLAG_IRQ2		0x00003F00
-#define  BCMA_MIPS_IPSFLAG_IRQ2_SHIFT	8
-/* which sbflags get routed to mips interrupt 3 */
-#define  BCMA_MIPS_IPSFLAG_IRQ3		0x003F0000
-#define  BCMA_MIPS_IPSFLAG_IRQ3_SHIFT	16
-/* which sbflags get routed to mips interrupt 4 */
-#define  BCMA_MIPS_IPSFLAG_IRQ4		0x3F000000
-#define  BCMA_MIPS_IPSFLAG_IRQ4_SHIFT	24
-
-/* MIPS 74K core registers */
-#define BCMA_MIPS_MIPS74K_CORECTL	0x0000
-#define BCMA_MIPS_MIPS74K_EXCEPTBASE	0x0004
-#define BCMA_MIPS_MIPS74K_BIST		0x000C
-#define BCMA_MIPS_MIPS74K_INTMASK_INT0	0x0014
-#define BCMA_MIPS_MIPS74K_INTMASK(int) \
-	((int) * 4 + BCMA_MIPS_MIPS74K_INTMASK_INT0)
-#define BCMA_MIPS_MIPS74K_NMIMASK	0x002C
-#define BCMA_MIPS_MIPS74K_GPIOSEL	0x0040
-#define BCMA_MIPS_MIPS74K_GPIOOUT	0x0044
-#define BCMA_MIPS_MIPS74K_GPIOEN	0x0048
-#define BCMA_MIPS_MIPS74K_CLKCTLST	0x01E0
-
-#define BCMA_MIPS_OOBSELINA74		0x004
-#define BCMA_MIPS_OOBSELOUTA30		0x100
-
-struct bcma_device;
-
-struct bcma_drv_mips {
-	struct bcma_device *core;
-	u8 setup_done:1;
-	u8 early_setup_done:1;
-};
-
-extern u32 bcma_cpu_clock(struct bcma_drv_mips *mcore);
-
-#endif /* LINUX_BCMA_DRIVER_MIPS_H_ */
diff --git a/include/linux/bcma/bcma_driver_pci.h b/include/linux/bcma/bcma_driver_pci.h
deleted file mode 100644
index bca4771..0000000
--- a/include/linux/bcma/bcma_driver_pci.h
+++ /dev/null
@@ -1,264 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_PCI_H_
-#define LINUX_BCMA_DRIVER_PCI_H_
-
-#include <linux/types.h>
-
-struct pci_dev;
-
-/** PCI core registers. **/
-#define BCMA_CORE_PCI_CTL			0x0000	/* PCI Control */
-#define  BCMA_CORE_PCI_CTL_RST_OE		0x00000001 /* PCI_RESET Output Enable */
-#define  BCMA_CORE_PCI_CTL_RST			0x00000002 /* PCI_RESET driven out to pin */
-#define  BCMA_CORE_PCI_CTL_CLK_OE		0x00000004 /* Clock gate Output Enable */
-#define  BCMA_CORE_PCI_CTL_CLK			0x00000008 /* Gate for clock driven out to pin */
-#define BCMA_CORE_PCI_ARBCTL			0x0010	/* PCI Arbiter Control */
-#define  BCMA_CORE_PCI_ARBCTL_INTERN		0x00000001 /* Use internal arbiter */
-#define  BCMA_CORE_PCI_ARBCTL_EXTERN		0x00000002 /* Use external arbiter */
-#define  BCMA_CORE_PCI_ARBCTL_PARKID		0x00000006 /* Mask, selects which agent is parked on an idle bus */
-#define   BCMA_CORE_PCI_ARBCTL_PARKID_LAST	0x00000000 /* Last requestor */
-#define   BCMA_CORE_PCI_ARBCTL_PARKID_4710	0x00000002 /* 4710 */
-#define   BCMA_CORE_PCI_ARBCTL_PARKID_EXT0	0x00000004 /* External requestor 0 */
-#define   BCMA_CORE_PCI_ARBCTL_PARKID_EXT1	0x00000006 /* External requestor 1 */
-#define BCMA_CORE_PCI_ISTAT			0x0020	/* Interrupt status */
-#define  BCMA_CORE_PCI_ISTAT_INTA		0x00000001 /* PCI INTA# */
-#define  BCMA_CORE_PCI_ISTAT_INTB		0x00000002 /* PCI INTB# */
-#define  BCMA_CORE_PCI_ISTAT_SERR		0x00000004 /* PCI SERR# (write to clear) */
-#define  BCMA_CORE_PCI_ISTAT_PERR		0x00000008 /* PCI PERR# (write to clear) */
-#define  BCMA_CORE_PCI_ISTAT_PME		0x00000010 /* PCI PME# */
-#define BCMA_CORE_PCI_IMASK			0x0024	/* Interrupt mask */
-#define  BCMA_CORE_PCI_IMASK_INTA		0x00000001 /* PCI INTA# */
-#define  BCMA_CORE_PCI_IMASK_INTB		0x00000002 /* PCI INTB# */
-#define  BCMA_CORE_PCI_IMASK_SERR		0x00000004 /* PCI SERR# */
-#define  BCMA_CORE_PCI_IMASK_PERR		0x00000008 /* PCI PERR# */
-#define  BCMA_CORE_PCI_IMASK_PME		0x00000010 /* PCI PME# */
-#define BCMA_CORE_PCI_MBOX			0x0028	/* Backplane to PCI Mailbox */
-#define  BCMA_CORE_PCI_MBOX_F0_0		0x00000100 /* PCI function 0, INT 0 */
-#define  BCMA_CORE_PCI_MBOX_F0_1		0x00000200 /* PCI function 0, INT 1 */
-#define  BCMA_CORE_PCI_MBOX_F1_0		0x00000400 /* PCI function 1, INT 0 */
-#define  BCMA_CORE_PCI_MBOX_F1_1		0x00000800 /* PCI function 1, INT 1 */
-#define  BCMA_CORE_PCI_MBOX_F2_0		0x00001000 /* PCI function 2, INT 0 */
-#define  BCMA_CORE_PCI_MBOX_F2_1		0x00002000 /* PCI function 2, INT 1 */
-#define  BCMA_CORE_PCI_MBOX_F3_0		0x00004000 /* PCI function 3, INT 0 */
-#define  BCMA_CORE_PCI_MBOX_F3_1		0x00008000 /* PCI function 3, INT 1 */
-#define BCMA_CORE_PCI_BCAST_ADDR		0x0050	/* Backplane Broadcast Address */
-#define  BCMA_CORE_PCI_BCAST_ADDR_MASK		0x000000FF
-#define BCMA_CORE_PCI_BCAST_DATA		0x0054	/* Backplane Broadcast Data */
-#define BCMA_CORE_PCI_GPIO_IN			0x0060	/* rev >= 2 only */
-#define BCMA_CORE_PCI_GPIO_OUT			0x0064	/* rev >= 2 only */
-#define BCMA_CORE_PCI_GPIO_ENABLE		0x0068	/* rev >= 2 only */
-#define BCMA_CORE_PCI_GPIO_CTL			0x006C	/* rev >= 2 only */
-#define BCMA_CORE_PCI_SBTOPCI0			0x0100	/* Backplane to PCI translation 0 (sbtopci0) */
-#define  BCMA_CORE_PCI_SBTOPCI0_MASK		0xFC000000
-#define BCMA_CORE_PCI_SBTOPCI1			0x0104	/* Backplane to PCI translation 1 (sbtopci1) */
-#define  BCMA_CORE_PCI_SBTOPCI1_MASK		0xFC000000
-#define BCMA_CORE_PCI_SBTOPCI2			0x0108	/* Backplane to PCI translation 2 (sbtopci2) */
-#define  BCMA_CORE_PCI_SBTOPCI2_MASK		0xC0000000
-#define BCMA_CORE_PCI_CONFIG_ADDR		0x0120	/* pcie config space access */
-#define BCMA_CORE_PCI_CONFIG_DATA		0x0124	/* pcie config space access */
-#define BCMA_CORE_PCI_MDIO_CONTROL		0x0128	/* controls the mdio access */
-#define  BCMA_CORE_PCI_MDIOCTL_DIVISOR_MASK	0x7f	/* clock to be used on MDIO */
-#define  BCMA_CORE_PCI_MDIOCTL_DIVISOR_VAL	0x2
-#define  BCMA_CORE_PCI_MDIOCTL_PREAM_EN		0x80	/* Enable preamble sequnce */
-#define  BCMA_CORE_PCI_MDIOCTL_ACCESS_DONE	0x100	/* Tranaction complete */
-#define BCMA_CORE_PCI_MDIO_DATA			0x012c	/* Data to the mdio access */
-#define  BCMA_CORE_PCI_MDIODATA_MASK		0x0000ffff /* data 2 bytes */
-#define  BCMA_CORE_PCI_MDIODATA_TA		0x00020000 /* Turnaround */
-#define  BCMA_CORE_PCI_MDIODATA_REGADDR_SHF_OLD	18	/* Regaddr shift (rev < 10) */
-#define  BCMA_CORE_PCI_MDIODATA_REGADDR_MASK_OLD	0x003c0000 /* Regaddr Mask (rev < 10) */
-#define  BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF_OLD	22	/* Physmedia devaddr shift (rev < 10) */
-#define  BCMA_CORE_PCI_MDIODATA_DEVADDR_MASK_OLD	0x0fc00000 /* Physmedia devaddr Mask (rev < 10) */
-#define  BCMA_CORE_PCI_MDIODATA_REGADDR_SHF	18	/* Regaddr shift */
-#define  BCMA_CORE_PCI_MDIODATA_REGADDR_MASK	0x007c0000 /* Regaddr Mask */
-#define  BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF	23	/* Physmedia devaddr shift */
-#define  BCMA_CORE_PCI_MDIODATA_DEVADDR_MASK	0x0f800000 /* Physmedia devaddr Mask */
-#define  BCMA_CORE_PCI_MDIODATA_WRITE		0x10000000 /* write Transaction */
-#define  BCMA_CORE_PCI_MDIODATA_READ		0x20000000 /* Read Transaction */
-#define  BCMA_CORE_PCI_MDIODATA_START		0x40000000 /* start of Transaction */
-#define  BCMA_CORE_PCI_MDIODATA_DEV_ADDR	0x0	/* dev address for serdes */
-#define  BCMA_CORE_PCI_MDIODATA_BLK_ADDR	0x1F	/* blk address for serdes */
-#define  BCMA_CORE_PCI_MDIODATA_DEV_PLL		0x1d	/* SERDES PLL Dev */
-#define  BCMA_CORE_PCI_MDIODATA_DEV_TX		0x1e	/* SERDES TX Dev */
-#define  BCMA_CORE_PCI_MDIODATA_DEV_RX		0x1f	/* SERDES RX Dev */
-#define BCMA_CORE_PCI_PCIEIND_ADDR		0x0130	/* indirect access to the internal register */
-#define BCMA_CORE_PCI_PCIEIND_DATA		0x0134	/* Data to/from the internal register */
-#define BCMA_CORE_PCI_CLKREQENCTRL		0x0138	/*  >= rev 6, Clkreq rdma control */
-#define BCMA_CORE_PCI_PCICFG0			0x0400	/* PCI config space 0 (rev >= 8) */
-#define BCMA_CORE_PCI_PCICFG1			0x0500	/* PCI config space 1 (rev >= 8) */
-#define BCMA_CORE_PCI_PCICFG2			0x0600	/* PCI config space 2 (rev >= 8) */
-#define BCMA_CORE_PCI_PCICFG3			0x0700	/* PCI config space 3 (rev >= 8) */
-#define BCMA_CORE_PCI_SPROM(wordoffset)		(0x0800 + ((wordoffset) * 2)) /* SPROM shadow area (72 bytes) */
-#define  BCMA_CORE_PCI_SPROM_PI_OFFSET		0	/* first word */
-#define   BCMA_CORE_PCI_SPROM_PI_MASK		0xf000	/* bit 15:12 */
-#define   BCMA_CORE_PCI_SPROM_PI_SHIFT		12	/* bit 15:12 */
-#define  BCMA_CORE_PCI_SPROM_MISC_CONFIG	5	/* word 5 */
-#define   BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST	0x8000	/* bit 15 */
-#define   BCMA_CORE_PCI_SPROM_CLKREQ_OFFSET_REV5	20	/* word 20 for srom rev <= 5 */
-#define   BCMA_CORE_PCI_SPROM_CLKREQ_ENB	0x0800	/* bit 11 */
-
-/* SBtoPCIx */
-#define BCMA_CORE_PCI_SBTOPCI_MEM		0x00000000
-#define BCMA_CORE_PCI_SBTOPCI_IO		0x00000001
-#define BCMA_CORE_PCI_SBTOPCI_CFG0		0x00000002
-#define BCMA_CORE_PCI_SBTOPCI_CFG1		0x00000003
-#define BCMA_CORE_PCI_SBTOPCI_PREF		0x00000004 /* Prefetch enable */
-#define BCMA_CORE_PCI_SBTOPCI_BURST		0x00000008 /* Burst enable */
-#define BCMA_CORE_PCI_SBTOPCI_MRM		0x00000020 /* Memory Read Multiple */
-#define BCMA_CORE_PCI_SBTOPCI_RC		0x00000030 /* Read Command mask (rev >= 11) */
-#define  BCMA_CORE_PCI_SBTOPCI_RC_READ		0x00000000 /* Memory read */
-#define  BCMA_CORE_PCI_SBTOPCI_RC_READL		0x00000010 /* Memory read line */
-#define  BCMA_CORE_PCI_SBTOPCI_RC_READM		0x00000020 /* Memory read multiple */
-
-/* PCIE protocol PHY diagnostic registers */
-#define BCMA_CORE_PCI_PLP_MODEREG		0x200	/* Mode */
-#define BCMA_CORE_PCI_PLP_STATUSREG		0x204	/* Status */
-#define  BCMA_CORE_PCI_PLP_POLARITYINV_STAT	0x10	/* Status reg PCIE_PLP_STATUSREG */
-#define BCMA_CORE_PCI_PLP_LTSSMCTRLREG		0x208	/* LTSSM control */
-#define BCMA_CORE_PCI_PLP_LTLINKNUMREG		0x20c	/* Link Training Link number */
-#define BCMA_CORE_PCI_PLP_LTLANENUMREG		0x210	/* Link Training Lane number */
-#define BCMA_CORE_PCI_PLP_LTNFTSREG		0x214	/* Link Training N_FTS */
-#define BCMA_CORE_PCI_PLP_ATTNREG		0x218	/* Attention */
-#define BCMA_CORE_PCI_PLP_ATTNMASKREG		0x21C	/* Attention Mask */
-#define BCMA_CORE_PCI_PLP_RXERRCTR		0x220	/* Rx Error */
-#define BCMA_CORE_PCI_PLP_RXFRMERRCTR		0x224	/* Rx Framing Error */
-#define BCMA_CORE_PCI_PLP_RXERRTHRESHREG	0x228	/* Rx Error threshold */
-#define BCMA_CORE_PCI_PLP_TESTCTRLREG		0x22C	/* Test Control reg */
-#define BCMA_CORE_PCI_PLP_SERDESCTRLOVRDREG	0x230	/* SERDES Control Override */
-#define BCMA_CORE_PCI_PLP_TIMINGOVRDREG		0x234	/* Timing param override */
-#define BCMA_CORE_PCI_PLP_RXTXSMDIAGREG		0x238	/* RXTX State Machine Diag */
-#define BCMA_CORE_PCI_PLP_LTSSMDIAGREG		0x23C	/* LTSSM State Machine Diag */
-
-/* PCIE protocol DLLP diagnostic registers */
-#define BCMA_CORE_PCI_DLLP_LCREG		0x100	/* Link Control */
-#define BCMA_CORE_PCI_DLLP_LSREG		0x104	/* Link Status */
-#define BCMA_CORE_PCI_DLLP_LAREG		0x108	/* Link Attention */
-#define  BCMA_CORE_PCI_DLLP_LSREG_LINKUP	(1 << 16)
-#define BCMA_CORE_PCI_DLLP_LAMASKREG		0x10C	/* Link Attention Mask */
-#define BCMA_CORE_PCI_DLLP_NEXTTXSEQNUMREG	0x110	/* Next Tx Seq Num */
-#define BCMA_CORE_PCI_DLLP_ACKEDTXSEQNUMREG	0x114	/* Acked Tx Seq Num */
-#define BCMA_CORE_PCI_DLLP_PURGEDTXSEQNUMREG	0x118	/* Purged Tx Seq Num */
-#define BCMA_CORE_PCI_DLLP_RXSEQNUMREG		0x11C	/* Rx Sequence Number */
-#define BCMA_CORE_PCI_DLLP_LRREG		0x120	/* Link Replay */
-#define BCMA_CORE_PCI_DLLP_LACKTOREG		0x124	/* Link Ack Timeout */
-#define BCMA_CORE_PCI_DLLP_PMTHRESHREG		0x128	/* Power Management Threshold */
-#define  BCMA_CORE_PCI_ASPMTIMER_EXTEND		0x01000000 /* > rev7: enable extend ASPM timer */
-#define BCMA_CORE_PCI_DLLP_RTRYWPREG		0x12C	/* Retry buffer write ptr */
-#define BCMA_CORE_PCI_DLLP_RTRYRPREG		0x130	/* Retry buffer Read ptr */
-#define BCMA_CORE_PCI_DLLP_RTRYPPREG		0x134	/* Retry buffer Purged ptr */
-#define BCMA_CORE_PCI_DLLP_RTRRWREG		0x138	/* Retry buffer Read/Write */
-#define BCMA_CORE_PCI_DLLP_ECTHRESHREG		0x13C	/* Error Count Threshold */
-#define BCMA_CORE_PCI_DLLP_TLPERRCTRREG		0x140	/* TLP Error Counter */
-#define BCMA_CORE_PCI_DLLP_ERRCTRREG		0x144	/* Error Counter */
-#define BCMA_CORE_PCI_DLLP_NAKRXCTRREG		0x148	/* NAK Received Counter */
-#define BCMA_CORE_PCI_DLLP_TESTREG		0x14C	/* Test */
-#define BCMA_CORE_PCI_DLLP_PKTBIST		0x150	/* Packet BIST */
-#define BCMA_CORE_PCI_DLLP_PCIE11		0x154	/* DLLP PCIE 1.1 reg */
-
-/* SERDES RX registers */
-#define BCMA_CORE_PCI_SERDES_RX_CTRL		1	/* Rx cntrl */
-#define  BCMA_CORE_PCI_SERDES_RX_CTRL_FORCE	0x80	/* rxpolarity_force */
-#define  BCMA_CORE_PCI_SERDES_RX_CTRL_POLARITY	0x40	/* rxpolarity_value */
-#define BCMA_CORE_PCI_SERDES_RX_TIMER1		2	/* Rx Timer1 */
-#define BCMA_CORE_PCI_SERDES_RX_CDR		6	/* CDR */
-#define BCMA_CORE_PCI_SERDES_RX_CDRBW		7	/* CDR BW */
-
-/* SERDES PLL registers */
-#define BCMA_CORE_PCI_SERDES_PLL_CTRL		1	/* PLL control reg */
-#define BCMA_CORE_PCI_PLL_CTRL_FREQDET_EN	0x4000	/* bit 14 is FREQDET on */
-
-/* PCIcore specific boardflags */
-#define BCMA_CORE_PCI_BFL_NOPCI			0x00000400 /* Board leaves PCI floating */
-
-/* PCIE Config space accessing MACROS */
-#define BCMA_CORE_PCI_CFG_BUS_SHIFT		24	/* Bus shift */
-#define BCMA_CORE_PCI_CFG_SLOT_SHIFT		19	/* Slot/Device shift */
-#define BCMA_CORE_PCI_CFG_FUN_SHIFT		16	/* Function shift */
-#define BCMA_CORE_PCI_CFG_OFF_SHIFT		0	/* Register shift */
-
-#define BCMA_CORE_PCI_CFG_BUS_MASK		0xff	/* Bus mask */
-#define BCMA_CORE_PCI_CFG_SLOT_MASK		0x1f	/* Slot/Device mask */
-#define BCMA_CORE_PCI_CFG_FUN_MASK		7	/* Function mask */
-#define BCMA_CORE_PCI_CFG_OFF_MASK		0xfff	/* Register mask */
-
-#define BCMA_CORE_PCI_CFG_DEVCTRL		0xd8
-
-#define BCMA_CORE_PCI_
-
-/* MDIO devices (SERDES modules) */
-#define BCMA_CORE_PCI_MDIO_IEEE0		0x000
-#define BCMA_CORE_PCI_MDIO_IEEE1		0x001
-#define BCMA_CORE_PCI_MDIO_BLK0			0x800
-#define BCMA_CORE_PCI_MDIO_BLK1			0x801
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT0		0x16
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT1		0x17
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT2		0x18
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT3		0x19
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT4		0x1A
-#define BCMA_CORE_PCI_MDIO_BLK2			0x802
-#define BCMA_CORE_PCI_MDIO_BLK3			0x803
-#define BCMA_CORE_PCI_MDIO_BLK4			0x804
-#define BCMA_CORE_PCI_MDIO_TXPLL		0x808	/* TXPLL register block idx */
-#define BCMA_CORE_PCI_MDIO_TXCTRL0		0x820
-#define BCMA_CORE_PCI_MDIO_SERDESID		0x831
-#define BCMA_CORE_PCI_MDIO_RXCTRL0		0x840
-
-/* PCIE Root Capability Register bits (Host mode only) */
-#define BCMA_CORE_PCI_RC_CRS_VISIBILITY		0x0001
-
-struct bcma_drv_pci;
-struct bcma_bus;
-
-#ifdef CPTCFG_BCMA_DRIVER_PCI_HOSTMODE
-struct bcma_drv_pci_host {
-	struct bcma_drv_pci *pdev;
-
-	u32 host_cfg_addr;
-	spinlock_t cfgspace_lock;
-
-	struct pci_controller pci_controller;
-	struct pci_ops pci_ops;
-	struct resource mem_resource;
-	struct resource io_resource;
-};
-#endif
-
-struct bcma_drv_pci {
-	struct bcma_device *core;
-	u8 early_setup_done:1;
-	u8 setup_done:1;
-	u8 hostmode:1;
-
-#ifdef CPTCFG_BCMA_DRIVER_PCI_HOSTMODE
-	struct bcma_drv_pci_host *host_controller;
-#endif
-};
-
-/* Register access */
-#define pcicore_read16(pc, offset)		bcma_read16((pc)->core, offset)
-#define pcicore_read32(pc, offset)		bcma_read32((pc)->core, offset)
-#define pcicore_write16(pc, offset, val)	bcma_write16((pc)->core, offset, val)
-#define pcicore_write32(pc, offset, val)	bcma_write32((pc)->core, offset, val)
-
-#ifdef CPTCFG_BCMA_DRIVER_PCI
-extern void bcma_core_pci_power_save(struct bcma_bus *bus, bool up);
-#else
-static inline void bcma_core_pci_power_save(struct bcma_bus *bus, bool up)
-{
-}
-#endif
-
-#ifdef CPTCFG_BCMA_DRIVER_PCI_HOSTMODE
-extern int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev);
-extern int bcma_core_pci_plat_dev_init(struct pci_dev *dev);
-#else
-static inline int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev)
-{
-	return -ENOTSUPP;
-}
-static inline int bcma_core_pci_plat_dev_init(struct pci_dev *dev)
-{
-	return -ENOTSUPP;
-}
-#endif
-
-#endif /* LINUX_BCMA_DRIVER_PCI_H_ */
diff --git a/include/linux/bcma/bcma_driver_pcie2.h b/include/linux/bcma/bcma_driver_pcie2.h
deleted file mode 100644
index 91ce515..0000000
--- a/include/linux/bcma/bcma_driver_pcie2.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_PCIE2_H_
-#define LINUX_BCMA_DRIVER_PCIE2_H_
-
-#define BCMA_CORE_PCIE2_CLK_CONTROL		0x0000
-#define  PCIE2_CLKC_RST_OE			0x0001 /* When set, drives PCI_RESET out to pin */
-#define  PCIE2_CLKC_RST				0x0002 /* Value driven out to pin */
-#define  PCIE2_CLKC_SPERST			0x0004 /* SurvivePeRst */
-#define  PCIE2_CLKC_DISABLE_L1CLK_GATING	0x0010
-#define  PCIE2_CLKC_DLYPERST			0x0100 /* Delay PeRst to CoE Core */
-#define  PCIE2_CLKC_DISSPROMLD			0x0200 /* DisableSpromLoadOnPerst */
-#define  PCIE2_CLKC_WAKE_MODE_L2		0x1000 /* Wake on L2 */
-#define BCMA_CORE_PCIE2_RC_PM_CONTROL		0x0004
-#define BCMA_CORE_PCIE2_RC_PM_STATUS		0x0008
-#define BCMA_CORE_PCIE2_EP_PM_CONTROL		0x000C
-#define BCMA_CORE_PCIE2_EP_PM_STATUS		0x0010
-#define BCMA_CORE_PCIE2_EP_LTR_CONTROL		0x0014
-#define BCMA_CORE_PCIE2_EP_LTR_STATUS		0x0018
-#define BCMA_CORE_PCIE2_EP_OBFF_STATUS		0x001C
-#define BCMA_CORE_PCIE2_PCIE_ERR_STATUS		0x0020
-#define BCMA_CORE_PCIE2_RC_AXI_CONFIG		0x0100
-#define BCMA_CORE_PCIE2_EP_AXI_CONFIG		0x0104
-#define BCMA_CORE_PCIE2_RXDEBUG_STATUS0		0x0108
-#define BCMA_CORE_PCIE2_RXDEBUG_CONTROL0	0x010C
-#define BCMA_CORE_PCIE2_CONFIGINDADDR		0x0120
-#define BCMA_CORE_PCIE2_CONFIGINDDATA		0x0124
-#define BCMA_CORE_PCIE2_MDIOCONTROL		0x0128
-#define BCMA_CORE_PCIE2_MDIOWRDATA		0x012C
-#define BCMA_CORE_PCIE2_MDIORDDATA		0x0130
-#define BCMA_CORE_PCIE2_DATAINTF		0x0180
-#define BCMA_CORE_PCIE2_D2H_INTRLAZY_0		0x0188
-#define BCMA_CORE_PCIE2_H2D_INTRLAZY_0		0x018c
-#define BCMA_CORE_PCIE2_H2D_INTSTAT_0		0x0190
-#define BCMA_CORE_PCIE2_H2D_INTMASK_0		0x0194
-#define BCMA_CORE_PCIE2_D2H_INTSTAT_0		0x0198
-#define BCMA_CORE_PCIE2_D2H_INTMASK_0		0x019c
-#define BCMA_CORE_PCIE2_LTR_STATE		0x01A0 /* Latency Tolerance Reporting */
-#define  PCIE2_LTR_ACTIVE			2
-#define  PCIE2_LTR_ACTIVE_IDLE			1
-#define  PCIE2_LTR_SLEEP			0
-#define  PCIE2_LTR_FINAL_MASK			0x300
-#define  PCIE2_LTR_FINAL_SHIFT			8
-#define BCMA_CORE_PCIE2_PWR_INT_STATUS		0x01A4
-#define BCMA_CORE_PCIE2_PWR_INT_MASK		0x01A8
-#define BCMA_CORE_PCIE2_CFG_ADDR		0x01F8
-#define BCMA_CORE_PCIE2_CFG_DATA		0x01FC
-#define BCMA_CORE_PCIE2_SYS_EQ_PAGE		0x0200
-#define BCMA_CORE_PCIE2_SYS_MSI_PAGE		0x0204
-#define BCMA_CORE_PCIE2_SYS_MSI_INTREN		0x0208
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL0		0x0210
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL1		0x0214
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL2		0x0218
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL3		0x021C
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL4		0x0220
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL5		0x0224
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD0		0x0250
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL0		0x0254
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD1		0x0258
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL1		0x025C
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD2		0x0260
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL2		0x0264
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD3		0x0268
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL3		0x026C
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD4		0x0270
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL4		0x0274
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD5		0x0278
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL5		0x027C
-#define BCMA_CORE_PCIE2_SYS_RC_INTX_EN		0x0330
-#define BCMA_CORE_PCIE2_SYS_RC_INTX_CSR		0x0334
-#define BCMA_CORE_PCIE2_SYS_MSI_REQ		0x0340
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR_EN	0x0344
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR_CSR	0x0348
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR0		0x0350
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR1		0x0354
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR2		0x0358
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR3		0x035C
-#define BCMA_CORE_PCIE2_SYS_EP_INT_EN0		0x0360
-#define BCMA_CORE_PCIE2_SYS_EP_INT_EN1		0x0364
-#define BCMA_CORE_PCIE2_SYS_EP_INT_CSR0		0x0370
-#define BCMA_CORE_PCIE2_SYS_EP_INT_CSR1		0x0374
-#define BCMA_CORE_PCIE2_SPROM(wordoffset)	(0x0800 + ((wordoffset) * 2))
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_0		0x0C00
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_1		0x0C04
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_2		0x0C08
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_3		0x0C0C
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_4		0x0C10
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_5		0x0C14
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_6		0x0C18
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_7		0x0C1C
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_0		0x0C20
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_1		0x0C24
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_2		0x0C28
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_3		0x0C2C
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_4		0x0C30
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_5		0x0C34
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_6		0x0C38
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_7		0x0C3C
-#define BCMA_CORE_PCIE2_FUNC0_IMAP1		0x0C80
-#define BCMA_CORE_PCIE2_FUNC1_IMAP1		0x0C88
-#define BCMA_CORE_PCIE2_FUNC0_IMAP2		0x0CC0
-#define BCMA_CORE_PCIE2_FUNC1_IMAP2		0x0CC8
-#define BCMA_CORE_PCIE2_IARR0_LOWER		0x0D00
-#define BCMA_CORE_PCIE2_IARR0_UPPER		0x0D04
-#define BCMA_CORE_PCIE2_IARR1_LOWER		0x0D08
-#define BCMA_CORE_PCIE2_IARR1_UPPER		0x0D0C
-#define BCMA_CORE_PCIE2_IARR2_LOWER		0x0D10
-#define BCMA_CORE_PCIE2_IARR2_UPPER		0x0D14
-#define BCMA_CORE_PCIE2_OARR0			0x0D20
-#define BCMA_CORE_PCIE2_OARR1			0x0D28
-#define BCMA_CORE_PCIE2_OARR2			0x0D30
-#define BCMA_CORE_PCIE2_OMAP0_LOWER		0x0D40
-#define BCMA_CORE_PCIE2_OMAP0_UPPER		0x0D44
-#define BCMA_CORE_PCIE2_OMAP1_LOWER		0x0D48
-#define BCMA_CORE_PCIE2_OMAP1_UPPER		0x0D4C
-#define BCMA_CORE_PCIE2_OMAP2_LOWER		0x0D50
-#define BCMA_CORE_PCIE2_OMAP2_UPPER		0x0D54
-#define BCMA_CORE_PCIE2_FUNC1_IARR1_SIZE	0x0D58
-#define BCMA_CORE_PCIE2_FUNC1_IARR2_SIZE	0x0D5C
-#define BCMA_CORE_PCIE2_MEM_CONTROL		0x0F00
-#define BCMA_CORE_PCIE2_MEM_ECC_ERRLOG0		0x0F04
-#define BCMA_CORE_PCIE2_MEM_ECC_ERRLOG1		0x0F08
-#define BCMA_CORE_PCIE2_LINK_STATUS		0x0F0C
-#define BCMA_CORE_PCIE2_STRAP_STATUS		0x0F10
-#define BCMA_CORE_PCIE2_RESET_STATUS		0x0F14
-#define BCMA_CORE_PCIE2_RESETEN_IN_LINKDOWN	0x0F18
-#define BCMA_CORE_PCIE2_MISC_INTR_EN		0x0F1C
-#define BCMA_CORE_PCIE2_TX_DEBUG_CFG		0x0F20
-#define BCMA_CORE_PCIE2_MISC_CONFIG		0x0F24
-#define BCMA_CORE_PCIE2_MISC_STATUS		0x0F28
-#define BCMA_CORE_PCIE2_INTR_EN			0x0F30
-#define BCMA_CORE_PCIE2_INTR_CLEAR		0x0F34
-#define BCMA_CORE_PCIE2_INTR_STATUS		0x0F38
-
-/* PCIE gen2 config regs */
-#define PCIE2_INTSTATUS				0x090
-#define PCIE2_INTMASK				0x094
-#define PCIE2_SBMBX				0x098
-
-#define PCIE2_PMCR_REFUP			0x1814 /* Trefup time */
-
-#define PCIE2_CAP_DEVSTSCTRL2_OFFSET		0xD4
-#define PCIE2_CAP_DEVSTSCTRL2_LTRENAB		0x400
-#define PCIE2_PVT_REG_PM_CLK_PERIOD		0x184c
-
-struct bcma_drv_pcie2 {
-	struct bcma_device *core;
-
-	u16 reqsize;
-};
-
-#define pcie2_read16(pcie2, offset)		bcma_read16((pcie2)->core, offset)
-#define pcie2_read32(pcie2, offset)		bcma_read32((pcie2)->core, offset)
-#define pcie2_write16(pcie2, offset, val)	bcma_write16((pcie2)->core, offset, val)
-#define pcie2_write32(pcie2, offset, val)	bcma_write32((pcie2)->core, offset, val)
-
-#define pcie2_set32(pcie2, offset, set)		bcma_set32((pcie2)->core, offset, set)
-#define pcie2_mask32(pcie2, offset, mask)	bcma_mask32((pcie2)->core, offset, mask)
-
-#endif /* LINUX_BCMA_DRIVER_PCIE2_H_ */
diff --git a/include/linux/bcma/bcma_regs.h b/include/linux/bcma/bcma_regs.h
deleted file mode 100644
index 944105c..0000000
--- a/include/linux/bcma/bcma_regs.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_REGS_H_
-#define LINUX_BCMA_REGS_H_
-
-/* Some single registers are shared between many cores */
-/* BCMA_CLKCTLST: ChipCommon (rev >= 20), PCIe, 80211 */
-#define BCMA_CLKCTLST			0x01E0 /* Clock control and status */
-#define  BCMA_CLKCTLST_FORCEALP		0x00000001 /* Force ALP request */
-#define  BCMA_CLKCTLST_FORCEHT		0x00000002 /* Force HT request */
-#define  BCMA_CLKCTLST_FORCEILP		0x00000004 /* Force ILP request */
-#define  BCMA_CLKCTLST_HAVEALPREQ	0x00000008 /* ALP available request */
-#define  BCMA_CLKCTLST_HAVEHTREQ	0x00000010 /* HT available request */
-#define  BCMA_CLKCTLST_HWCROFF		0x00000020 /* Force HW clock request off */
-#define  BCMA_CLKCTLST_HQCLKREQ		0x00000040 /* HQ Clock */
-#define  BCMA_CLKCTLST_EXTRESREQ	0x00000700 /* Mask of external resource requests */
-#define  BCMA_CLKCTLST_EXTRESREQ_SHIFT	8
-#define  BCMA_CLKCTLST_HAVEALP		0x00010000 /* ALP available */
-#define  BCMA_CLKCTLST_HAVEHT		0x00020000 /* HT available */
-#define  BCMA_CLKCTLST_BP_ON_ALP	0x00040000 /* RO: running on ALP clock */
-#define  BCMA_CLKCTLST_BP_ON_HT		0x00080000 /* RO: running on HT clock */
-#define  BCMA_CLKCTLST_EXTRESST		0x07000000 /* Mask of external resource status */
-#define  BCMA_CLKCTLST_EXTRESST_SHIFT	24
-/* Is there any BCM4328 on BCMA bus? */
-#define  BCMA_CLKCTLST_4328A0_HAVEHT	0x00010000 /* 4328a0 has reversed bits */
-#define  BCMA_CLKCTLST_4328A0_HAVEALP	0x00020000 /* 4328a0 has reversed bits */
-
-/* Agent registers (common for every core) */
-#define BCMA_OOB_SEL_OUT_A30		0x0100
-#define BCMA_IOCTL			0x0408 /* IO control */
-#define  BCMA_IOCTL_CLK			0x0001
-#define  BCMA_IOCTL_FGC			0x0002
-#define  BCMA_IOCTL_CORE_BITS		0x3FFC
-#define  BCMA_IOCTL_PME_EN		0x4000
-#define  BCMA_IOCTL_BIST_EN		0x8000
-#define BCMA_IOST			0x0500 /* IO status */
-#define  BCMA_IOST_CORE_BITS		0x0FFF
-#define  BCMA_IOST_DMA64		0x1000
-#define  BCMA_IOST_GATED_CLK		0x2000
-#define  BCMA_IOST_BIST_ERROR		0x4000
-#define  BCMA_IOST_BIST_DONE		0x8000
-#define BCMA_RESET_CTL			0x0800
-#define  BCMA_RESET_CTL_RESET		0x0001
-#define BCMA_RESET_ST			0x0804
-
-#define BCMA_NS_ROM_IOST_BOOT_DEV_MASK	0x0003
-#define BCMA_NS_ROM_IOST_BOOT_DEV_NOR	0x0000
-#define BCMA_NS_ROM_IOST_BOOT_DEV_NAND	0x0001
-#define BCMA_NS_ROM_IOST_BOOT_DEV_ROM	0x0002
-
-/* BCMA PCI config space registers. */
-#define BCMA_PCI_PMCSR			0x44
-#define  BCMA_PCI_PE			0x100
-#define BCMA_PCI_BAR0_WIN		0x80	/* Backplane address space 0 */
-#define BCMA_PCI_BAR1_WIN		0x84	/* Backplane address space 1 */
-#define BCMA_PCI_SPROMCTL		0x88	/* SPROM control */
-#define  BCMA_PCI_SPROMCTL_WE		0x10	/* SPROM write enable */
-#define BCMA_PCI_BAR1_CONTROL		0x8c	/* Address space 1 burst control */
-#define BCMA_PCI_IRQS			0x90	/* PCI interrupts */
-#define BCMA_PCI_IRQMASK		0x94	/* PCI IRQ control and mask (pcirev >= 6 only) */
-#define BCMA_PCI_BACKPLANE_IRQS		0x98	/* Backplane Interrupts */
-#define BCMA_PCI_BAR0_WIN2		0xAC
-#define BCMA_PCI_GPIO_IN		0xB0	/* GPIO Input (pcirev >= 3 only) */
-#define BCMA_PCI_GPIO_OUT		0xB4	/* GPIO Output (pcirev >= 3 only) */
-#define BCMA_PCI_GPIO_OUT_ENABLE	0xB8	/* GPIO Output Enable/Disable (pcirev >= 3 only) */
-#define  BCMA_PCI_GPIO_SCS		0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
-#define  BCMA_PCI_GPIO_HWRAD		0x20	/* PCI config space GPIO 13 for hw radio disable */
-#define  BCMA_PCI_GPIO_XTAL		0x40	/* PCI config space GPIO 14 for Xtal powerup */
-#define  BCMA_PCI_GPIO_PLL		0x80	/* PCI config space GPIO 15 for PLL powerdown */
-
-#define BCMA_PCIE2_BAR0_WIN2		0x70
-
-/* SiliconBackplane Address Map.
- * All regions may not exist on all chips.
- */
-#define BCMA_SOC_SDRAM_BASE		0x00000000U	/* Physical SDRAM */
-#define BCMA_SOC_PCI_MEM		0x08000000U	/* Host Mode sb2pcitranslation0 (64 MB) */
-#define BCMA_SOC_PCI_MEM_SZ		(64 * 1024 * 1024)
-#define BCMA_SOC_PCI_CFG		0x0c000000U	/* Host Mode sb2pcitranslation1 (64 MB) */
-#define BCMA_SOC_SDRAM_SWAPPED		0x10000000U	/* Byteswapped Physical SDRAM */
-#define BCMA_SOC_SDRAM_R2		0x80000000U	/* Region 2 for sdram (512 MB) */
-
-
-#define BCMA_SOC_PCI_DMA		0x40000000U	/* Client Mode sb2pcitranslation2 (1 GB) */
-#define BCMA_SOC_PCI_DMA2		0x80000000U	/* Client Mode sb2pcitranslation2 (1 GB) */
-#define BCMA_SOC_PCI_DMA_SZ		0x40000000U	/* Client Mode sb2pcitranslation2 size in bytes */
-#define BCMA_SOC_PCIE_DMA_L32		0x00000000U	/* PCIE Client Mode sb2pcitranslation2
-							 * (2 ZettaBytes), low 32 bits
-							 */
-#define BCMA_SOC_PCIE_DMA_H32		0x80000000U	/* PCIE Client Mode sb2pcitranslation2
-							 * (2 ZettaBytes), high 32 bits
-							 */
-
-#define BCMA_SOC_PCI1_MEM		0x40000000U	/* Host Mode sb2pcitranslation0 (64 MB) */
-#define BCMA_SOC_PCI1_CFG		0x44000000U	/* Host Mode sb2pcitranslation1 (64 MB) */
-#define BCMA_SOC_PCIE1_DMA_H32		0xc0000000U	/* PCIE Client Mode sb2pcitranslation2
-							 * (2 ZettaBytes), high 32 bits
-							 */
-
-#define BCMA_SOC_FLASH1			0x1fc00000	/* MIPS Flash Region 1 */
-#define BCMA_SOC_FLASH1_SZ		0x00400000	/* MIPS Size of Flash Region 1 */
-#define BCMA_SOC_FLASH2			0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
-#define BCMA_SOC_FLASH2_SZ		0x02000000	/* Size of Flash Region 2 */
-
-#endif /* LINUX_BCMA_REGS_H_ */
diff --git a/include/linux/bcma/bcma_soc.h b/include/linux/bcma/bcma_soc.h
deleted file mode 100644
index f3c4351..0000000
--- a/include/linux/bcma/bcma_soc.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_SOC_H_
-#define LINUX_BCMA_SOC_H_
-
-#include <linux/bcma/bcma.h>
-
-struct bcma_soc {
-	struct bcma_bus bus;
-	struct device *dev;
-};
-
-int __init bcma_host_soc_register(struct bcma_soc *soc);
-int __init bcma_host_soc_init(struct bcma_soc *soc);
-
-int bcma_bus_register(struct bcma_bus *bus);
-
-#endif /* LINUX_BCMA_SOC_H_ */
diff --git a/include/linux/ieee80211.h b/include/linux/ieee80211.h
index 9c03a7d..e783d17 100644
--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -1659,6 +1659,7 @@ struct ieee80211_mu_edca_param_set {
 #define IEEE80211_VHT_CAP_RXSTBC_3				0x00000300
 #define IEEE80211_VHT_CAP_RXSTBC_4				0x00000400
 #define IEEE80211_VHT_CAP_RXSTBC_MASK				0x00000700
+#define IEEE80211_VHT_CAP_RXSTBC_SHIFT				8
 #define IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE			0x00000800
 #define IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE			0x00001000
 #define IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT                  13
diff --git a/include/linux/spi/libertas_spi.h b/include/linux/spi/libertas_spi.h
deleted file mode 100644
index 1b5d538..0000000
--- a/include/linux/spi/libertas_spi.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * board-specific data for the libertas_spi driver.
- *
- * Copyright 2008 Analog Devices Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- */
-#ifndef _LIBERTAS_SPI_H_
-#define _LIBERTAS_SPI_H_
-
-struct spi_device;
-
-struct libertas_spi_platform_data {
-	/* There are two ways to read data from the WLAN module's SPI
-	 * interface. Setting 0 or 1 here controls which one is used.
-	 *
-	 * Usually you want to set use_dummy_writes = 1.
-	 * However, if that doesn't work or if you are using a slow SPI clock
-	 * speed, you may want to use 0 here. */
-	u16 use_dummy_writes;
-
-	/* Board specific setup/teardown */
-	int (*setup)(struct spi_device *spi);
-	int (*teardown)(struct spi_device *spi);
-};
-#endif
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
deleted file mode 100644
index ed67bd6..0000000
--- a/include/linux/ssb/ssb.h
+++ /dev/null
@@ -1,682 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_H_
-#define LINUX_SSB_H_
-
-#include <linux/device.h>
-#include <linux/list.h>
-#include <linux/types.h>
-#include <linux/spinlock.h>
-#include <linux/pci.h>
-#include <linux/gpio.h>
-#include <linux/mod_devicetable.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-
-#include <linux/ssb/ssb_regs.h>
-
-
-struct pcmcia_device;
-struct ssb_bus;
-struct ssb_driver;
-
-struct ssb_sprom_core_pwr_info {
-	u8 itssi_2g, itssi_5g;
-	u8 maxpwr_2g, maxpwr_5gl, maxpwr_5g, maxpwr_5gh;
-	u16 pa_2g[4], pa_5gl[4], pa_5g[4], pa_5gh[4];
-};
-
-struct ssb_sprom {
-	u8 revision;
-	u8 il0mac[6] __aligned(sizeof(u16));	/* MAC address for 802.11b/g */
-	u8 et0mac[6] __aligned(sizeof(u16));	/* MAC address for Ethernet */
-	u8 et1mac[6] __aligned(sizeof(u16));	/* MAC address for 802.11a */
-	u8 et2mac[6] __aligned(sizeof(u16));	/* MAC address for extra Ethernet */
-	u8 et0phyaddr;		/* MII address for enet0 */
-	u8 et1phyaddr;		/* MII address for enet1 */
-	u8 et2phyaddr;		/* MII address for enet2 */
-	u8 et0mdcport;		/* MDIO for enet0 */
-	u8 et1mdcport;		/* MDIO for enet1 */
-	u8 et2mdcport;		/* MDIO for enet2 */
-	u16 dev_id;		/* Device ID overriding e.g. PCI ID */
-	u16 board_rev;		/* Board revision number from SPROM. */
-	u16 board_num;		/* Board number from SPROM. */
-	u16 board_type;		/* Board type from SPROM. */
-	u8 country_code;	/* Country Code */
-	char alpha2[2];		/* Country Code as two chars like EU or US */
-	u8 leddc_on_time;	/* LED Powersave Duty Cycle On Count */
-	u8 leddc_off_time;	/* LED Powersave Duty Cycle Off Count */
-	u8 ant_available_a;	/* 2GHz antenna available bits (up to 4) */
-	u8 ant_available_bg;	/* 5GHz antenna available bits (up to 4) */
-	u16 pa0b0;
-	u16 pa0b1;
-	u16 pa0b2;
-	u16 pa1b0;
-	u16 pa1b1;
-	u16 pa1b2;
-	u16 pa1lob0;
-	u16 pa1lob1;
-	u16 pa1lob2;
-	u16 pa1hib0;
-	u16 pa1hib1;
-	u16 pa1hib2;
-	u8 gpio0;		/* GPIO pin 0 */
-	u8 gpio1;		/* GPIO pin 1 */
-	u8 gpio2;		/* GPIO pin 2 */
-	u8 gpio3;		/* GPIO pin 3 */
-	u8 maxpwr_bg;		/* 2.4GHz Amplifier Max Power (in dBm Q5.2) */
-	u8 maxpwr_al;		/* 5.2GHz Amplifier Max Power (in dBm Q5.2) */
-	u8 maxpwr_a;		/* 5.3GHz Amplifier Max Power (in dBm Q5.2) */
-	u8 maxpwr_ah;		/* 5.8GHz Amplifier Max Power (in dBm Q5.2) */
-	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
-	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
-	u8 tri2g;		/* 2.4GHz TX isolation */
-	u8 tri5gl;		/* 5.2GHz TX isolation */
-	u8 tri5g;		/* 5.3GHz TX isolation */
-	u8 tri5gh;		/* 5.8GHz TX isolation */
-	u8 txpid2g[4];		/* 2GHz TX power index */
-	u8 txpid5gl[4];		/* 4.9 - 5.1GHz TX power index */
-	u8 txpid5g[4];		/* 5.1 - 5.5GHz TX power index */
-	u8 txpid5gh[4];		/* 5.5 - ...GHz TX power index */
-	s8 rxpo2g;		/* 2GHz RX power offset */
-	s8 rxpo5g;		/* 5GHz RX power offset */
-	u8 rssisav2g;		/* 2GHz RSSI params */
-	u8 rssismc2g;
-	u8 rssismf2g;
-	u8 bxa2g;		/* 2GHz BX arch */
-	u8 rssisav5g;		/* 5GHz RSSI params */
-	u8 rssismc5g;
-	u8 rssismf5g;
-	u8 bxa5g;		/* 5GHz BX arch */
-	u16 cck2gpo;		/* CCK power offset */
-	u32 ofdm2gpo;		/* 2.4GHz OFDM power offset */
-	u32 ofdm5glpo;		/* 5.2GHz OFDM power offset */
-	u32 ofdm5gpo;		/* 5.3GHz OFDM power offset */
-	u32 ofdm5ghpo;		/* 5.8GHz OFDM power offset */
-	u32 boardflags;
-	u32 boardflags2;
-	u32 boardflags3;
-	/* TODO: Switch all drivers to new u32 fields and drop below ones */
-	u16 boardflags_lo;	/* Board flags (bits 0-15) */
-	u16 boardflags_hi;	/* Board flags (bits 16-31) */
-	u16 boardflags2_lo;	/* Board flags (bits 32-47) */
-	u16 boardflags2_hi;	/* Board flags (bits 48-63) */
-
-	struct ssb_sprom_core_pwr_info core_pwr_info[4];
-
-	/* Antenna gain values for up to 4 antennas
-	 * on each band. Values in dBm/4 (Q5.2). Negative gain means the
-	 * loss in the connectors is bigger than the gain. */
-	struct {
-		s8 a0, a1, a2, a3;
-	} antenna_gain;
-
-	struct {
-		struct {
-			u8 tssipos, extpa_gain, pdet_range, tr_iso, antswlut;
-		} ghz2;
-		struct {
-			u8 tssipos, extpa_gain, pdet_range, tr_iso, antswlut;
-		} ghz5;
-	} fem;
-
-	u16 mcs2gpo[8];
-	u16 mcs5gpo[8];
-	u16 mcs5glpo[8];
-	u16 mcs5ghpo[8];
-	u8 opo;
-
-	u8 rxgainerr2ga[3];
-	u8 rxgainerr5gla[3];
-	u8 rxgainerr5gma[3];
-	u8 rxgainerr5gha[3];
-	u8 rxgainerr5gua[3];
-
-	u8 noiselvl2ga[3];
-	u8 noiselvl5gla[3];
-	u8 noiselvl5gma[3];
-	u8 noiselvl5gha[3];
-	u8 noiselvl5gua[3];
-
-	u8 regrev;
-	u8 txchain;
-	u8 rxchain;
-	u8 antswitch;
-	u16 cddpo;
-	u16 stbcpo;
-	u16 bw40po;
-	u16 bwduppo;
-
-	u8 tempthresh;
-	u8 tempoffset;
-	u16 rawtempsense;
-	u8 measpower;
-	u8 tempsense_slope;
-	u8 tempcorrx;
-	u8 tempsense_option;
-	u8 freqoffset_corr;
-	u8 iqcal_swp_dis;
-	u8 hw_iqcal_en;
-	u8 elna2g;
-	u8 elna5g;
-	u8 phycal_tempdelta;
-	u8 temps_period;
-	u8 temps_hysteresis;
-	u8 measpower1;
-	u8 measpower2;
-	u8 pcieingress_war;
-
-	/* power per rate from sromrev 9 */
-	u16 cckbw202gpo;
-	u16 cckbw20ul2gpo;
-	u32 legofdmbw202gpo;
-	u32 legofdmbw20ul2gpo;
-	u32 legofdmbw205glpo;
-	u32 legofdmbw20ul5glpo;
-	u32 legofdmbw205gmpo;
-	u32 legofdmbw20ul5gmpo;
-	u32 legofdmbw205ghpo;
-	u32 legofdmbw20ul5ghpo;
-	u32 mcsbw202gpo;
-	u32 mcsbw20ul2gpo;
-	u32 mcsbw402gpo;
-	u32 mcsbw205glpo;
-	u32 mcsbw20ul5glpo;
-	u32 mcsbw405glpo;
-	u32 mcsbw205gmpo;
-	u32 mcsbw20ul5gmpo;
-	u32 mcsbw405gmpo;
-	u32 mcsbw205ghpo;
-	u32 mcsbw20ul5ghpo;
-	u32 mcsbw405ghpo;
-	u16 mcs32po;
-	u16 legofdm40duppo;
-	u8 sar2g;
-	u8 sar5g;
-};
-
-/* Information about the PCB the circuitry is soldered on. */
-struct ssb_boardinfo {
-	u16 vendor;
-	u16 type;
-};
-
-
-struct ssb_device;
-/* Lowlevel read/write operations on the device MMIO.
- * Internal, don't use that outside of ssb. */
-struct ssb_bus_ops {
-	u8 (*read8)(struct ssb_device *dev, u16 offset);
-	u16 (*read16)(struct ssb_device *dev, u16 offset);
-	u32 (*read32)(struct ssb_device *dev, u16 offset);
-	void (*write8)(struct ssb_device *dev, u16 offset, u8 value);
-	void (*write16)(struct ssb_device *dev, u16 offset, u16 value);
-	void (*write32)(struct ssb_device *dev, u16 offset, u32 value);
-#ifdef CPTCFG_SSB_BLOCKIO
-	void (*block_read)(struct ssb_device *dev, void *buffer,
-			   size_t count, u16 offset, u8 reg_width);
-	void (*block_write)(struct ssb_device *dev, const void *buffer,
-			    size_t count, u16 offset, u8 reg_width);
-#endif
-};
-
-
-/* Core-ID values. */
-#define SSB_DEV_CHIPCOMMON	0x800
-#define SSB_DEV_ILINE20		0x801
-#define SSB_DEV_SDRAM		0x803
-#define SSB_DEV_PCI		0x804
-#define SSB_DEV_MIPS		0x805
-#define SSB_DEV_ETHERNET	0x806
-#define SSB_DEV_V90		0x807
-#define SSB_DEV_USB11_HOSTDEV	0x808
-#define SSB_DEV_ADSL		0x809
-#define SSB_DEV_ILINE100	0x80A
-#define SSB_DEV_IPSEC		0x80B
-#define SSB_DEV_PCMCIA		0x80D
-#define SSB_DEV_INTERNAL_MEM	0x80E
-#define SSB_DEV_MEMC_SDRAM	0x80F
-#define SSB_DEV_EXTIF		0x811
-#define SSB_DEV_80211		0x812
-#define SSB_DEV_MIPS_3302	0x816
-#define SSB_DEV_USB11_HOST	0x817
-#define SSB_DEV_USB11_DEV	0x818
-#define SSB_DEV_USB20_HOST	0x819
-#define SSB_DEV_USB20_DEV	0x81A
-#define SSB_DEV_SDIO_HOST	0x81B
-#define SSB_DEV_ROBOSWITCH	0x81C
-#define SSB_DEV_PARA_ATA	0x81D
-#define SSB_DEV_SATA_XORDMA	0x81E
-#define SSB_DEV_ETHERNET_GBIT	0x81F
-#define SSB_DEV_PCIE		0x820
-#define SSB_DEV_MIMO_PHY	0x821
-#define SSB_DEV_SRAM_CTRLR	0x822
-#define SSB_DEV_MINI_MACPHY	0x823
-#define SSB_DEV_ARM_1176	0x824
-#define SSB_DEV_ARM_7TDMI	0x825
-#define SSB_DEV_ARM_CM3		0x82A
-
-/* Vendor-ID values */
-#define SSB_VENDOR_BROADCOM	0x4243
-
-/* Some kernel subsystems poke with dev->drvdata, so we must use the
- * following ugly workaround to get from struct device to struct ssb_device */
-struct __ssb_dev_wrapper {
-	struct device dev;
-	struct ssb_device *sdev;
-};
-
-struct ssb_device {
-	/* Having a copy of the ops pointer in each dev struct
-	 * is an optimization. */
-	const struct ssb_bus_ops *ops;
-
-	struct device *dev, *dma_dev;
-
-	struct ssb_bus *bus;
-	struct ssb_device_id id;
-
-	u8 core_index;
-	unsigned int irq;
-
-	/* Internal-only stuff follows. */
-	void *drvdata;		/* Per-device data */
-	void *devtypedata;	/* Per-devicetype (eg 802.11) data */
-};
-
-/* Go from struct device to struct ssb_device. */
-static inline
-struct ssb_device * dev_to_ssb_dev(struct device *dev)
-{
-	struct __ssb_dev_wrapper *wrap;
-	wrap = container_of(dev, struct __ssb_dev_wrapper, dev);
-	return wrap->sdev;
-}
-
-/* Device specific user data */
-static inline
-void ssb_set_drvdata(struct ssb_device *dev, void *data)
-{
-	dev->drvdata = data;
-}
-static inline
-void * ssb_get_drvdata(struct ssb_device *dev)
-{
-	return dev->drvdata;
-}
-
-/* Devicetype specific user data. This is per device-type (not per device) */
-void ssb_set_devtypedata(struct ssb_device *dev, void *data);
-static inline
-void * ssb_get_devtypedata(struct ssb_device *dev)
-{
-	return dev->devtypedata;
-}
-
-
-struct ssb_driver {
-	const char *name;
-	const struct ssb_device_id *id_table;
-
-	int (*probe)(struct ssb_device *dev, const struct ssb_device_id *id);
-	void (*remove)(struct ssb_device *dev);
-	int (*suspend)(struct ssb_device *dev, pm_message_t state);
-	int (*resume)(struct ssb_device *dev);
-	void (*shutdown)(struct ssb_device *dev);
-
-	struct device_driver drv;
-};
-#define drv_to_ssb_drv(_drv) container_of(_drv, struct ssb_driver, drv)
-
-extern int __ssb_driver_register(struct ssb_driver *drv, struct module *owner);
-#define ssb_driver_register(drv) \
-	__ssb_driver_register(drv, THIS_MODULE)
-
-extern void ssb_driver_unregister(struct ssb_driver *drv);
-
-
-
-
-enum ssb_bustype {
-	SSB_BUSTYPE_SSB,	/* This SSB bus is the system bus */
-	SSB_BUSTYPE_PCI,	/* SSB is connected to PCI bus */
-	SSB_BUSTYPE_PCMCIA,	/* SSB is connected to PCMCIA bus */
-	SSB_BUSTYPE_SDIO,	/* SSB is connected to SDIO bus */
-};
-
-/* board_vendor */
-#define SSB_BOARDVENDOR_BCM	0x14E4	/* Broadcom */
-#define SSB_BOARDVENDOR_DELL	0x1028	/* Dell */
-#define SSB_BOARDVENDOR_HP	0x0E11	/* HP */
-/* board_type */
-#define SSB_BOARD_BCM94301CB	0x0406
-#define SSB_BOARD_BCM94301MP	0x0407
-#define SSB_BOARD_BU4309	0x040A
-#define SSB_BOARD_BCM94309CB	0x040B
-#define SSB_BOARD_BCM4309MP	0x040C
-#define SSB_BOARD_BU4306	0x0416
-#define SSB_BOARD_BCM94306MP	0x0418
-#define SSB_BOARD_BCM4309G	0x0421
-#define SSB_BOARD_BCM4306CB	0x0417
-#define SSB_BOARD_BCM94306PC	0x0425	/* pcmcia 3.3v 4306 card */
-#define SSB_BOARD_BCM94306CBSG	0x042B	/* with SiGe PA */
-#define SSB_BOARD_PCSG94306	0x042D	/* with SiGe PA */
-#define SSB_BOARD_BU4704SD	0x042E	/* with sdram */
-#define SSB_BOARD_BCM94704AGR	0x042F	/* dual 11a/11g Router */
-#define SSB_BOARD_BCM94308MP	0x0430	/* 11a-only minipci */
-#define SSB_BOARD_BU4318	0x0447
-#define SSB_BOARD_CB4318	0x0448
-#define SSB_BOARD_MPG4318	0x0449
-#define SSB_BOARD_MP4318	0x044A
-#define SSB_BOARD_SD4318	0x044B
-#define SSB_BOARD_BCM94306P	0x044C	/* with SiGe */
-#define SSB_BOARD_BCM94303MP	0x044E
-#define SSB_BOARD_BCM94306MPM	0x0450
-#define SSB_BOARD_BCM94306MPL	0x0453
-#define SSB_BOARD_PC4303	0x0454	/* pcmcia */
-#define SSB_BOARD_BCM94306MPLNA	0x0457
-#define SSB_BOARD_BCM94306MPH	0x045B
-#define SSB_BOARD_BCM94306PCIV	0x045C
-#define SSB_BOARD_BCM94318MPGH	0x0463
-#define SSB_BOARD_BU4311	0x0464
-#define SSB_BOARD_BCM94311MC	0x0465
-#define SSB_BOARD_BCM94311MCAG	0x0466
-/* 4321 boards */
-#define SSB_BOARD_BU4321	0x046B
-#define SSB_BOARD_BU4321E	0x047C
-#define SSB_BOARD_MP4321	0x046C
-#define SSB_BOARD_CB2_4321	0x046D
-#define SSB_BOARD_CB2_4321_AG	0x0066
-#define SSB_BOARD_MC4321	0x046E
-/* 4325 boards */
-#define SSB_BOARD_BCM94325DEVBU	0x0490
-#define SSB_BOARD_BCM94325BGABU	0x0491
-#define SSB_BOARD_BCM94325SDGWB	0x0492
-#define SSB_BOARD_BCM94325SDGMDL	0x04AA
-#define SSB_BOARD_BCM94325SDGMDL2	0x04C6
-#define SSB_BOARD_BCM94325SDGMDL3	0x04C9
-#define SSB_BOARD_BCM94325SDABGWBA	0x04E1
-/* 4322 boards */
-#define SSB_BOARD_BCM94322MC	0x04A4
-#define SSB_BOARD_BCM94322USB	0x04A8	/* dualband */
-#define SSB_BOARD_BCM94322HM	0x04B0
-#define SSB_BOARD_BCM94322USB2D	0x04Bf	/* single band discrete front end */
-/* 4312 boards */
-#define SSB_BOARD_BU4312	0x048A
-#define SSB_BOARD_BCM4312MCGSG	0x04B5
-/* chip_package */
-#define SSB_CHIPPACK_BCM4712S	1	/* Small 200pin 4712 */
-#define SSB_CHIPPACK_BCM4712M	2	/* Medium 225pin 4712 */
-#define SSB_CHIPPACK_BCM4712L	0	/* Large 340pin 4712 */
-
-#include <linux/ssb/ssb_driver_chipcommon.h>
-#include <linux/ssb/ssb_driver_mips.h>
-#include <linux/ssb/ssb_driver_extif.h>
-#include <linux/ssb/ssb_driver_pci.h>
-
-struct ssb_bus {
-	/* The MMIO area. */
-	void __iomem *mmio;
-
-	const struct ssb_bus_ops *ops;
-
-	/* The core currently mapped into the MMIO window.
-	 * Not valid on all host-buses. So don't use outside of SSB. */
-	struct ssb_device *mapped_device;
-	union {
-		/* Currently mapped PCMCIA segment. (bustype == SSB_BUSTYPE_PCMCIA only) */
-		u8 mapped_pcmcia_seg;
-		/* Current SSB base address window for SDIO. */
-		u32 sdio_sbaddr;
-	};
-	/* Lock for core and segment switching.
-	 * On PCMCIA-host busses this is used to protect the whole MMIO access. */
-	spinlock_t bar_lock;
-
-	/* The host-bus this backplane is running on. */
-	enum ssb_bustype bustype;
-	/* Pointers to the host-bus. Check bustype before using any of these pointers. */
-	union {
-		/* Pointer to the PCI bus (only valid if bustype == SSB_BUSTYPE_PCI). */
-		struct pci_dev *host_pci;
-		/* Pointer to the PCMCIA device (only if bustype == SSB_BUSTYPE_PCMCIA). */
-		struct pcmcia_device *host_pcmcia;
-		/* Pointer to the SDIO device (only if bustype == SSB_BUSTYPE_SDIO). */
-		struct sdio_func *host_sdio;
-	};
-
-	/* See enum ssb_quirks */
-	unsigned int quirks;
-
-#ifdef CPTCFG_SSB_SPROM
-	/* Mutex to protect the SPROM writing. */
-	struct mutex sprom_mutex;
-#endif
-
-	/* ID information about the Chip. */
-	u16 chip_id;
-	u8 chip_rev;
-	u16 sprom_offset;
-	u16 sprom_size;		/* number of words in sprom */
-	u8 chip_package;
-
-	/* List of devices (cores) on the backplane. */
-	struct ssb_device devices[SSB_MAX_NR_CORES];
-	u8 nr_devices;
-
-	/* Software ID number for this bus. */
-	unsigned int busnumber;
-
-	/* The ChipCommon device (if available). */
-	struct ssb_chipcommon chipco;
-	/* The PCI-core device (if available). */
-	struct ssb_pcicore pcicore;
-	/* The MIPS-core device (if available). */
-	struct ssb_mipscore mipscore;
-	/* The EXTif-core device (if available). */
-	struct ssb_extif extif;
-
-	/* The following structure elements are not available in early
-	 * SSB initialization. Though, they are available for regular
-	 * registered drivers at any stage. So be careful when
-	 * using them in the ssb core code. */
-
-	/* ID information about the PCB. */
-	struct ssb_boardinfo boardinfo;
-	/* Contents of the SPROM. */
-	struct ssb_sprom sprom;
-	/* If the board has a cardbus slot, this is set to true. */
-	bool has_cardbus_slot;
-
-#ifdef CPTCFG_SSB_EMBEDDED
-	/* Lock for GPIO register access. */
-	spinlock_t gpio_lock;
-	struct platform_device *watchdog;
-#endif /* EMBEDDED */
-#ifdef CPTCFG_SSB_DRIVER_GPIO
-	struct gpio_chip gpio;
-	struct irq_domain *irq_domain;
-#endif /* DRIVER_GPIO */
-
-	/* Internal-only stuff follows. Do not touch. */
-	struct list_head list;
-	/* Is the bus already powered up? */
-	bool powered_up;
-	int power_warn_count;
-};
-
-enum ssb_quirks {
-	/* SDIO connected card requires performing a read after writing a 32-bit value */
-	SSB_QUIRK_SDIO_READ_AFTER_WRITE32	= (1 << 0),
-};
-
-/* The initialization-invariants. */
-struct ssb_init_invariants {
-	/* Versioning information about the PCB. */
-	struct ssb_boardinfo boardinfo;
-	/* The SPROM information. That's either stored in an
-	 * EEPROM or NVRAM on the board. */
-	struct ssb_sprom sprom;
-	/* If the board has a cardbus slot, this is set to true. */
-	bool has_cardbus_slot;
-};
-/* Type of function to fetch the invariants. */
-typedef int (*ssb_invariants_func_t)(struct ssb_bus *bus,
-				     struct ssb_init_invariants *iv);
-
-/* Register SoC bus. */
-extern int ssb_bus_host_soc_register(struct ssb_bus *bus,
-				     unsigned long baseaddr);
-#ifdef CPTCFG_SSB_PCIHOST
-extern int ssb_bus_pcibus_register(struct ssb_bus *bus,
-				   struct pci_dev *host_pci);
-#endif /* CPTCFG_SSB_PCIHOST */
-#ifdef CPTCFG_SSB_PCMCIAHOST
-extern int ssb_bus_pcmciabus_register(struct ssb_bus *bus,
-				      struct pcmcia_device *pcmcia_dev,
-				      unsigned long baseaddr);
-#endif /* CPTCFG_SSB_PCMCIAHOST */
-#ifdef CPTCFG_SSB_SDIOHOST
-extern int ssb_bus_sdiobus_register(struct ssb_bus *bus,
-				    struct sdio_func *sdio_func,
-				    unsigned int quirks);
-#endif /* CPTCFG_SSB_SDIOHOST */
-
-
-extern void ssb_bus_unregister(struct ssb_bus *bus);
-
-/* Does the device have an SPROM? */
-extern bool ssb_is_sprom_available(struct ssb_bus *bus);
-
-/* Set a fallback SPROM.
- * See kdoc at the function definition for complete documentation. */
-extern int ssb_arch_register_fallback_sprom(
-		int (*sprom_callback)(struct ssb_bus *bus,
-		struct ssb_sprom *out));
-
-/* Suspend a SSB bus.
- * Call this from the parent bus suspend routine. */
-extern int ssb_bus_suspend(struct ssb_bus *bus);
-/* Resume a SSB bus.
- * Call this from the parent bus resume routine. */
-extern int ssb_bus_resume(struct ssb_bus *bus);
-
-extern u32 ssb_clockspeed(struct ssb_bus *bus);
-
-/* Is the device enabled in hardware? */
-int ssb_device_is_enabled(struct ssb_device *dev);
-/* Enable a device and pass device-specific SSB_TMSLOW flags.
- * If no device-specific flags are available, use 0. */
-void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags);
-/* Disable a device in hardware and pass SSB_TMSLOW flags (if any). */
-void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags);
-
-
-/* Device MMIO register read/write functions. */
-static inline u8 ssb_read8(struct ssb_device *dev, u16 offset)
-{
-	return dev->ops->read8(dev, offset);
-}
-static inline u16 ssb_read16(struct ssb_device *dev, u16 offset)
-{
-	return dev->ops->read16(dev, offset);
-}
-static inline u32 ssb_read32(struct ssb_device *dev, u16 offset)
-{
-	return dev->ops->read32(dev, offset);
-}
-static inline void ssb_write8(struct ssb_device *dev, u16 offset, u8 value)
-{
-	dev->ops->write8(dev, offset, value);
-}
-static inline void ssb_write16(struct ssb_device *dev, u16 offset, u16 value)
-{
-	dev->ops->write16(dev, offset, value);
-}
-static inline void ssb_write32(struct ssb_device *dev, u16 offset, u32 value)
-{
-	dev->ops->write32(dev, offset, value);
-}
-#ifdef CPTCFG_SSB_BLOCKIO
-static inline void ssb_block_read(struct ssb_device *dev, void *buffer,
-				  size_t count, u16 offset, u8 reg_width)
-{
-	dev->ops->block_read(dev, buffer, count, offset, reg_width);
-}
-
-static inline void ssb_block_write(struct ssb_device *dev, const void *buffer,
-				   size_t count, u16 offset, u8 reg_width)
-{
-	dev->ops->block_write(dev, buffer, count, offset, reg_width);
-}
-#endif /* CPTCFG_SSB_BLOCKIO */
-
-
-/* The SSB DMA API. Use this API for any DMA operation on the device.
- * This API basically is a wrapper that calls the correct DMA API for
- * the host device type the SSB device is attached to. */
-
-/* Translation (routing) bits that need to be ORed to DMA
- * addresses before they are given to a device. */
-extern u32 ssb_dma_translation(struct ssb_device *dev);
-#define SSB_DMA_TRANSLATION_MASK	0xC0000000
-#define SSB_DMA_TRANSLATION_SHIFT	30
-
-static inline void __cold __ssb_dma_not_implemented(struct ssb_device *dev)
-{
-#ifdef CONFIG_SSB_DEBUG
-	printk(KERN_ERR "SSB: BUG! Calling DMA API for "
-	       "unsupported bustype %d\n", dev->bus->bustype);
-#endif /* DEBUG */
-}
-
-#ifdef CPTCFG_SSB_PCIHOST
-/* PCI-host wrapper driver */
-extern int ssb_pcihost_register(struct pci_driver *driver);
-static inline void ssb_pcihost_unregister(struct pci_driver *driver)
-{
-	pci_unregister_driver(driver);
-}
-
-static inline
-void ssb_pcihost_set_power_state(struct ssb_device *sdev, pci_power_t state)
-{
-	if (sdev->bus->bustype == SSB_BUSTYPE_PCI)
-		pci_set_power_state(sdev->bus->host_pci, state);
-}
-#else
-static inline void ssb_pcihost_unregister(struct pci_driver *driver)
-{
-}
-
-static inline
-void ssb_pcihost_set_power_state(struct ssb_device *sdev, pci_power_t state)
-{
-}
-#endif /* CPTCFG_SSB_PCIHOST */
-
-
-/* If a driver is shutdown or suspended, call this to signal
- * that the bus may be completely powered down. SSB will decide,
- * if it's really time to power down the bus, based on if there
- * are other devices that want to run. */
-extern int ssb_bus_may_powerdown(struct ssb_bus *bus);
-/* Before initializing and enabling a device, call this to power-up the bus.
- * If you want to allow use of dynamic-power-control, pass the flag.
- * Otherwise static always-on powercontrol will be used. */
-extern int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl);
-
-extern void ssb_commit_settings(struct ssb_bus *bus);
-
-/* Various helper functions */
-extern u32 ssb_admatch_base(u32 adm);
-extern u32 ssb_admatch_size(u32 adm);
-
-/* PCI device mapping and fixup routines.
- * Called from the architecture pcibios init code.
- * These are only available on SSB_EMBEDDED configurations. */
-#ifdef CPTCFG_SSB_EMBEDDED
-int ssb_pcibios_plat_dev_init(struct pci_dev *dev);
-int ssb_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin);
-#endif /* CPTCFG_SSB_EMBEDDED */
-
-#endif /* LINUX_SSB_H_ */
diff --git a/include/linux/ssb/ssb_driver_chipcommon.h b/include/linux/ssb/ssb_driver_chipcommon.h
deleted file mode 100644
index 9336d12..0000000
--- a/include/linux/ssb/ssb_driver_chipcommon.h
+++ /dev/null
@@ -1,673 +0,0 @@
-#ifndef LINUX_SSB_CHIPCO_H_
-#define LINUX_SSB_CHIPCO_H_
-
-/* SonicsSiliconBackplane CHIPCOMMON core hardware definitions
- *
- * The chipcommon core provides chip identification, SB control,
- * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
- * gpio interface, extbus, and support for serial and parallel flashes.
- *
- * Copyright 2005, Broadcom Corporation
- * Copyright 2006, Michael Buesch <m@bues.ch>
- *
- * Licensed under the GPL version 2. See COPYING for details.
- */
-
-/** ChipCommon core registers. **/
-
-#define SSB_CHIPCO_CHIPID		0x0000
-#define  SSB_CHIPCO_IDMASK		0x0000FFFF
-#define  SSB_CHIPCO_REVMASK		0x000F0000
-#define  SSB_CHIPCO_REVSHIFT		16
-#define  SSB_CHIPCO_PACKMASK		0x00F00000
-#define  SSB_CHIPCO_PACKSHIFT		20
-#define  SSB_CHIPCO_NRCORESMASK		0x0F000000
-#define  SSB_CHIPCO_NRCORESSHIFT	24
-#define SSB_CHIPCO_CAP	 		0x0004		/* Capabilities */
-#define  SSB_CHIPCO_CAP_NRUART		0x00000003	/* # of UARTs */
-#define  SSB_CHIPCO_CAP_MIPSEB		0x00000004	/* MIPS in BigEndian Mode */
-#define  SSB_CHIPCO_CAP_UARTCLK		0x00000018	/* UART clock select */
-#define   SSB_CHIPCO_CAP_UARTCLK_INT	0x00000008	/* UARTs are driven by internal divided clock */
-#define  SSB_CHIPCO_CAP_UARTGPIO	0x00000020	/* UARTs on GPIO 15-12 */
-#define  SSB_CHIPCO_CAP_EXTBUS		0x000000C0	/* External buses present */
-#define  SSB_CHIPCO_CAP_FLASHT		0x00000700	/* Flash Type */
-#define   SSB_CHIPCO_FLASHT_NONE	0x00000000	/* No flash */
-#define   SSB_CHIPCO_FLASHT_STSER	0x00000100	/* ST serial flash */
-#define   SSB_CHIPCO_FLASHT_ATSER	0x00000200	/* Atmel serial flash */
-#define	  SSB_CHIPCO_FLASHT_PARA	0x00000700	/* Parallel flash */
-#define  SSB_CHIPCO_CAP_PLLT		0x00038000	/* PLL Type */
-#define   SSB_PLLTYPE_NONE		0x00000000
-#define   SSB_PLLTYPE_1			0x00010000	/* 48Mhz base, 3 dividers */
-#define   SSB_PLLTYPE_2			0x00020000	/* 48Mhz, 4 dividers */
-#define   SSB_PLLTYPE_3			0x00030000	/* 25Mhz, 2 dividers */
-#define   SSB_PLLTYPE_4			0x00008000	/* 48Mhz, 4 dividers */
-#define   SSB_PLLTYPE_5			0x00018000	/* 25Mhz, 4 dividers */
-#define   SSB_PLLTYPE_6			0x00028000	/* 100/200 or 120/240 only */
-#define   SSB_PLLTYPE_7			0x00038000	/* 25Mhz, 4 dividers */
-#define  SSB_CHIPCO_CAP_PCTL		0x00040000	/* Power Control */
-#define  SSB_CHIPCO_CAP_OTPS		0x00380000	/* OTP size */
-#define  SSB_CHIPCO_CAP_OTPS_SHIFT	19
-#define  SSB_CHIPCO_CAP_OTPS_BASE	5
-#define  SSB_CHIPCO_CAP_JTAGM		0x00400000	/* JTAG master present */
-#define  SSB_CHIPCO_CAP_BROM		0x00800000	/* Internal boot ROM active */
-#define  SSB_CHIPCO_CAP_64BIT		0x08000000	/* 64-bit Backplane */
-#define  SSB_CHIPCO_CAP_PMU		0x10000000	/* PMU available (rev >= 20) */
-#define  SSB_CHIPCO_CAP_ECI		0x20000000	/* ECI available (rev >= 20) */
-#define  SSB_CHIPCO_CAP_SPROM		0x40000000	/* SPROM present */
-#define SSB_CHIPCO_CORECTL		0x0008
-#define  SSB_CHIPCO_CORECTL_UARTCLK0	0x00000001	/* Drive UART with internal clock */
-#define	 SSB_CHIPCO_CORECTL_SE		0x00000002	/* sync clk out enable (corerev >= 3) */
-#define  SSB_CHIPCO_CORECTL_UARTCLKEN	0x00000008	/* UART clock enable (rev >= 21) */
-#define SSB_CHIPCO_BIST			0x000C
-#define SSB_CHIPCO_OTPS			0x0010		/* OTP status */
-#define	 SSB_CHIPCO_OTPS_PROGFAIL	0x80000000
-#define	 SSB_CHIPCO_OTPS_PROTECT	0x00000007
-#define	 SSB_CHIPCO_OTPS_HW_PROTECT	0x00000001
-#define	 SSB_CHIPCO_OTPS_SW_PROTECT	0x00000002
-#define	 SSB_CHIPCO_OTPS_CID_PROTECT	0x00000004
-#define SSB_CHIPCO_OTPC			0x0014		/* OTP control */
-#define	 SSB_CHIPCO_OTPC_RECWAIT	0xFF000000
-#define	 SSB_CHIPCO_OTPC_PROGWAIT	0x00FFFF00
-#define	 SSB_CHIPCO_OTPC_PRW_SHIFT	8
-#define	 SSB_CHIPCO_OTPC_MAXFAIL	0x00000038
-#define	 SSB_CHIPCO_OTPC_VSEL		0x00000006
-#define	 SSB_CHIPCO_OTPC_SELVL		0x00000001
-#define SSB_CHIPCO_OTPP			0x0018		/* OTP prog */
-#define	 SSB_CHIPCO_OTPP_COL		0x000000FF
-#define	 SSB_CHIPCO_OTPP_ROW		0x0000FF00
-#define	 SSB_CHIPCO_OTPP_ROW_SHIFT	8
-#define	 SSB_CHIPCO_OTPP_READERR	0x10000000
-#define	 SSB_CHIPCO_OTPP_VALUE		0x20000000
-#define	 SSB_CHIPCO_OTPP_READ		0x40000000
-#define	 SSB_CHIPCO_OTPP_START		0x80000000
-#define	 SSB_CHIPCO_OTPP_BUSY		0x80000000
-#define SSB_CHIPCO_IRQSTAT		0x0020
-#define SSB_CHIPCO_IRQMASK		0x0024
-#define	 SSB_CHIPCO_IRQ_GPIO		0x00000001	/* gpio intr */
-#define	 SSB_CHIPCO_IRQ_EXT		0x00000002	/* ro: ext intr pin (corerev >= 3) */
-#define	 SSB_CHIPCO_IRQ_WDRESET		0x80000000	/* watchdog reset occurred */
-#define SSB_CHIPCO_CHIPCTL		0x0028		/* Rev >= 11 only */
-#define SSB_CHIPCO_CHIPSTAT		0x002C		/* Rev >= 11 only */
-#define SSB_CHIPCO_JCMD			0x0030		/* Rev >= 10 only */
-#define  SSB_CHIPCO_JCMD_START		0x80000000
-#define  SSB_CHIPCO_JCMD_BUSY		0x80000000
-#define  SSB_CHIPCO_JCMD_PAUSE		0x40000000
-#define  SSB_CHIPCO_JCMD0_ACC_MASK	0x0000F000
-#define  SSB_CHIPCO_JCMD0_ACC_IRDR	0x00000000
-#define  SSB_CHIPCO_JCMD0_ACC_DR	0x00001000
-#define  SSB_CHIPCO_JCMD0_ACC_IR	0x00002000
-#define  SSB_CHIPCO_JCMD0_ACC_RESET	0x00003000
-#define  SSB_CHIPCO_JCMD0_ACC_IRPDR	0x00004000
-#define  SSB_CHIPCO_JCMD0_ACC_PDR	0x00005000
-#define  SSB_CHIPCO_JCMD0_IRW_MASK	0x00000F00
-#define  SSB_CHIPCO_JCMD_ACC_MASK	0x000F0000	/* Changes for corerev 11 */
-#define  SSB_CHIPCO_JCMD_ACC_IRDR	0x00000000
-#define  SSB_CHIPCO_JCMD_ACC_DR		0x00010000
-#define  SSB_CHIPCO_JCMD_ACC_IR		0x00020000
-#define  SSB_CHIPCO_JCMD_ACC_RESET	0x00030000
-#define  SSB_CHIPCO_JCMD_ACC_IRPDR	0x00040000
-#define  SSB_CHIPCO_JCMD_ACC_PDR	0x00050000
-#define  SSB_CHIPCO_JCMD_IRW_MASK	0x00001F00
-#define  SSB_CHIPCO_JCMD_IRW_SHIFT	8
-#define  SSB_CHIPCO_JCMD_DRW_MASK	0x0000003F
-#define SSB_CHIPCO_JIR			0x0034		/* Rev >= 10 only */
-#define SSB_CHIPCO_JDR			0x0038		/* Rev >= 10 only */
-#define SSB_CHIPCO_JCTL			0x003C		/* Rev >= 10 only */
-#define  SSB_CHIPCO_JCTL_FORCE_CLK	4		/* Force clock */
-#define  SSB_CHIPCO_JCTL_EXT_EN		2		/* Enable external targets */
-#define  SSB_CHIPCO_JCTL_EN		1		/* Enable Jtag master */
-#define SSB_CHIPCO_FLASHCTL		0x0040
-#define  SSB_CHIPCO_FLASHCTL_START	0x80000000
-#define  SSB_CHIPCO_FLASHCTL_BUSY	SSB_CHIPCO_FLASHCTL_START
-#define SSB_CHIPCO_FLASHADDR		0x0044
-#define SSB_CHIPCO_FLASHDATA		0x0048
-#define SSB_CHIPCO_BCAST_ADDR		0x0050
-#define SSB_CHIPCO_BCAST_DATA		0x0054
-#define SSB_CHIPCO_GPIOPULLUP		0x0058		/* Rev >= 20 only */
-#define SSB_CHIPCO_GPIOPULLDOWN		0x005C		/* Rev >= 20 only */
-#define SSB_CHIPCO_GPIOIN		0x0060
-#define SSB_CHIPCO_GPIOOUT		0x0064
-#define SSB_CHIPCO_GPIOOUTEN		0x0068
-#define SSB_CHIPCO_GPIOCTL		0x006C
-#define SSB_CHIPCO_GPIOPOL		0x0070
-#define SSB_CHIPCO_GPIOIRQ		0x0074
-#define SSB_CHIPCO_WATCHDOG		0x0080
-#define SSB_CHIPCO_GPIOTIMER		0x0088		/* LED powersave (corerev >= 16) */
-#define  SSB_CHIPCO_GPIOTIMER_OFFTIME	0x0000FFFF
-#define  SSB_CHIPCO_GPIOTIMER_OFFTIME_SHIFT	0
-#define  SSB_CHIPCO_GPIOTIMER_ONTIME	0xFFFF0000
-#define  SSB_CHIPCO_GPIOTIMER_ONTIME_SHIFT	16
-#define SSB_CHIPCO_GPIOTOUTM		0x008C		/* LED powersave (corerev >= 16) */
-#define SSB_CHIPCO_CLOCK_N		0x0090
-#define SSB_CHIPCO_CLOCK_SB		0x0094
-#define SSB_CHIPCO_CLOCK_PCI		0x0098
-#define SSB_CHIPCO_CLOCK_M2		0x009C
-#define SSB_CHIPCO_CLOCK_MIPS		0x00A0
-#define SSB_CHIPCO_CLKDIV		0x00A4		/* Rev >= 3 only */
-#define	 SSB_CHIPCO_CLKDIV_SFLASH	0x0F000000
-#define	 SSB_CHIPCO_CLKDIV_SFLASH_SHIFT	24
-#define	 SSB_CHIPCO_CLKDIV_OTP		0x000F0000
-#define	 SSB_CHIPCO_CLKDIV_OTP_SHIFT	16
-#define	 SSB_CHIPCO_CLKDIV_JTAG		0x00000F00
-#define	 SSB_CHIPCO_CLKDIV_JTAG_SHIFT	8
-#define	 SSB_CHIPCO_CLKDIV_UART		0x000000FF
-#define SSB_CHIPCO_PLLONDELAY		0x00B0		/* Rev >= 4 only */
-#define SSB_CHIPCO_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
-#define SSB_CHIPCO_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
-#define  SSB_CHIPCO_SLOWCLKCTL_SRC	0x00000007	/* slow clock source mask */
-#define	  SSB_CHIPCO_SLOWCLKCTL_SRC_LPO		0x00000000	/* source of slow clock is LPO */
-#define   SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL	0x00000001	/* source of slow clock is crystal */
-#define	  SSB_CHIPCO_SLOECLKCTL_SRC_PCI		0x00000002	/* source of slow clock is PCI */
-#define  SSB_CHIPCO_SLOWCLKCTL_LPOFREQ	0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
-#define  SSB_CHIPCO_SLOWCLKCTL_LPOPD	0x00000400	/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
-#define  SSB_CHIPCO_SLOWCLKCTL_FSLOW	0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
-#define  SSB_CHIPCO_SLOWCLKCTL_IPLL	0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
-#define  SSB_CHIPCO_SLOWCLKCTL_ENXTAL	0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
-#define  SSB_CHIPCO_SLOWCLKCTL_XTALPU	0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
-#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV	0xFFFF0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
-#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV_SHIFT	16
-#define SSB_CHIPCO_SYSCLKCTL		0x00C0		/* Rev >= 3 only */
-#define	 SSB_CHIPCO_SYSCLKCTL_IDLPEN	0x00000001	/* ILPen: Enable Idle Low Power */
-#define	 SSB_CHIPCO_SYSCLKCTL_ALPEN	0x00000002	/* ALPen: Enable Active Low Power */
-#define	 SSB_CHIPCO_SYSCLKCTL_PLLEN	0x00000004	/* ForcePLLOn */
-#define	 SSB_CHIPCO_SYSCLKCTL_FORCEALP	0x00000008	/* Force ALP (or HT if ALPen is not set */
-#define	 SSB_CHIPCO_SYSCLKCTL_FORCEHT	0x00000010	/* Force HT */
-#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV	0xFFFF0000	/* ClkDiv  (ILP = 1/(4+divisor)) */
-#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV_SHIFT	16
-#define SSB_CHIPCO_CLKSTSTR		0x00C4		/* Rev >= 3 only */
-#define SSB_CHIPCO_PCMCIA_CFG		0x0100
-#define SSB_CHIPCO_PCMCIA_MEMWAIT	0x0104
-#define SSB_CHIPCO_PCMCIA_ATTRWAIT	0x0108
-#define SSB_CHIPCO_PCMCIA_IOWAIT	0x010C
-#define SSB_CHIPCO_IDE_CFG		0x0110
-#define SSB_CHIPCO_IDE_MEMWAIT		0x0114
-#define SSB_CHIPCO_IDE_ATTRWAIT		0x0118
-#define SSB_CHIPCO_IDE_IOWAIT		0x011C
-#define SSB_CHIPCO_PROG_CFG		0x0120
-#define SSB_CHIPCO_PROG_WAITCNT		0x0124
-#define SSB_CHIPCO_FLASH_CFG		0x0128
-#define SSB_CHIPCO_FLASH_WAITCNT	0x012C
-#define SSB_CHIPCO_CLKCTLST		0x01E0 /* Clock control and status (rev >= 20) */
-#define  SSB_CHIPCO_CLKCTLST_FORCEALP	0x00000001 /* Force ALP request */
-#define  SSB_CHIPCO_CLKCTLST_FORCEHT	0x00000002 /* Force HT request */
-#define  SSB_CHIPCO_CLKCTLST_FORCEILP	0x00000004 /* Force ILP request */
-#define  SSB_CHIPCO_CLKCTLST_HAVEALPREQ	0x00000008 /* ALP available request */
-#define  SSB_CHIPCO_CLKCTLST_HAVEHTREQ	0x00000010 /* HT available request */
-#define  SSB_CHIPCO_CLKCTLST_HWCROFF	0x00000020 /* Force HW clock request off */
-#define  SSB_CHIPCO_CLKCTLST_HAVEALP	0x00010000 /* ALP available */
-#define  SSB_CHIPCO_CLKCTLST_HAVEHT	0x00020000 /* HT available */
-#define  SSB_CHIPCO_CLKCTLST_4328A0_HAVEHT	0x00010000 /* 4328a0 has reversed bits */
-#define  SSB_CHIPCO_CLKCTLST_4328A0_HAVEALP	0x00020000 /* 4328a0 has reversed bits */
-#define SSB_CHIPCO_HW_WORKAROUND	0x01E4 /* Hardware workaround (rev >= 20) */
-#define SSB_CHIPCO_UART0_DATA		0x0300
-#define SSB_CHIPCO_UART0_IMR		0x0304
-#define SSB_CHIPCO_UART0_FCR		0x0308
-#define SSB_CHIPCO_UART0_LCR		0x030C
-#define SSB_CHIPCO_UART0_MCR		0x0310
-#define SSB_CHIPCO_UART0_LSR		0x0314
-#define SSB_CHIPCO_UART0_MSR		0x0318
-#define SSB_CHIPCO_UART0_SCRATCH	0x031C
-#define SSB_CHIPCO_UART1_DATA		0x0400
-#define SSB_CHIPCO_UART1_IMR		0x0404
-#define SSB_CHIPCO_UART1_FCR		0x0408
-#define SSB_CHIPCO_UART1_LCR		0x040C
-#define SSB_CHIPCO_UART1_MCR		0x0410
-#define SSB_CHIPCO_UART1_LSR		0x0414
-#define SSB_CHIPCO_UART1_MSR		0x0418
-#define SSB_CHIPCO_UART1_SCRATCH	0x041C
-/* PMU registers (rev >= 20) */
-#define SSB_CHIPCO_PMU_CTL			0x0600 /* PMU control */
-#define  SSB_CHIPCO_PMU_CTL_ILP_DIV		0xFFFF0000 /* ILP div mask */
-#define  SSB_CHIPCO_PMU_CTL_ILP_DIV_SHIFT	16
-#define  SSB_CHIPCO_PMU_CTL_PLL_UPD		0x00000400
-#define  SSB_CHIPCO_PMU_CTL_NOILPONW		0x00000200 /* No ILP on wait */
-#define  SSB_CHIPCO_PMU_CTL_HTREQEN		0x00000100 /* HT req enable */
-#define  SSB_CHIPCO_PMU_CTL_ALPREQEN		0x00000080 /* ALP req enable */
-#define  SSB_CHIPCO_PMU_CTL_XTALFREQ		0x0000007C /* Crystal freq */
-#define  SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT	2
-#define  SSB_CHIPCO_PMU_CTL_ILPDIVEN		0x00000002 /* ILP div enable */
-#define  SSB_CHIPCO_PMU_CTL_LPOSEL		0x00000001 /* LPO sel */
-#define SSB_CHIPCO_PMU_CAP			0x0604 /* PMU capabilities */
-#define  SSB_CHIPCO_PMU_CAP_REVISION		0x000000FF /* Revision mask */
-#define SSB_CHIPCO_PMU_STAT			0x0608 /* PMU status */
-#define  SSB_CHIPCO_PMU_STAT_INTPEND		0x00000040 /* Interrupt pending */
-#define  SSB_CHIPCO_PMU_STAT_SBCLKST		0x00000030 /* Backplane clock status? */
-#define  SSB_CHIPCO_PMU_STAT_HAVEALP		0x00000008 /* ALP available */
-#define  SSB_CHIPCO_PMU_STAT_HAVEHT		0x00000004 /* HT available */
-#define  SSB_CHIPCO_PMU_STAT_RESINIT		0x00000003 /* Res init */
-#define SSB_CHIPCO_PMU_RES_STAT			0x060C /* PMU res status */
-#define SSB_CHIPCO_PMU_RES_PEND			0x0610 /* PMU res pending */
-#define SSB_CHIPCO_PMU_TIMER			0x0614 /* PMU timer */
-#define SSB_CHIPCO_PMU_MINRES_MSK		0x0618 /* PMU min res mask */
-#define SSB_CHIPCO_PMU_MAXRES_MSK		0x061C /* PMU max res mask */
-#define SSB_CHIPCO_PMU_RES_TABSEL		0x0620 /* PMU res table sel */
-#define SSB_CHIPCO_PMU_RES_DEPMSK		0x0624 /* PMU res dep mask */
-#define SSB_CHIPCO_PMU_RES_UPDNTM		0x0628 /* PMU res updown timer */
-#define SSB_CHIPCO_PMU_RES_TIMER		0x062C /* PMU res timer */
-#define SSB_CHIPCO_PMU_CLKSTRETCH		0x0630 /* PMU clockstretch */
-#define SSB_CHIPCO_PMU_WATCHDOG			0x0634 /* PMU watchdog */
-#define SSB_CHIPCO_PMU_RES_REQTS		0x0640 /* PMU res req timer sel */
-#define SSB_CHIPCO_PMU_RES_REQT			0x0644 /* PMU res req timer */
-#define SSB_CHIPCO_PMU_RES_REQM			0x0648 /* PMU res req mask */
-#define SSB_CHIPCO_CHIPCTL_ADDR			0x0650
-#define SSB_CHIPCO_CHIPCTL_DATA			0x0654
-#define SSB_CHIPCO_REGCTL_ADDR			0x0658
-#define SSB_CHIPCO_REGCTL_DATA			0x065C
-#define SSB_CHIPCO_PLLCTL_ADDR			0x0660
-#define SSB_CHIPCO_PLLCTL_DATA			0x0664
-
-
-
-/** PMU PLL registers */
-
-/* PMU rev 0 PLL registers */
-#define SSB_PMU0_PLLCTL0			0
-#define  SSB_PMU0_PLLCTL0_PDIV_MSK		0x00000001
-#define  SSB_PMU0_PLLCTL0_PDIV_FREQ		25000 /* kHz */
-#define SSB_PMU0_PLLCTL1			1
-#define  SSB_PMU0_PLLCTL1_WILD_IMSK		0xF0000000 /* Wild int mask (low nibble) */
-#define  SSB_PMU0_PLLCTL1_WILD_IMSK_SHIFT	28
-#define  SSB_PMU0_PLLCTL1_WILD_FMSK		0x0FFFFF00 /* Wild frac mask */
-#define  SSB_PMU0_PLLCTL1_WILD_FMSK_SHIFT	8
-#define  SSB_PMU0_PLLCTL1_STOPMOD		0x00000040 /* Stop mod */
-#define SSB_PMU0_PLLCTL2			2
-#define  SSB_PMU0_PLLCTL2_WILD_IMSKHI		0x0000000F /* Wild int mask (high nibble) */
-#define  SSB_PMU0_PLLCTL2_WILD_IMSKHI_SHIFT	0
-
-/* PMU rev 1 PLL registers */
-#define SSB_PMU1_PLLCTL0			0
-#define  SSB_PMU1_PLLCTL0_P1DIV			0x00F00000 /* P1 div */
-#define  SSB_PMU1_PLLCTL0_P1DIV_SHIFT		20
-#define  SSB_PMU1_PLLCTL0_P2DIV			0x0F000000 /* P2 div */
-#define  SSB_PMU1_PLLCTL0_P2DIV_SHIFT		24
-#define SSB_PMU1_PLLCTL1			1
-#define  SSB_PMU1_PLLCTL1_M1DIV			0x000000FF /* M1 div */
-#define  SSB_PMU1_PLLCTL1_M1DIV_SHIFT		0
-#define  SSB_PMU1_PLLCTL1_M2DIV			0x0000FF00 /* M2 div */
-#define  SSB_PMU1_PLLCTL1_M2DIV_SHIFT		8
-#define  SSB_PMU1_PLLCTL1_M3DIV			0x00FF0000 /* M3 div */
-#define  SSB_PMU1_PLLCTL1_M3DIV_SHIFT		16
-#define  SSB_PMU1_PLLCTL1_M4DIV			0xFF000000 /* M4 div */
-#define  SSB_PMU1_PLLCTL1_M4DIV_SHIFT		24
-#define SSB_PMU1_PLLCTL2			2
-#define  SSB_PMU1_PLLCTL2_M5DIV			0x000000FF /* M5 div */
-#define  SSB_PMU1_PLLCTL2_M5DIV_SHIFT		0
-#define  SSB_PMU1_PLLCTL2_M6DIV			0x0000FF00 /* M6 div */
-#define  SSB_PMU1_PLLCTL2_M6DIV_SHIFT		8
-#define  SSB_PMU1_PLLCTL2_NDIVMODE		0x000E0000 /* NDIV mode */
-#define  SSB_PMU1_PLLCTL2_NDIVMODE_SHIFT	17
-#define  SSB_PMU1_PLLCTL2_NDIVINT		0x1FF00000 /* NDIV int */
-#define  SSB_PMU1_PLLCTL2_NDIVINT_SHIFT		20
-#define SSB_PMU1_PLLCTL3			3
-#define  SSB_PMU1_PLLCTL3_NDIVFRAC		0x00FFFFFF /* NDIV frac */
-#define  SSB_PMU1_PLLCTL3_NDIVFRAC_SHIFT	0
-#define SSB_PMU1_PLLCTL4			4
-#define SSB_PMU1_PLLCTL5			5
-#define  SSB_PMU1_PLLCTL5_CLKDRV		0xFFFFFF00 /* clk drv */
-#define  SSB_PMU1_PLLCTL5_CLKDRV_SHIFT		8
-
-/* BCM4312 PLL resource numbers. */
-#define SSB_PMURES_4312_SWITCHER_BURST		0
-#define SSB_PMURES_4312_SWITCHER_PWM    	1
-#define SSB_PMURES_4312_PA_REF_LDO		2
-#define SSB_PMURES_4312_CORE_LDO_BURST		3
-#define SSB_PMURES_4312_CORE_LDO_PWM		4
-#define SSB_PMURES_4312_RADIO_LDO		5
-#define SSB_PMURES_4312_ILP_REQUEST		6
-#define SSB_PMURES_4312_BG_FILTBYP		7
-#define SSB_PMURES_4312_TX_FILTBYP		8
-#define SSB_PMURES_4312_RX_FILTBYP		9
-#define SSB_PMURES_4312_XTAL_PU			10
-#define SSB_PMURES_4312_ALP_AVAIL		11
-#define SSB_PMURES_4312_BB_PLL_FILTBYP		12
-#define SSB_PMURES_4312_RF_PLL_FILTBYP		13
-#define SSB_PMURES_4312_HT_AVAIL		14
-
-/* BCM4325 PLL resource numbers. */
-#define SSB_PMURES_4325_BUCK_BOOST_BURST	0
-#define SSB_PMURES_4325_CBUCK_BURST		1
-#define SSB_PMURES_4325_CBUCK_PWM		2
-#define SSB_PMURES_4325_CLDO_CBUCK_BURST	3
-#define SSB_PMURES_4325_CLDO_CBUCK_PWM		4
-#define SSB_PMURES_4325_BUCK_BOOST_PWM		5
-#define SSB_PMURES_4325_ILP_REQUEST		6
-#define SSB_PMURES_4325_ABUCK_BURST		7
-#define SSB_PMURES_4325_ABUCK_PWM		8
-#define SSB_PMURES_4325_LNLDO1_PU		9
-#define SSB_PMURES_4325_LNLDO2_PU		10
-#define SSB_PMURES_4325_LNLDO3_PU		11
-#define SSB_PMURES_4325_LNLDO4_PU		12
-#define SSB_PMURES_4325_XTAL_PU			13
-#define SSB_PMURES_4325_ALP_AVAIL		14
-#define SSB_PMURES_4325_RX_PWRSW_PU		15
-#define SSB_PMURES_4325_TX_PWRSW_PU		16
-#define SSB_PMURES_4325_RFPLL_PWRSW_PU		17
-#define SSB_PMURES_4325_LOGEN_PWRSW_PU		18
-#define SSB_PMURES_4325_AFE_PWRSW_PU		19
-#define SSB_PMURES_4325_BBPLL_PWRSW_PU		20
-#define SSB_PMURES_4325_HT_AVAIL		21
-
-/* BCM4328 PLL resource numbers. */
-#define SSB_PMURES_4328_EXT_SWITCHER_PWM	0
-#define SSB_PMURES_4328_BB_SWITCHER_PWM		1
-#define SSB_PMURES_4328_BB_SWITCHER_BURST	2
-#define SSB_PMURES_4328_BB_EXT_SWITCHER_BURST	3
-#define SSB_PMURES_4328_ILP_REQUEST		4
-#define SSB_PMURES_4328_RADIO_SWITCHER_PWM	5
-#define SSB_PMURES_4328_RADIO_SWITCHER_BURST	6
-#define SSB_PMURES_4328_ROM_SWITCH		7
-#define SSB_PMURES_4328_PA_REF_LDO		8
-#define SSB_PMURES_4328_RADIO_LDO		9
-#define SSB_PMURES_4328_AFE_LDO			10
-#define SSB_PMURES_4328_PLL_LDO			11
-#define SSB_PMURES_4328_BG_FILTBYP		12
-#define SSB_PMURES_4328_TX_FILTBYP		13
-#define SSB_PMURES_4328_RX_FILTBYP		14
-#define SSB_PMURES_4328_XTAL_PU			15
-#define SSB_PMURES_4328_XTAL_EN			16
-#define SSB_PMURES_4328_BB_PLL_FILTBYP		17
-#define SSB_PMURES_4328_RF_PLL_FILTBYP		18
-#define SSB_PMURES_4328_BB_PLL_PU		19
-
-/* BCM5354 PLL resource numbers. */
-#define SSB_PMURES_5354_EXT_SWITCHER_PWM	0
-#define SSB_PMURES_5354_BB_SWITCHER_PWM		1
-#define SSB_PMURES_5354_BB_SWITCHER_BURST	2
-#define SSB_PMURES_5354_BB_EXT_SWITCHER_BURST	3
-#define SSB_PMURES_5354_ILP_REQUEST		4
-#define SSB_PMURES_5354_RADIO_SWITCHER_PWM	5
-#define SSB_PMURES_5354_RADIO_SWITCHER_BURST	6
-#define SSB_PMURES_5354_ROM_SWITCH		7
-#define SSB_PMURES_5354_PA_REF_LDO		8
-#define SSB_PMURES_5354_RADIO_LDO		9
-#define SSB_PMURES_5354_AFE_LDO			10
-#define SSB_PMURES_5354_PLL_LDO			11
-#define SSB_PMURES_5354_BG_FILTBYP		12
-#define SSB_PMURES_5354_TX_FILTBYP		13
-#define SSB_PMURES_5354_RX_FILTBYP		14
-#define SSB_PMURES_5354_XTAL_PU			15
-#define SSB_PMURES_5354_XTAL_EN			16
-#define SSB_PMURES_5354_BB_PLL_FILTBYP		17
-#define SSB_PMURES_5354_RF_PLL_FILTBYP		18
-#define SSB_PMURES_5354_BB_PLL_PU		19
-
-
-
-/** Chip specific Chip-Status register contents. */
-#define SSB_CHIPCO_CHST_4322_SPROM_EXISTS	0x00000040 /* SPROM present */
-#define SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL	0x00000003
-#define SSB_CHIPCO_CHST_4325_DEFCIS_SEL		0 /* OTP is powered up, use def. CIS, no SPROM */
-#define SSB_CHIPCO_CHST_4325_SPROM_SEL		1 /* OTP is powered up, SPROM is present */
-#define SSB_CHIPCO_CHST_4325_OTP_SEL		2 /* OTP is powered up, no SPROM */
-#define SSB_CHIPCO_CHST_4325_OTP_PWRDN		3 /* OTP is powered down, SPROM is present */
-#define SSB_CHIPCO_CHST_4325_SDIO_USB_MODE	0x00000004
-#define SSB_CHIPCO_CHST_4325_SDIO_USB_MODE_SHIFT  2
-#define SSB_CHIPCO_CHST_4325_RCAL_VALID		0x00000008
-#define SSB_CHIPCO_CHST_4325_RCAL_VALID_SHIFT	3
-#define SSB_CHIPCO_CHST_4325_RCAL_VALUE		0x000001F0
-#define SSB_CHIPCO_CHST_4325_RCAL_VALUE_SHIFT	4
-#define SSB_CHIPCO_CHST_4325_PMUTOP_2B 		0x00000200 /* 1 for 2b, 0 for to 2a */
-
-/** Macros to determine SPROM presence based on Chip-Status register. */
-#define SSB_CHIPCO_CHST_4312_SPROM_PRESENT(status) \
-	((status & SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL) != \
-		SSB_CHIPCO_CHST_4325_OTP_SEL)
-#define SSB_CHIPCO_CHST_4322_SPROM_PRESENT(status) \
-	(status & SSB_CHIPCO_CHST_4322_SPROM_EXISTS)
-#define SSB_CHIPCO_CHST_4325_SPROM_PRESENT(status) \
-	(((status & SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL) != \
-		SSB_CHIPCO_CHST_4325_DEFCIS_SEL) && \
-	 ((status & SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL) != \
-		SSB_CHIPCO_CHST_4325_OTP_SEL))
-
-
-
-/** Clockcontrol masks and values **/
-
-/* SSB_CHIPCO_CLOCK_N */
-#define	SSB_CHIPCO_CLK_N1		0x0000003F	/* n1 control */
-#define	SSB_CHIPCO_CLK_N2		0x00003F00	/* n2 control */
-#define	SSB_CHIPCO_CLK_N2_SHIFT		8
-#define	SSB_CHIPCO_CLK_PLLC		0x000F0000	/* pll control */
-#define	SSB_CHIPCO_CLK_PLLC_SHIFT	16
-
-/* SSB_CHIPCO_CLOCK_SB/PCI/UART */
-#define	SSB_CHIPCO_CLK_M1		0x0000003F	/* m1 control */
-#define	SSB_CHIPCO_CLK_M2		0x00003F00	/* m2 control */
-#define	SSB_CHIPCO_CLK_M2_SHIFT		8
-#define	SSB_CHIPCO_CLK_M3		0x003F0000	/* m3 control */
-#define	SSB_CHIPCO_CLK_M3_SHIFT		16
-#define	SSB_CHIPCO_CLK_MC		0x1F000000	/* mux control */
-#define	SSB_CHIPCO_CLK_MC_SHIFT		24
-
-/* N3M Clock control magic field values */
-#define	SSB_CHIPCO_CLK_F6_2		0x02		/* A factor of 2 in */
-#define	SSB_CHIPCO_CLK_F6_3		0x03		/* 6-bit fields like */
-#define	SSB_CHIPCO_CLK_F6_4		0x05		/* N1, M1 or M3 */
-#define	SSB_CHIPCO_CLK_F6_5		0x09
-#define	SSB_CHIPCO_CLK_F6_6		0x11
-#define	SSB_CHIPCO_CLK_F6_7		0x21
-
-#define	SSB_CHIPCO_CLK_F5_BIAS		5		/* 5-bit fields get this added */
-
-#define	SSB_CHIPCO_CLK_MC_BYPASS	0x08
-#define	SSB_CHIPCO_CLK_MC_M1		0x04
-#define	SSB_CHIPCO_CLK_MC_M1M2		0x02
-#define	SSB_CHIPCO_CLK_MC_M1M2M3	0x01
-#define	SSB_CHIPCO_CLK_MC_M1M3		0x11
-
-/* Type 2 Clock control magic field values */
-#define	SSB_CHIPCO_CLK_T2_BIAS		2		/* n1, n2, m1 & m3 bias */
-#define	SSB_CHIPCO_CLK_T2M2_BIAS	3		/* m2 bias */
-
-#define	SSB_CHIPCO_CLK_T2MC_M1BYP	1
-#define	SSB_CHIPCO_CLK_T2MC_M2BYP	2
-#define	SSB_CHIPCO_CLK_T2MC_M3BYP	4
-
-/* Type 6 Clock control magic field values */
-#define	SSB_CHIPCO_CLK_T6_MMASK		1		/* bits of interest in m */
-#define	SSB_CHIPCO_CLK_T6_M0		120000000	/* sb clock for m = 0 */
-#define	SSB_CHIPCO_CLK_T6_M1		100000000	/* sb clock for m = 1 */
-#define	SSB_CHIPCO_CLK_SB2MIPS_T6(sb)	(2 * (sb))
-
-/* Common clock base */
-#define	SSB_CHIPCO_CLK_BASE1		24000000	/* Half the clock freq */
-#define SSB_CHIPCO_CLK_BASE2		12500000	/* Alternate crystal on some PLL's */
-
-/* Clock control values for 200Mhz in 5350 */
-#define	SSB_CHIPCO_CLK_5350_N		0x0311
-#define	SSB_CHIPCO_CLK_5350_M		0x04020009
-
-
-/** Bits in the config registers **/
-
-#define	SSB_CHIPCO_CFG_EN		0x0001		/* Enable */
-#define	SSB_CHIPCO_CFG_EXTM		0x000E		/* Extif Mode */
-#define	 SSB_CHIPCO_CFG_EXTM_ASYNC	0x0002		/* Async/Parallel flash */
-#define	 SSB_CHIPCO_CFG_EXTM_SYNC	0x0004		/* Synchronous */
-#define	 SSB_CHIPCO_CFG_EXTM_PCMCIA	0x0008		/* PCMCIA */
-#define	 SSB_CHIPCO_CFG_EXTM_IDE	0x000A		/* IDE */
-#define	SSB_CHIPCO_CFG_DS16		0x0010		/* Data size, 0=8bit, 1=16bit */
-#define	SSB_CHIPCO_CFG_CLKDIV		0x0060		/* Sync: Clock divisor */
-#define	SSB_CHIPCO_CFG_CLKEN		0x0080		/* Sync: Clock enable */
-#define	SSB_CHIPCO_CFG_BSTRO		0x0100		/* Sync: Size/Bytestrobe */
-
-
-/** Flash-specific control/status values */
-
-/* flashcontrol opcodes for ST flashes */
-#define SSB_CHIPCO_FLASHCTL_ST_WREN	0x0006		/* Write Enable */
-#define SSB_CHIPCO_FLASHCTL_ST_WRDIS	0x0004		/* Write Disable */
-#define SSB_CHIPCO_FLASHCTL_ST_RDSR	0x0105		/* Read Status Register */
-#define SSB_CHIPCO_FLASHCTL_ST_WRSR	0x0101		/* Write Status Register */
-#define SSB_CHIPCO_FLASHCTL_ST_READ	0x0303		/* Read Data Bytes */
-#define SSB_CHIPCO_FLASHCTL_ST_PP	0x0302		/* Page Program */
-#define SSB_CHIPCO_FLASHCTL_ST_SE	0x02D8		/* Sector Erase */
-#define SSB_CHIPCO_FLASHCTL_ST_BE	0x00C7		/* Bulk Erase */
-#define SSB_CHIPCO_FLASHCTL_ST_DP	0x00B9		/* Deep Power-down */
-#define SSB_CHIPCO_FLASHCTL_ST_RES	0x03AB		/* Read Electronic Signature */
-#define SSB_CHIPCO_FLASHCTL_ST_CSA	0x1000		/* Keep chip select asserted */
-#define SSB_CHIPCO_FLASHCTL_ST_SSE	0x0220		/* Sub-sector Erase */
-
-/* Status register bits for ST flashes */
-#define SSB_CHIPCO_FLASHSTA_ST_WIP	0x01		/* Write In Progress */
-#define SSB_CHIPCO_FLASHSTA_ST_WEL	0x02		/* Write Enable Latch */
-#define SSB_CHIPCO_FLASHSTA_ST_BP	0x1C		/* Block Protect */
-#define SSB_CHIPCO_FLASHSTA_ST_BP_SHIFT	2
-#define SSB_CHIPCO_FLASHSTA_ST_SRWD	0x80		/* Status Register Write Disable */
-
-/* flashcontrol opcodes for Atmel flashes */
-#define SSB_CHIPCO_FLASHCTL_AT_READ		0x07E8
-#define SSB_CHIPCO_FLASHCTL_AT_PAGE_READ	0x07D2
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_READ	/* FIXME */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_READ	/* FIXME */
-#define SSB_CHIPCO_FLASHCTL_AT_STATUS		0x01D7
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRITE	0x0384
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRITE	0x0387
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_ERASE_PRGM	0x0283	/* Erase program */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_ERASE_PRGM	0x0286	/* Erase program */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_PROGRAM	0x0288
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_PROGRAM	0x0289
-#define SSB_CHIPCO_FLASHCTL_AT_PAGE_ERASE	0x0281
-#define SSB_CHIPCO_FLASHCTL_AT_BLOCK_ERASE	0x0250
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRER_PRGM	0x0382	/* Write erase program */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRER_PRGM	0x0385	/* Write erase program */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_LOAD	0x0253
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_LOAD	0x0255
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_COMPARE	0x0260
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_COMPARE	0x0261
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_REPROGRAM	0x0258
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_REPROGRAM	0x0259
-
-/* Status register bits for Atmel flashes */
-#define SSB_CHIPCO_FLASHSTA_AT_READY	0x80
-#define SSB_CHIPCO_FLASHSTA_AT_MISMATCH	0x40
-#define SSB_CHIPCO_FLASHSTA_AT_ID	0x38
-#define SSB_CHIPCO_FLASHSTA_AT_ID_SHIFT	3
-
-
-/** OTP **/
-
-/* OTP regions */
-#define	SSB_CHIPCO_OTP_HW_REGION	SSB_CHIPCO_OTPS_HW_PROTECT
-#define	SSB_CHIPCO_OTP_SW_REGION	SSB_CHIPCO_OTPS_SW_PROTECT
-#define	SSB_CHIPCO_OTP_CID_REGION	SSB_CHIPCO_OTPS_CID_PROTECT
-
-/* OTP regions (Byte offsets from otp size) */
-#define	SSB_CHIPCO_OTP_SWLIM_OFF	(-8)
-#define	SSB_CHIPCO_OTP_CIDBASE_OFF	0
-#define	SSB_CHIPCO_OTP_CIDLIM_OFF	8
-
-/* Predefined OTP words (Word offset from otp size) */
-#define	SSB_CHIPCO_OTP_BOUNDARY_OFF	(-4)
-#define	SSB_CHIPCO_OTP_HWSIGN_OFF	(-3)
-#define	SSB_CHIPCO_OTP_SWSIGN_OFF	(-2)
-#define	SSB_CHIPCO_OTP_CIDSIGN_OFF	(-1)
-
-#define	SSB_CHIPCO_OTP_CID_OFF		0
-#define	SSB_CHIPCO_OTP_PKG_OFF		1
-#define	SSB_CHIPCO_OTP_FID_OFF		2
-#define	SSB_CHIPCO_OTP_RSV_OFF		3
-#define	SSB_CHIPCO_OTP_LIM_OFF		4
-
-#define	SSB_CHIPCO_OTP_SIGNATURE	0x578A
-#define	SSB_CHIPCO_OTP_MAGIC		0x4E56
-
-
-struct ssb_device;
-struct ssb_serial_port;
-
-/* Data for the PMU, if available.
- * Check availability with ((struct ssb_chipcommon)->capabilities & SSB_CHIPCO_CAP_PMU)
- */
-struct ssb_chipcommon_pmu {
-	u8 rev;			/* PMU revision */
-	u32 crystalfreq;	/* The active crystal frequency (in kHz) */
-};
-
-struct ssb_chipcommon {
-	struct ssb_device *dev;
-	u32 capabilities;
-	u32 status;
-	/* Fast Powerup Delay constant */
-	u16 fast_pwrup_delay;
-	spinlock_t gpio_lock;
-	struct ssb_chipcommon_pmu pmu;
-	u32 ticks_per_ms;
-	u32 max_timer_ms;
-};
-
-static inline bool ssb_chipco_available(struct ssb_chipcommon *cc)
-{
-	return (cc->dev != NULL);
-}
-
-/* Register access */
-#define chipco_read32(cc, offset)	ssb_read32((cc)->dev, offset)
-#define chipco_write32(cc, offset, val)	ssb_write32((cc)->dev, offset, val)
-
-#define chipco_mask32(cc, offset, mask) \
-		chipco_write32(cc, offset, chipco_read32(cc, offset) & (mask))
-#define chipco_set32(cc, offset, set) \
-		chipco_write32(cc, offset, chipco_read32(cc, offset) | (set))
-#define chipco_maskset32(cc, offset, mask, set) \
-		chipco_write32(cc, offset, (chipco_read32(cc, offset) & (mask)) | (set))
-
-extern void ssb_chipcommon_init(struct ssb_chipcommon *cc);
-
-extern void ssb_chipco_suspend(struct ssb_chipcommon *cc);
-extern void ssb_chipco_resume(struct ssb_chipcommon *cc);
-
-extern void ssb_chipco_get_clockcpu(struct ssb_chipcommon *cc,
-                                    u32 *plltype, u32 *n, u32 *m);
-extern void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
-					u32 *plltype, u32 *n, u32 *m);
-extern void ssb_chipco_timing_init(struct ssb_chipcommon *cc,
-				   unsigned long ns_per_cycle);
-
-enum ssb_clkmode {
-	SSB_CLKMODE_SLOW,
-	SSB_CLKMODE_FAST,
-	SSB_CLKMODE_DYNAMIC,
-};
-
-extern void ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,
-				     enum ssb_clkmode mode);
-
-extern u32 ssb_chipco_watchdog_timer_set(struct ssb_chipcommon *cc, u32 ticks);
-
-void ssb_chipco_irq_mask(struct ssb_chipcommon *cc, u32 mask, u32 value);
-
-u32 ssb_chipco_irq_status(struct ssb_chipcommon *cc, u32 mask);
-
-/* Chipcommon GPIO pin access. */
-u32 ssb_chipco_gpio_in(struct ssb_chipcommon *cc, u32 mask);
-u32 ssb_chipco_gpio_out(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_outen(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_control(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_intmask(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_polarity(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_pullup(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_pulldown(struct ssb_chipcommon *cc, u32 mask, u32 value);
-
-#ifdef CPTCFG_SSB_SERIAL
-extern int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
-				  struct ssb_serial_port *ports);
-#endif /* CPTCFG_SSB_SERIAL */
-
-/* PMU support */
-extern void ssb_pmu_init(struct ssb_chipcommon *cc);
-
-enum ssb_pmu_ldo_volt_id {
-	LDO_PAREF = 0,
-	LDO_VOLT1,
-	LDO_VOLT2,
-	LDO_VOLT3,
-};
-
-void ssb_pmu_set_ldo_voltage(struct ssb_chipcommon *cc,
-			     enum ssb_pmu_ldo_volt_id id, u32 voltage);
-void ssb_pmu_set_ldo_paref(struct ssb_chipcommon *cc, bool on);
-void ssb_pmu_spuravoid_pllupdate(struct ssb_chipcommon *cc, int spuravoid);
-
-#endif /* LINUX_SSB_CHIPCO_H_ */
diff --git a/include/linux/ssb/ssb_driver_extif.h b/include/linux/ssb/ssb_driver_extif.h
deleted file mode 100644
index 84ab320..0000000
--- a/include/linux/ssb/ssb_driver_extif.h
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- * Hardware-specific External Interface I/O core definitions
- * for the BCM47xx family of SiliconBackplane-based chips.
- *
- * The External Interface core supports a total of three external chip selects
- * supporting external interfaces. One of the external chip selects is
- * used for Flash, one is used for PCMCIA, and the other may be
- * programmed to support either a synchronous interface or an
- * asynchronous interface. The asynchronous interface can be used to
- * support external devices such as UARTs and the BCM2019 Bluetooth
- * baseband processor.
- * The external interface core also contains 2 on-chip 16550 UARTs, clock
- * frequency control, a watchdog interrupt timer, and a GPIO interface.
- *
- * Copyright 2005, Broadcom Corporation
- * Copyright 2006, Michael Buesch
- *
- * Licensed under the GPL version 2. See COPYING for details.
- */
-#ifndef LINUX_SSB_EXTIFCORE_H_
-#define LINUX_SSB_EXTIFCORE_H_
-
-/* external interface address space */
-#define	SSB_EXTIF_PCMCIA_MEMBASE(x)	(x)
-#define	SSB_EXTIF_PCMCIA_IOBASE(x)	((x) + 0x100000)
-#define	SSB_EXTIF_PCMCIA_CFGBASE(x)	((x) + 0x200000)
-#define	SSB_EXTIF_CFGIF_BASE(x)		((x) + 0x800000)
-#define	SSB_EXTIF_FLASH_BASE(x)		((x) + 0xc00000)
-
-#define SSB_EXTIF_NR_GPIOOUT		5
-/* GPIO NOTE:
- * The multiple instances of output and output enable registers
- * are present to allow driver software for multiple cores to control
- * gpio outputs without needing to share a single register pair.
- * Use the following helper macro to get a register offset value.
- */
-#define SSB_EXTIF_GPIO_OUT(index)	({		\
-	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
-	SSB_EXTIF_GPIO_OUT_BASE + ((index) * 8);	\
-					})
-#define SSB_EXTIF_GPIO_OUTEN(index)	({		\
-	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
-	SSB_EXTIF_GPIO_OUTEN_BASE + ((index) * 8);	\
-					})
-
-/** EXTIF core registers **/
-
-#define SSB_EXTIF_CTL			0x0000
-#define  SSB_EXTIF_CTL_UARTEN		(1 << 0) /* UART enable */
-#define SSB_EXTIF_EXTSTAT		0x0004
-#define  SSB_EXTIF_EXTSTAT_EMODE	(1 << 0) /* Endian mode (ro) */
-#define  SSB_EXTIF_EXTSTAT_EIRQPIN	(1 << 1) /* External interrupt pin (ro) */
-#define  SSB_EXTIF_EXTSTAT_GPIOIRQPIN	(1 << 2) /* GPIO interrupt pin (ro) */
-#define SSB_EXTIF_PCMCIA_CFG		0x0010
-#define SSB_EXTIF_PCMCIA_MEMWAIT	0x0014
-#define SSB_EXTIF_PCMCIA_ATTRWAIT	0x0018
-#define SSB_EXTIF_PCMCIA_IOWAIT		0x001C
-#define SSB_EXTIF_PROG_CFG		0x0020
-#define SSB_EXTIF_PROG_WAITCNT		0x0024
-#define SSB_EXTIF_FLASH_CFG		0x0028
-#define SSB_EXTIF_FLASH_WAITCNT		0x002C
-#define SSB_EXTIF_WATCHDOG		0x0040
-#define SSB_EXTIF_CLOCK_N		0x0044
-#define SSB_EXTIF_CLOCK_SB		0x0048
-#define SSB_EXTIF_CLOCK_PCI		0x004C
-#define SSB_EXTIF_CLOCK_MII		0x0050
-#define SSB_EXTIF_GPIO_IN		0x0060
-#define SSB_EXTIF_GPIO_OUT_BASE		0x0064
-#define SSB_EXTIF_GPIO_OUTEN_BASE	0x0068
-#define SSB_EXTIF_EJTAG_OUTEN		0x0090
-#define SSB_EXTIF_GPIO_INTPOL		0x0094
-#define SSB_EXTIF_GPIO_INTMASK		0x0098
-#define SSB_EXTIF_UART_DATA		0x0300
-#define SSB_EXTIF_UART_TIMER		0x0310
-#define SSB_EXTIF_UART_FCR		0x0320
-#define SSB_EXTIF_UART_LCR		0x0330
-#define SSB_EXTIF_UART_MCR		0x0340
-#define SSB_EXTIF_UART_LSR		0x0350
-#define SSB_EXTIF_UART_MSR		0x0360
-#define SSB_EXTIF_UART_SCRATCH		0x0370
-
-
-
-
-/* pcmcia/prog/flash_config */
-#define	SSB_EXTCFG_EN			(1 << 0)	/* enable */
-#define	SSB_EXTCFG_MODE			0xE		/* mode */
-#define	SSB_EXTCFG_MODE_SHIFT		1
-#define	 SSB_EXTCFG_MODE_FLASH		0x0		/* flash/asynchronous mode */
-#define	 SSB_EXTCFG_MODE_SYNC		0x2		/* synchronous mode */
-#define	 SSB_EXTCFG_MODE_PCMCIA		0x4		/* pcmcia mode */
-#define	SSB_EXTCFG_DS16			(1 << 4)	/* destsize:  0=8bit, 1=16bit */
-#define	SSB_EXTCFG_BSWAP		(1 << 5)	/* byteswap */
-#define	SSB_EXTCFG_CLKDIV		0xC0		/* clock divider */
-#define	SSB_EXTCFG_CLKDIV_SHIFT		6
-#define	 SSB_EXTCFG_CLKDIV_2		0x0		/* backplane/2 */
-#define	 SSB_EXTCFG_CLKDIV_3		0x40		/* backplane/3 */
-#define	 SSB_EXTCFG_CLKDIV_4		0x80		/* backplane/4 */
-#define	SSB_EXTCFG_CLKEN		(1 << 8)	/* clock enable */
-#define	SSB_EXTCFG_STROBE		(1 << 9)	/* size/bytestrobe (synch only) */
-
-/* pcmcia_memwait */
-#define	SSB_PCMCIA_MEMW_0		0x0000003F	/* waitcount0 */
-#define	SSB_PCMCIA_MEMW_1		0x00001F00	/* waitcount1 */
-#define	SSB_PCMCIA_MEMW_1_SHIFT		8
-#define	SSB_PCMCIA_MEMW_2		0x001F0000	/* waitcount2 */
-#define	SSB_PCMCIA_MEMW_2_SHIFT		16
-#define	SSB_PCMCIA_MEMW_3		0x1F000000	/* waitcount3 */
-#define	SSB_PCMCIA_MEMW_3_SHIFT		24
-
-/* pcmcia_attrwait */
-#define	SSB_PCMCIA_ATTW_0		0x0000003F	/* waitcount0 */
-#define	SSB_PCMCIA_ATTW_1		0x00001F00	/* waitcount1 */
-#define	SSB_PCMCIA_ATTW_1_SHIFT		8
-#define	SSB_PCMCIA_ATTW_2		0x001F0000	/* waitcount2 */
-#define	SSB_PCMCIA_ATTW_2_SHIFT		16
-#define	SSB_PCMCIA_ATTW_3		0x1F000000	/* waitcount3 */
-#define	SSB_PCMCIA_ATTW_3_SHIFT		24
-
-/* pcmcia_iowait */
-#define	SSB_PCMCIA_IOW_0		0x0000003F	/* waitcount0 */
-#define	SSB_PCMCIA_IOW_1		0x00001F00	/* waitcount1 */
-#define	SSB_PCMCIA_IOW_1_SHIFT		8
-#define	SSB_PCMCIA_IOW_2		0x001F0000	/* waitcount2 */
-#define	SSB_PCMCIA_IOW_2_SHIFT		16
-#define	SSB_PCMCIA_IOW_3		0x1F000000	/* waitcount3 */
-#define	SSB_PCMCIA_IOW_3_SHIFT		24
-
-/* prog_waitcount */
-#define	SSB_PROG_WCNT_0			0x0000001F	/* waitcount0 */
-#define	SSB_PROG_WCNT_1			0x00001F00	/* waitcount1 */
-#define	SSB_PROG_WCNT_1_SHIFT		8
-#define	SSB_PROG_WCNT_2			0x001F0000	/* waitcount2 */
-#define	SSB_PROG_WCNT_2_SHIFT		16
-#define	SSB_PROG_WCNT_3			0x1F000000	/* waitcount3 */
-#define	SSB_PROG_WCNT_3_SHIFT		24
-
-#define SSB_PROG_W0			0x0000000C
-#define SSB_PROG_W1			0x00000A00
-#define SSB_PROG_W2			0x00020000
-#define SSB_PROG_W3			0x01000000
-
-/* flash_waitcount */
-#define	SSB_FLASH_WCNT_0		0x0000001F	/* waitcount0 */
-#define	SSB_FLASH_WCNT_1		0x00001F00	/* waitcount1 */
-#define	SSB_FLASH_WCNT_1_SHIFT		8
-#define	SSB_FLASH_WCNT_2		0x001F0000	/* waitcount2 */
-#define	SSB_FLASH_WCNT_2_SHIFT		16
-#define	SSB_FLASH_WCNT_3		0x1F000000	/* waitcount3 */
-#define	SSB_FLASH_WCNT_3_SHIFT		24
-
-/* watchdog */
-#define SSB_EXTIF_WATCHDOG_CLK		48000000	/* Hz */
-
-#define SSB_EXTIF_WATCHDOG_MAX_TIMER	((1 << 28) - 1)
-#define SSB_EXTIF_WATCHDOG_MAX_TIMER_MS	(SSB_EXTIF_WATCHDOG_MAX_TIMER \
-					 / (SSB_EXTIF_WATCHDOG_CLK / 1000))
-
-
-#ifdef CPTCFG_SSB_DRIVER_EXTIF
-
-struct ssb_extif {
-	struct ssb_device *dev;
-	spinlock_t gpio_lock;
-};
-
-static inline bool ssb_extif_available(struct ssb_extif *extif)
-{
-	return (extif->dev != NULL);
-}
-
-extern void ssb_extif_get_clockcontrol(struct ssb_extif *extif,
-			               u32 *plltype, u32 *n, u32 *m);
-
-extern void ssb_extif_timing_init(struct ssb_extif *extif,
-				  unsigned long ns);
-
-extern u32 ssb_extif_watchdog_timer_set(struct ssb_extif *extif, u32 ticks);
-
-/* Extif GPIO pin access */
-u32 ssb_extif_gpio_in(struct ssb_extif *extif, u32 mask);
-u32 ssb_extif_gpio_out(struct ssb_extif *extif, u32 mask, u32 value);
-u32 ssb_extif_gpio_outen(struct ssb_extif *extif, u32 mask, u32 value);
-u32 ssb_extif_gpio_polarity(struct ssb_extif *extif, u32 mask, u32 value);
-u32 ssb_extif_gpio_intmask(struct ssb_extif *extif, u32 mask, u32 value);
-
-#ifdef CPTCFG_SSB_SERIAL
-extern int ssb_extif_serial_init(struct ssb_extif *extif,
-				 struct ssb_serial_port *ports);
-#endif /* CPTCFG_SSB_SERIAL */
-
-
-#else /* CPTCFG_SSB_DRIVER_EXTIF */
-/* extif disabled */
-
-struct ssb_extif {
-};
-
-static inline bool ssb_extif_available(struct ssb_extif *extif)
-{
-	return 0;
-}
-
-static inline
-void ssb_extif_get_clockcontrol(struct ssb_extif *extif,
-			        u32 *plltype, u32 *n, u32 *m)
-{
-}
-
-static inline
-void ssb_extif_timing_init(struct ssb_extif *extif, unsigned long ns)
-{
-}
-
-static inline
-u32 ssb_extif_watchdog_timer_set(struct ssb_extif *extif, u32 ticks)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_in(struct ssb_extif *extif, u32 mask)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_out(struct ssb_extif *extif, u32 mask,
-				     u32 value)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_outen(struct ssb_extif *extif, u32 mask,
-				       u32 value)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_polarity(struct ssb_extif *extif, u32 mask,
-					  u32 value)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_intmask(struct ssb_extif *extif, u32 mask,
-					 u32 value)
-{
-	return 0;
-}
-
-#ifdef CPTCFG_SSB_SERIAL
-static inline int ssb_extif_serial_init(struct ssb_extif *extif,
-					struct ssb_serial_port *ports)
-{
-	return 0;
-}
-#endif /* CPTCFG_SSB_SERIAL */
-
-#endif /* CPTCFG_SSB_DRIVER_EXTIF */
-#endif /* LINUX_SSB_EXTIFCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_gige.h b/include/linux/ssb/ssb_driver_gige.h
deleted file mode 100644
index 1ccc0c5..0000000
--- a/include/linux/ssb/ssb_driver_gige.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_DRIVER_GIGE_H_
-#define LINUX_SSB_DRIVER_GIGE_H_
-
-#include <linux/ssb/ssb.h>
-#include <linux/bug.h>
-#include <linux/pci.h>
-#include <linux/spinlock.h>
-
-
-#ifdef CPTCFG_SSB_DRIVER_GIGE
-
-
-#define SSB_GIGE_PCIIO			0x0000 /* PCI I/O Registers (1024 bytes) */
-#define SSB_GIGE_RESERVED		0x0400 /* Reserved (1024 bytes) */
-#define SSB_GIGE_PCICFG			0x0800 /* PCI config space (256 bytes) */
-#define SSB_GIGE_SHIM_FLUSHSTAT		0x0C00 /* PCI to OCP: Flush status control (32bit) */
-#define SSB_GIGE_SHIM_FLUSHRDA		0x0C04 /* PCI to OCP: Flush read address (32bit) */
-#define SSB_GIGE_SHIM_FLUSHTO		0x0C08 /* PCI to OCP: Flush timeout counter (32bit) */
-#define SSB_GIGE_SHIM_BARRIER		0x0C0C /* PCI to OCP: Barrier register (32bit) */
-#define SSB_GIGE_SHIM_MAOCPSI		0x0C10 /* PCI to OCP: MaocpSI Control (32bit) */
-#define SSB_GIGE_SHIM_SIOCPMA		0x0C14 /* PCI to OCP: SiocpMa Control (32bit) */
-
-/* TM Status High flags */
-#define SSB_GIGE_TMSHIGH_RGMII		0x00010000 /* Have an RGMII PHY-bus */
-/* TM Status Low flags */
-#define SSB_GIGE_TMSLOW_TXBYPASS	0x00080000 /* TX bypass (no delay) */
-#define SSB_GIGE_TMSLOW_RXBYPASS	0x00100000 /* RX bypass (no delay) */
-#define SSB_GIGE_TMSLOW_DLLEN		0x01000000 /* Enable DLL controls */
-
-/* Boardflags (low) */
-#define SSB_GIGE_BFL_ROBOSWITCH		0x0010
-
-
-#define SSB_GIGE_MEM_RES_NAME		"SSB Broadcom 47xx GigE memory"
-#define SSB_GIGE_IO_RES_NAME		"SSB Broadcom 47xx GigE I/O"
-
-struct ssb_gige {
-	struct ssb_device *dev;
-
-	spinlock_t lock;
-
-	/* True, if the device has an RGMII bus.
-	 * False, if the device has a GMII bus. */
-	bool has_rgmii;
-
-	/* The PCI controller device. */
-	struct pci_controller pci_controller;
-	struct pci_ops pci_ops;
-	struct resource mem_resource;
-	struct resource io_resource;
-};
-
-/* Check whether a PCI device is a SSB Gigabit Ethernet core. */
-extern bool pdev_is_ssb_gige_core(struct pci_dev *pdev);
-
-/* Convert a pci_dev pointer to a ssb_gige pointer. */
-static inline struct ssb_gige * pdev_to_ssb_gige(struct pci_dev *pdev)
-{
-	if (!pdev_is_ssb_gige_core(pdev))
-		return NULL;
-	return container_of(pdev->bus->ops, struct ssb_gige, pci_ops);
-}
-
-/* Returns whether the PHY is connected by an RGMII bus. */
-static inline bool ssb_gige_is_rgmii(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	return (dev ? dev->has_rgmii : 0);
-}
-
-/* Returns whether we have a Roboswitch. */
-static inline bool ssb_gige_have_roboswitch(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (dev)
-		return !!(dev->dev->bus->sprom.boardflags_lo &
-			  SSB_GIGE_BFL_ROBOSWITCH);
-	return 0;
-}
-
-/* Returns whether we can only do one DMA at once. */
-static inline bool ssb_gige_one_dma_at_once(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (dev)
-		return ((dev->dev->bus->chip_id == 0x4785) &&
-			(dev->dev->bus->chip_rev < 2));
-	return 0;
-}
-
-/* Returns whether we must flush posted writes. */
-static inline bool ssb_gige_must_flush_posted_writes(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (dev)
-		return (dev->dev->bus->chip_id == 0x4785);
-	return 0;
-}
-
-/* Get the device MAC address */
-static inline int ssb_gige_get_macaddr(struct pci_dev *pdev, u8 *macaddr)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (!dev)
-		return -ENODEV;
-
-	memcpy(macaddr, dev->dev->bus->sprom.et0mac, 6);
-	return 0;
-}
-
-/* Get the device phy address */
-static inline int ssb_gige_get_phyaddr(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (!dev)
-		return -ENODEV;
-
-	return dev->dev->bus->sprom.et0phyaddr;
-}
-
-extern int ssb_gige_pcibios_plat_dev_init(struct ssb_device *sdev,
-					  struct pci_dev *pdev);
-extern int ssb_gige_map_irq(struct ssb_device *sdev,
-			    const struct pci_dev *pdev);
-
-/* The GigE driver is not a standalone module, because we don't have support
- * for unregistering the driver. So we could not unload the module anyway. */
-extern int ssb_gige_init(void);
-static inline void ssb_gige_exit(void)
-{
-	/* Currently we can not unregister the GigE driver,
-	 * because we can not unregister the PCI bridge. */
-	BUG();
-}
-
-
-#else /* CPTCFG_SSB_DRIVER_GIGE */
-/* Gigabit Ethernet driver disabled */
-
-
-static inline int ssb_gige_pcibios_plat_dev_init(struct ssb_device *sdev,
-						 struct pci_dev *pdev)
-{
-	return -ENOSYS;
-}
-static inline int ssb_gige_map_irq(struct ssb_device *sdev,
-				   const struct pci_dev *pdev)
-{
-	return -ENOSYS;
-}
-static inline int ssb_gige_init(void)
-{
-	return 0;
-}
-static inline void ssb_gige_exit(void)
-{
-}
-
-static inline bool pdev_is_ssb_gige_core(struct pci_dev *pdev)
-{
-	return 0;
-}
-static inline struct ssb_gige * pdev_to_ssb_gige(struct pci_dev *pdev)
-{
-	return NULL;
-}
-static inline bool ssb_gige_is_rgmii(struct pci_dev *pdev)
-{
-	return 0;
-}
-static inline bool ssb_gige_have_roboswitch(struct pci_dev *pdev)
-{
-	return 0;
-}
-static inline bool ssb_gige_one_dma_at_once(struct pci_dev *pdev)
-{
-	return 0;
-}
-static inline bool ssb_gige_must_flush_posted_writes(struct pci_dev *pdev)
-{
-	return 0;
-}
-static inline int ssb_gige_get_macaddr(struct pci_dev *pdev, u8 *macaddr)
-{
-	return -ENODEV;
-}
-static inline int ssb_gige_get_phyaddr(struct pci_dev *pdev)
-{
-	return -ENODEV;
-}
-
-#endif /* CPTCFG_SSB_DRIVER_GIGE */
-#endif /* LINUX_SSB_DRIVER_GIGE_H_ */
diff --git a/include/linux/ssb/ssb_driver_mips.h b/include/linux/ssb/ssb_driver_mips.h
deleted file mode 100644
index f4d3ef3..0000000
--- a/include/linux/ssb/ssb_driver_mips.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_MIPSCORE_H_
-#define LINUX_SSB_MIPSCORE_H_
-
-#ifdef CPTCFG_SSB_DRIVER_MIPS
-
-struct ssb_device;
-
-struct ssb_serial_port {
-	void *regs;
-	unsigned long clockspeed;
-	unsigned int irq;
-	unsigned int baud_base;
-	unsigned int reg_shift;
-};
-
-struct ssb_pflash {
-	bool present;
-	u8 buswidth;
-	u32 window;
-	u32 window_size;
-};
-
-#ifdef CPTCFG_SSB_SFLASH
-struct ssb_sflash {
-	bool present;
-	u32 window;
-	u32 blocksize;
-	u16 numblocks;
-	u32 size;
-
-	void *priv;
-};
-#endif
-
-struct ssb_mipscore {
-	struct ssb_device *dev;
-
-	int nr_serial_ports;
-	struct ssb_serial_port serial_ports[4];
-
-	struct ssb_pflash pflash;
-#ifdef CPTCFG_SSB_SFLASH
-	struct ssb_sflash sflash;
-#endif
-};
-
-extern void ssb_mipscore_init(struct ssb_mipscore *mcore);
-extern u32 ssb_cpu_clock(struct ssb_mipscore *mcore);
-
-extern unsigned int ssb_mips_irq(struct ssb_device *dev);
-
-
-#else /* CPTCFG_SSB_DRIVER_MIPS */
-
-struct ssb_mipscore {
-};
-
-static inline
-void ssb_mipscore_init(struct ssb_mipscore *mcore)
-{
-}
-
-static inline unsigned int ssb_mips_irq(struct ssb_device *dev)
-{
-	return 0;
-}
-
-#endif /* CPTCFG_SSB_DRIVER_MIPS */
-
-#endif /* LINUX_SSB_MIPSCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_pci.h b/include/linux/ssb/ssb_driver_pci.h
deleted file mode 100644
index 90a1dda..0000000
--- a/include/linux/ssb/ssb_driver_pci.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_PCICORE_H_
-#define LINUX_SSB_PCICORE_H_
-
-#include <linux/types.h>
-
-struct pci_dev;
-
-
-#ifdef CPTCFG_SSB_DRIVER_PCICORE
-
-/* PCI core registers. */
-#define SSB_PCICORE_CTL			0x0000	/* PCI Control */
-#define  SSB_PCICORE_CTL_RST_OE		0x00000001 /* PCI_RESET Output Enable */
-#define  SSB_PCICORE_CTL_RST		0x00000002 /* PCI_RESET driven out to pin */
-#define  SSB_PCICORE_CTL_CLK_OE		0x00000004 /* Clock gate Output Enable */
-#define  SSB_PCICORE_CTL_CLK		0x00000008 /* Gate for clock driven out to pin */
-#define SSB_PCICORE_ARBCTL		0x0010	/* PCI Arbiter Control */
-#define  SSB_PCICORE_ARBCTL_INTERN	0x00000001 /* Use internal arbiter */
-#define  SSB_PCICORE_ARBCTL_EXTERN	0x00000002 /* Use external arbiter */
-#define  SSB_PCICORE_ARBCTL_PARKID	0x00000006 /* Mask, selects which agent is parked on an idle bus */
-#define   SSB_PCICORE_ARBCTL_PARKID_LAST	0x00000000 /* Last requestor */
-#define   SSB_PCICORE_ARBCTL_PARKID_4710	0x00000002 /* 4710 */
-#define   SSB_PCICORE_ARBCTL_PARKID_EXT0	0x00000004 /* External requestor 0 */
-#define   SSB_PCICORE_ARBCTL_PARKID_EXT1	0x00000006 /* External requestor 1 */
-#define SSB_PCICORE_ISTAT		0x0020	/* Interrupt status */
-#define  SSB_PCICORE_ISTAT_INTA		0x00000001 /* PCI INTA# */
-#define  SSB_PCICORE_ISTAT_INTB		0x00000002 /* PCI INTB# */
-#define  SSB_PCICORE_ISTAT_SERR		0x00000004 /* PCI SERR# (write to clear) */
-#define  SSB_PCICORE_ISTAT_PERR		0x00000008 /* PCI PERR# (write to clear) */
-#define  SSB_PCICORE_ISTAT_PME		0x00000010 /* PCI PME# */
-#define SSB_PCICORE_IMASK		0x0024	/* Interrupt mask */
-#define  SSB_PCICORE_IMASK_INTA		0x00000001 /* PCI INTA# */
-#define  SSB_PCICORE_IMASK_INTB		0x00000002 /* PCI INTB# */
-#define  SSB_PCICORE_IMASK_SERR		0x00000004 /* PCI SERR# */
-#define  SSB_PCICORE_IMASK_PERR		0x00000008 /* PCI PERR# */
-#define  SSB_PCICORE_IMASK_PME		0x00000010 /* PCI PME# */
-#define SSB_PCICORE_MBOX		0x0028	/* Backplane to PCI Mailbox */
-#define  SSB_PCICORE_MBOX_F0_0		0x00000100 /* PCI function 0, INT 0 */
-#define  SSB_PCICORE_MBOX_F0_1		0x00000200 /* PCI function 0, INT 1 */
-#define  SSB_PCICORE_MBOX_F1_0		0x00000400 /* PCI function 1, INT 0 */
-#define  SSB_PCICORE_MBOX_F1_1		0x00000800 /* PCI function 1, INT 1 */
-#define  SSB_PCICORE_MBOX_F2_0		0x00001000 /* PCI function 2, INT 0 */
-#define  SSB_PCICORE_MBOX_F2_1		0x00002000 /* PCI function 2, INT 1 */
-#define  SSB_PCICORE_MBOX_F3_0		0x00004000 /* PCI function 3, INT 0 */
-#define  SSB_PCICORE_MBOX_F3_1		0x00008000 /* PCI function 3, INT 1 */
-#define SSB_PCICORE_BCAST_ADDR		0x0050	/* Backplane Broadcast Address */
-#define  SSB_PCICORE_BCAST_ADDR_MASK	0x000000FF
-#define SSB_PCICORE_BCAST_DATA		0x0054	/* Backplane Broadcast Data */
-#define SSB_PCICORE_GPIO_IN		0x0060	/* rev >= 2 only */
-#define SSB_PCICORE_GPIO_OUT		0x0064	/* rev >= 2 only */
-#define SSB_PCICORE_GPIO_ENABLE		0x0068	/* rev >= 2 only */
-#define SSB_PCICORE_GPIO_CTL		0x006C	/* rev >= 2 only */
-#define SSB_PCICORE_SBTOPCI0		0x0100	/* Backplane to PCI translation 0 (sbtopci0) */
-#define  SSB_PCICORE_SBTOPCI0_MASK	0xFC000000
-#define SSB_PCICORE_SBTOPCI1		0x0104	/* Backplane to PCI translation 1 (sbtopci1) */
-#define  SSB_PCICORE_SBTOPCI1_MASK	0xFC000000
-#define SSB_PCICORE_SBTOPCI2		0x0108	/* Backplane to PCI translation 2 (sbtopci2) */
-#define  SSB_PCICORE_SBTOPCI2_MASK	0xC0000000
-#define SSB_PCICORE_PCICFG0		0x0400	/* PCI config space 0 (rev >= 8) */
-#define SSB_PCICORE_PCICFG1		0x0500	/* PCI config space 1 (rev >= 8) */
-#define SSB_PCICORE_PCICFG2		0x0600	/* PCI config space 2 (rev >= 8) */
-#define SSB_PCICORE_PCICFG3		0x0700	/* PCI config space 3 (rev >= 8) */
-#define SSB_PCICORE_SPROM(wordoffset)	(0x0800 + ((wordoffset) * 2)) /* SPROM shadow area (72 bytes) */
-
-/* SBtoPCIx */
-#define SSB_PCICORE_SBTOPCI_MEM		0x00000000
-#define SSB_PCICORE_SBTOPCI_IO		0x00000001
-#define SSB_PCICORE_SBTOPCI_CFG0	0x00000002
-#define SSB_PCICORE_SBTOPCI_CFG1	0x00000003
-#define SSB_PCICORE_SBTOPCI_PREF	0x00000004 /* Prefetch enable */
-#define SSB_PCICORE_SBTOPCI_BURST	0x00000008 /* Burst enable */
-#define SSB_PCICORE_SBTOPCI_MRM		0x00000020 /* Memory Read Multiple */
-#define SSB_PCICORE_SBTOPCI_RC		0x00000030 /* Read Command mask (rev >= 11) */
-#define  SSB_PCICORE_SBTOPCI_RC_READ	0x00000000 /* Memory read */
-#define  SSB_PCICORE_SBTOPCI_RC_READL	0x00000010 /* Memory read line */
-#define  SSB_PCICORE_SBTOPCI_RC_READM	0x00000020 /* Memory read multiple */
-
-
-/* PCIcore specific boardflags */
-#define SSB_PCICORE_BFL_NOPCI		0x00000400 /* Board leaves PCI floating */
-
-
-struct ssb_pcicore {
-	struct ssb_device *dev;
-	u8 setup_done:1;
-	u8 hostmode:1;
-	u8 cardbusmode:1;
-};
-
-extern void ssb_pcicore_init(struct ssb_pcicore *pc);
-
-/* Enable IRQ routing for a specific device */
-extern int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
-					  struct ssb_device *dev);
-
-int ssb_pcicore_plat_dev_init(struct pci_dev *d);
-int ssb_pcicore_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin);
-
-
-#else /* CPTCFG_SSB_DRIVER_PCICORE */
-
-
-struct ssb_pcicore {
-};
-
-static inline
-void ssb_pcicore_init(struct ssb_pcicore *pc)
-{
-}
-
-static inline
-int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
-				   struct ssb_device *dev)
-{
-	return 0;
-}
-
-static inline
-int ssb_pcicore_plat_dev_init(struct pci_dev *d)
-{
-	return -ENODEV;
-}
-static inline
-int ssb_pcicore_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
-{
-	return -ENODEV;
-}
-
-#endif /* CPTCFG_SSB_DRIVER_PCICORE */
-#endif /* LINUX_SSB_PCICORE_H_ */
diff --git a/include/linux/ssb/ssb_embedded.h b/include/linux/ssb/ssb_embedded.h
deleted file mode 100644
index 49604ac..0000000
--- a/include/linux/ssb/ssb_embedded.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_EMBEDDED_H_
-#define LINUX_SSB_EMBEDDED_H_
-
-#include <linux/types.h>
-#include <linux/ssb/ssb.h>
-
-
-extern int ssb_watchdog_timer_set(struct ssb_bus *bus, u32 ticks);
-
-/* Generic GPIO API */
-u32 ssb_gpio_in(struct ssb_bus *bus, u32 mask);
-u32 ssb_gpio_out(struct ssb_bus *bus, u32 mask, u32 value);
-u32 ssb_gpio_outen(struct ssb_bus *bus, u32 mask, u32 value);
-u32 ssb_gpio_control(struct ssb_bus *bus, u32 mask, u32 value);
-u32 ssb_gpio_intmask(struct ssb_bus *bus, u32 mask, u32 value);
-u32 ssb_gpio_polarity(struct ssb_bus *bus, u32 mask, u32 value);
-
-#endif /* LINUX_SSB_EMBEDDED_H_ */
diff --git a/include/linux/ssb/ssb_regs.h b/include/linux/ssb/ssb_regs.h
deleted file mode 100644
index 210f464..0000000
--- a/include/linux/ssb/ssb_regs.h
+++ /dev/null
@@ -1,687 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_REGS_H_
-#define LINUX_SSB_REGS_H_
-
-
-/* SiliconBackplane Address Map.
- * All regions may not exist on all chips.
- */
-#define SSB_SDRAM_BASE		0x00000000U	/* Physical SDRAM */
-#define SSB_PCI_MEM		0x08000000U	/* Host Mode sb2pcitranslation0 (64 MB) */
-#define SSB_PCI_CFG		0x0c000000U	/* Host Mode sb2pcitranslation1 (64 MB) */
-#define	SSB_SDRAM_SWAPPED	0x10000000U	/* Byteswapped Physical SDRAM */
-#define SSB_ENUM_BASE    	0x18000000U	/* Enumeration space base */
-#define	SSB_ENUM_LIMIT		0x18010000U	/* Enumeration space limit */
-
-#define	SSB_FLASH2		0x1c000000U	/* Flash Region 2 (region 1 shadowed here) */
-#define	SSB_FLASH2_SZ		0x02000000U	/* Size of Flash Region 2 */
-
-#define	SSB_EXTIF_BASE		0x1f000000U	/* External Interface region base address */
-#define	SSB_FLASH1		0x1fc00000U	/* Flash Region 1 */
-#define	SSB_FLASH1_SZ		0x00400000U	/* Size of Flash Region 1 */
-
-#define SSB_PCI_DMA		0x40000000U	/* Client Mode sb2pcitranslation2 (1 GB) */
-#define SSB_PCI_DMA_SZ		0x40000000U	/* Client Mode sb2pcitranslation2 size in bytes */
-#define SSB_PCIE_DMA_L32	0x00000000U	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), low 32 bits */
-#define SSB_PCIE_DMA_H32	0x80000000U	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), high 32 bits */
-#define	SSB_EUART		(SSB_EXTIF_BASE + 0x00800000)
-#define	SSB_LED			(SSB_EXTIF_BASE + 0x00900000)
-
-
-/* Enumeration space constants */
-#define SSB_CORE_SIZE		0x1000	/* Size of a core MMIO area */
-#define SSB_MAX_NR_CORES	((SSB_ENUM_LIMIT - SSB_ENUM_BASE) / SSB_CORE_SIZE)
-
-
-/* mips address */
-#define	SSB_EJTAG		0xff200000	/* MIPS EJTAG space (2M) */
-
-
-/* SSB PCI config space registers. */
-#define SSB_PMCSR		0x44
-#define  SSB_PE			0x100
-#define	SSB_BAR0_WIN		0x80	/* Backplane address space 0 */
-#define	SSB_BAR1_WIN		0x84	/* Backplane address space 1 */
-#define	SSB_SPROMCTL		0x88	/* SPROM control */
-#define  SSB_SPROMCTL_WE	0x10	/* SPROM write enable */
-#define	SSB_BAR1_CONTROL	0x8c	/* Address space 1 burst control */
-#define SSB_PCI_IRQS		0x90	/* PCI interrupts */
-#define SSB_PCI_IRQMASK		0x94	/* PCI IRQ control and mask (pcirev >= 6 only) */
-#define SSB_BACKPLANE_IRQS	0x98	/* Backplane Interrupts */
-#define SSB_GPIO_IN		0xB0	/* GPIO Input (pcirev >= 3 only) */
-#define SSB_GPIO_OUT		0xB4	/* GPIO Output (pcirev >= 3 only) */
-#define SSB_GPIO_OUT_ENABLE	0xB8	/* GPIO Output Enable/Disable (pcirev >= 3 only) */
-#define  SSB_GPIO_SCS		0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
-#define  SSB_GPIO_HWRAD		0x20	/* PCI config space GPIO 13 for hw radio disable */
-#define  SSB_GPIO_XTAL		0x40	/* PCI config space GPIO 14 for Xtal powerup */
-#define  SSB_GPIO_PLL		0x80	/* PCI config space GPIO 15 for PLL powerdown */
-
-
-#define SSB_BAR0_MAX_RETRIES	50
-
-/* Silicon backplane configuration register definitions */
-#define SSB_IPSFLAG		0x0F08
-#define	 SSB_IPSFLAG_IRQ1	0x0000003F /* which sbflags get routed to mips interrupt 1 */
-#define	 SSB_IPSFLAG_IRQ1_SHIFT	0
-#define	 SSB_IPSFLAG_IRQ2	0x00003F00 /* which sbflags get routed to mips interrupt 2 */
-#define	 SSB_IPSFLAG_IRQ2_SHIFT	8
-#define	 SSB_IPSFLAG_IRQ3	0x003F0000 /* which sbflags get routed to mips interrupt 3 */
-#define	 SSB_IPSFLAG_IRQ3_SHIFT	16
-#define	 SSB_IPSFLAG_IRQ4	0x3F000000 /* which sbflags get routed to mips interrupt 4 */
-#define	 SSB_IPSFLAG_IRQ4_SHIFT	24
-#define SSB_TPSFLAG		0x0F18
-#define  SSB_TPSFLAG_BPFLAG	0x0000003F /* Backplane flag # */
-#define  SSB_TPSFLAG_ALWAYSIRQ	0x00000040 /* IRQ is always sent on the Backplane */
-#define SSB_TMERRLOGA		0x0F48
-#define SSB_TMERRLOG		0x0F50
-#define SSB_ADMATCH3		0x0F60
-#define SSB_ADMATCH2		0x0F68
-#define SSB_ADMATCH1		0x0F70
-#define SSB_IMSTATE		0x0F90     /* SB Initiator Agent State */
-#define  SSB_IMSTATE_PC		0x0000000f /* Pipe Count */
-#define  SSB_IMSTATE_AP_MASK	0x00000030 /* Arbitration Priority */
-#define  SSB_IMSTATE_AP_BOTH	0x00000000 /* Use both timeslices and token */
-#define  SSB_IMSTATE_AP_TS	0x00000010 /* Use timeslices only */
-#define  SSB_IMSTATE_AP_TK	0x00000020 /* Use token only */
-#define  SSB_IMSTATE_AP_RSV	0x00000030 /* Reserved */
-#define  SSB_IMSTATE_IBE	0x00020000 /* In Band Error */
-#define  SSB_IMSTATE_TO		0x00040000 /* Timeout */
-#define  SSB_IMSTATE_BUSY	0x01800000 /* Busy (Backplane rev >= 2.3 only) */
-#define  SSB_IMSTATE_REJECT	0x02000000 /* Reject (Backplane rev >= 2.3 only) */
-#define SSB_INTVEC		0x0F94     /* SB Interrupt Mask */
-#define  SSB_INTVEC_PCI		0x00000001 /* Enable interrupts for PCI */
-#define  SSB_INTVEC_ENET0	0x00000002 /* Enable interrupts for enet 0 */
-#define  SSB_INTVEC_ILINE20	0x00000004 /* Enable interrupts for iline20 */
-#define  SSB_INTVEC_CODEC	0x00000008 /* Enable interrupts for v90 codec */
-#define  SSB_INTVEC_USB		0x00000010 /* Enable interrupts for usb */
-#define  SSB_INTVEC_EXTIF	0x00000020 /* Enable interrupts for external i/f */
-#define  SSB_INTVEC_ENET1	0x00000040 /* Enable interrupts for enet 1 */
-#define SSB_TMSLOW		0x0F98     /* SB Target State Low */
-#define  SSB_TMSLOW_RESET	0x00000001 /* Reset */
-#define  SSB_TMSLOW_REJECT	0x00000002 /* Reject (Standard Backplane) */
-#define  SSB_TMSLOW_REJECT_23	0x00000004 /* Reject (Backplane rev 2.3) */
-#define  SSB_TMSLOW_CLOCK	0x00010000 /* Clock Enable */
-#define  SSB_TMSLOW_FGC		0x00020000 /* Force Gated Clocks On */
-#define  SSB_TMSLOW_PE		0x40000000 /* Power Management Enable */
-#define  SSB_TMSLOW_BE		0x80000000 /* BIST Enable */
-#define SSB_TMSHIGH		0x0F9C     /* SB Target State High */
-#define  SSB_TMSHIGH_SERR	0x00000001 /* S-error */
-#define  SSB_TMSHIGH_INT	0x00000002 /* Interrupt */
-#define  SSB_TMSHIGH_BUSY	0x00000004 /* Busy */
-#define  SSB_TMSHIGH_TO		0x00000020 /* Timeout. Backplane rev >= 2.3 only */
-#define  SSB_TMSHIGH_COREFL	0x1FFF0000 /* Core specific flags */
-#define  SSB_TMSHIGH_COREFL_SHIFT	16
-#define  SSB_TMSHIGH_DMA64	0x10000000 /* 64bit DMA supported */
-#define  SSB_TMSHIGH_GCR	0x20000000 /* Gated Clock Request */
-#define  SSB_TMSHIGH_BISTF	0x40000000 /* BIST Failed */
-#define  SSB_TMSHIGH_BISTD	0x80000000 /* BIST Done */
-#define SSB_BWA0		0x0FA0
-#define SSB_IMCFGLO		0x0FA8
-#define  SSB_IMCFGLO_SERTO	0x00000007 /* Service timeout */
-#define  SSB_IMCFGLO_REQTO	0x00000070 /* Request timeout */
-#define  SSB_IMCFGLO_REQTO_SHIFT	4
-#define  SSB_IMCFGLO_CONNID	0x00FF0000 /* Connection ID */
-#define  SSB_IMCFGLO_CONNID_SHIFT	16
-#define SSB_IMCFGHI		0x0FAC
-#define SSB_ADMATCH0		0x0FB0
-#define SSB_TMCFGLO		0x0FB8
-#define SSB_TMCFGHI		0x0FBC
-#define SSB_BCONFIG		0x0FC0
-#define SSB_BSTATE		0x0FC8
-#define SSB_ACTCFG		0x0FD8
-#define SSB_FLAGST		0x0FE8
-#define SSB_IDLOW		0x0FF8
-#define  SSB_IDLOW_CFGSP	0x00000003 /* Config Space */
-#define  SSB_IDLOW_ADDRNGE	0x00000038 /* Address Ranges supported */
-#define  SSB_IDLOW_ADDRNGE_SHIFT	3
-#define  SSB_IDLOW_SYNC		0x00000040
-#define  SSB_IDLOW_INITIATOR	0x00000080
-#define  SSB_IDLOW_MIBL		0x00000F00 /* Minimum Backplane latency */
-#define  SSB_IDLOW_MIBL_SHIFT	8
-#define  SSB_IDLOW_MABL		0x0000F000 /* Maximum Backplane latency */
-#define  SSB_IDLOW_MABL_SHIFT	12
-#define  SSB_IDLOW_TIF		0x00010000 /* This Initiator is first */
-#define  SSB_IDLOW_CCW		0x000C0000 /* Cycle counter width */
-#define  SSB_IDLOW_CCW_SHIFT	18
-#define  SSB_IDLOW_TPT		0x00F00000 /* Target ports */
-#define  SSB_IDLOW_TPT_SHIFT	20
-#define  SSB_IDLOW_INITP	0x0F000000 /* Initiator ports */
-#define  SSB_IDLOW_INITP_SHIFT	24
-#define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
-#define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
-#define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
-#define  SSB_IDLOW_SSBREV_24	0x40000000 /* ?? Found in BCM4328 */
-#define  SSB_IDLOW_SSBREV_25	0x50000000 /* ?? Not Found yet */
-#define  SSB_IDLOW_SSBREV_26	0x60000000 /* ?? Found in some BCM4311/2 */
-#define  SSB_IDLOW_SSBREV_27	0x70000000 /* ?? Found in some BCM4311/2 */
-#define SSB_IDHIGH		0x0FFC     /* SB Identification High */
-#define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
-#define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
-#define  SSB_IDHIGH_CC_SHIFT	4
-#define  SSB_IDHIGH_RCHI	0x00007000 /* Revision Code (high part) */
-#define  SSB_IDHIGH_RCHI_SHIFT	8	   /* yes, shift 8 is right */
-#define  SSB_IDHIGH_VC		0xFFFF0000 /* Vendor Code */
-#define  SSB_IDHIGH_VC_SHIFT	16
-
-/* SPROM shadow area. If not otherwise noted, fields are
- * two bytes wide. Note that the SPROM can _only_ be read
- * in two-byte quantities.
- */
-#define SSB_SPROMSIZE_WORDS		64
-#define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
-#define SSB_SPROMSIZE_WORDS_R123	64
-#define SSB_SPROMSIZE_WORDS_R4		220
-#define SSB_SPROMSIZE_BYTES_R123	(SSB_SPROMSIZE_WORDS_R123 * sizeof(u16))
-#define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
-#define SSB_SPROMSIZE_WORDS_R10		230
-#define SSB_SPROMSIZE_WORDS_R11		234
-#define SSB_SPROM_BASE1			0x1000
-#define SSB_SPROM_BASE31		0x0800
-#define SSB_SPROM_REVISION		0x007E
-#define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
-#define  SSB_SPROM_REVISION_CRC		0xFF00	/* SPROM CRC8 value */
-#define  SSB_SPROM_REVISION_CRC_SHIFT	8
-
-/* SPROM Revision 1 */
-#define SSB_SPROM1_SPID			0x0004	/* Subsystem Product ID for PCI */
-#define SSB_SPROM1_SVID			0x0006	/* Subsystem Vendor ID for PCI */
-#define SSB_SPROM1_PID			0x0008	/* Product ID for PCI */
-#define SSB_SPROM1_IL0MAC		0x0048	/* 6 bytes MAC address for 802.11b/g */
-#define SSB_SPROM1_ET0MAC		0x004E	/* 6 bytes MAC address for Ethernet */
-#define SSB_SPROM1_ET1MAC		0x0054	/* 6 bytes MAC address for 802.11a */
-#define SSB_SPROM1_ETHPHY		0x005A	/* Ethernet PHY settings */
-#define  SSB_SPROM1_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
-#define  SSB_SPROM1_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
-#define  SSB_SPROM1_ETHPHY_ET1A_SHIFT	5
-#define  SSB_SPROM1_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
-#define  SSB_SPROM1_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
-#define SSB_SPROM1_BINF			0x005C	/* Board info */
-#define  SSB_SPROM1_BINF_BREV		0x00FF	/* Board Revision */
-#define  SSB_SPROM1_BINF_CCODE		0x0F00	/* Country Code */
-#define  SSB_SPROM1_BINF_CCODE_SHIFT	8
-#define  SSB_SPROM1_BINF_ANTBG		0x3000	/* Available B-PHY and G-PHY antennas */
-#define  SSB_SPROM1_BINF_ANTBG_SHIFT	12
-#define  SSB_SPROM1_BINF_ANTA		0xC000	/* Available A-PHY antennas */
-#define  SSB_SPROM1_BINF_ANTA_SHIFT	14
-#define SSB_SPROM1_PA0B0		0x005E
-#define SSB_SPROM1_PA0B1		0x0060
-#define SSB_SPROM1_PA0B2		0x0062
-#define SSB_SPROM1_GPIOA		0x0064	/* General Purpose IO pins 0 and 1 */
-#define  SSB_SPROM1_GPIOA_P0		0x00FF	/* Pin 0 */
-#define  SSB_SPROM1_GPIOA_P1		0xFF00	/* Pin 1 */
-#define  SSB_SPROM1_GPIOA_P1_SHIFT	8
-#define SSB_SPROM1_GPIOB		0x0066	/* General Purpuse IO pins 2 and 3 */
-#define  SSB_SPROM1_GPIOB_P2		0x00FF	/* Pin 2 */
-#define  SSB_SPROM1_GPIOB_P3		0xFF00	/* Pin 3 */
-#define  SSB_SPROM1_GPIOB_P3_SHIFT	8
-#define SSB_SPROM1_MAXPWR		0x0068	/* Power Amplifier Max Power */
-#define  SSB_SPROM1_MAXPWR_BG		0x00FF	/* B-PHY and G-PHY (in dBm Q5.2) */
-#define  SSB_SPROM1_MAXPWR_A		0xFF00	/* A-PHY (in dBm Q5.2) */
-#define  SSB_SPROM1_MAXPWR_A_SHIFT	8
-#define SSB_SPROM1_PA1B0		0x006A
-#define SSB_SPROM1_PA1B1		0x006C
-#define SSB_SPROM1_PA1B2		0x006E
-#define SSB_SPROM1_ITSSI		0x0070	/* Idle TSSI Target */
-#define  SSB_SPROM1_ITSSI_BG		0x00FF	/* B-PHY and G-PHY*/
-#define  SSB_SPROM1_ITSSI_A		0xFF00	/* A-PHY */
-#define  SSB_SPROM1_ITSSI_A_SHIFT	8
-#define SSB_SPROM1_BFLLO		0x0072	/* Boardflags (low 16 bits) */
-#define SSB_SPROM1_AGAIN		0x0074	/* Antenna Gain (in dBm Q5.2) */
-#define  SSB_SPROM1_AGAIN_BG		0x00FF	/* B-PHY and G-PHY */
-#define  SSB_SPROM1_AGAIN_BG_SHIFT	0
-#define  SSB_SPROM1_AGAIN_A		0xFF00	/* A-PHY */
-#define  SSB_SPROM1_AGAIN_A_SHIFT	8
-#define SSB_SPROM1_CCODE		0x0076
-
-/* SPROM Revision 2 (inherits from rev 1) */
-#define SSB_SPROM2_BFLHI		0x0038	/* Boardflags (high 16 bits) */
-#define SSB_SPROM2_MAXP_A		0x003A	/* A-PHY Max Power */
-#define  SSB_SPROM2_MAXP_A_HI		0x00FF	/* Max Power High */
-#define  SSB_SPROM2_MAXP_A_LO		0xFF00	/* Max Power Low */
-#define  SSB_SPROM2_MAXP_A_LO_SHIFT	8
-#define SSB_SPROM2_PA1LOB0		0x003C	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1LOB1		0x003E	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1LOB2		0x0040	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1HIB0		0x0042	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_PA1HIB1		0x0044	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_PA1HIB2		0x0046	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_OPO			0x0078	/* OFDM Power Offset from CCK Level */
-#define  SSB_SPROM2_OPO_VALUE		0x00FF
-#define  SSB_SPROM2_OPO_UNUSED		0xFF00
-#define SSB_SPROM2_CCODE		0x007C	/* Two char Country Code */
-
-/* SPROM Revision 3 (inherits most data from rev 2) */
-#define SSB_SPROM3_OFDMAPO		0x002C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_OFDMALPO		0x0030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_OFDMAHPO		0x0034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_GPIOLDC		0x0042	/* GPIO LED Powersave Duty Cycle (4 bytes, BigEndian) */
-#define  SSB_SPROM3_GPIOLDC_OFF		0x0000FF00	/* Off Count */
-#define  SSB_SPROM3_GPIOLDC_OFF_SHIFT	8
-#define  SSB_SPROM3_GPIOLDC_ON		0x00FF0000	/* On Count */
-#define  SSB_SPROM3_GPIOLDC_ON_SHIFT	16
-#define SSB_SPROM3_IL0MAC		0x004A	/* 6 bytes MAC address for 802.11b/g */
-#define SSB_SPROM3_CCKPO		0x0078	/* CCK Power Offset */
-#define  SSB_SPROM3_CCKPO_1M		0x000F	/* 1M Rate PO */
-#define  SSB_SPROM3_CCKPO_2M		0x00F0	/* 2M Rate PO */
-#define  SSB_SPROM3_CCKPO_2M_SHIFT	4
-#define  SSB_SPROM3_CCKPO_55M		0x0F00	/* 5.5M Rate PO */
-#define  SSB_SPROM3_CCKPO_55M_SHIFT	8
-#define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
-#define  SSB_SPROM3_CCKPO_11M_SHIFT	12
-#define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
-
-/* SPROM Revision 4 */
-#define SSB_SPROM4_BOARDREV		0x0042	/* Board revision */
-#define SSB_SPROM4_BFLLO		0x0044	/* Boardflags (low 16 bits) */
-#define SSB_SPROM4_BFLHI		0x0046  /* Board Flags Hi */
-#define SSB_SPROM4_BFL2LO		0x0048	/* Board flags 2 (low 16 bits) */
-#define SSB_SPROM4_BFL2HI		0x004A	/* Board flags 2 Hi */
-#define SSB_SPROM4_IL0MAC		0x004C	/* 6 byte MAC address for a/b/g/n */
-#define SSB_SPROM4_CCODE		0x0052	/* Country Code (2 bytes) */
-#define SSB_SPROM4_GPIOA		0x0056	/* Gen. Purpose IO # 0 and 1 */
-#define  SSB_SPROM4_GPIOA_P0		0x00FF	/* Pin 0 */
-#define  SSB_SPROM4_GPIOA_P1		0xFF00	/* Pin 1 */
-#define  SSB_SPROM4_GPIOA_P1_SHIFT	8
-#define SSB_SPROM4_GPIOB		0x0058	/* Gen. Purpose IO # 2 and 3 */
-#define  SSB_SPROM4_GPIOB_P2		0x00FF	/* Pin 2 */
-#define  SSB_SPROM4_GPIOB_P3		0xFF00	/* Pin 3 */
-#define  SSB_SPROM4_GPIOB_P3_SHIFT	8
-#define SSB_SPROM4_ETHPHY		0x005A	/* Ethernet PHY settings ?? */
-#define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
-#define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
-#define  SSB_SPROM4_ETHPHY_ET1A_SHIFT	5
-#define  SSB_SPROM4_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
-#define  SSB_SPROM4_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
-#define SSB_SPROM4_ANTAVAIL		0x005C  /* Antenna available bitfields */
-#define  SSB_SPROM4_ANTAVAIL_BG		0x00FF	/* B-PHY and G-PHY bitfield */
-#define  SSB_SPROM4_ANTAVAIL_BG_SHIFT	0
-#define  SSB_SPROM4_ANTAVAIL_A		0xFF00	/* A-PHY bitfield */
-#define  SSB_SPROM4_ANTAVAIL_A_SHIFT	8
-#define SSB_SPROM4_AGAIN01		0x005E	/* Antenna Gain (in dBm Q5.2) */
-#define  SSB_SPROM4_AGAIN0		0x00FF	/* Antenna 0 */
-#define  SSB_SPROM4_AGAIN0_SHIFT	0
-#define  SSB_SPROM4_AGAIN1		0xFF00	/* Antenna 1 */
-#define  SSB_SPROM4_AGAIN1_SHIFT	8
-#define SSB_SPROM4_AGAIN23		0x0060
-#define  SSB_SPROM4_AGAIN2		0x00FF	/* Antenna 2 */
-#define  SSB_SPROM4_AGAIN2_SHIFT	0
-#define  SSB_SPROM4_AGAIN3		0xFF00	/* Antenna 3 */
-#define  SSB_SPROM4_AGAIN3_SHIFT	8
-#define SSB_SPROM4_TXPID2G01		0x0062 	/* TX Power Index 2GHz */
-#define  SSB_SPROM4_TXPID2G0		0x00FF
-#define  SSB_SPROM4_TXPID2G0_SHIFT	0
-#define  SSB_SPROM4_TXPID2G1		0xFF00
-#define  SSB_SPROM4_TXPID2G1_SHIFT	8
-#define SSB_SPROM4_TXPID2G23		0x0064 	/* TX Power Index 2GHz */
-#define  SSB_SPROM4_TXPID2G2		0x00FF
-#define  SSB_SPROM4_TXPID2G2_SHIFT	0
-#define  SSB_SPROM4_TXPID2G3		0xFF00
-#define  SSB_SPROM4_TXPID2G3_SHIFT	8
-#define SSB_SPROM4_TXPID5G01		0x0066 	/* TX Power Index 5GHz middle subband */
-#define  SSB_SPROM4_TXPID5G0		0x00FF
-#define  SSB_SPROM4_TXPID5G0_SHIFT	0
-#define  SSB_SPROM4_TXPID5G1		0xFF00
-#define  SSB_SPROM4_TXPID5G1_SHIFT	8
-#define SSB_SPROM4_TXPID5G23		0x0068 	/* TX Power Index 5GHz middle subband */
-#define  SSB_SPROM4_TXPID5G2		0x00FF
-#define  SSB_SPROM4_TXPID5G2_SHIFT	0
-#define  SSB_SPROM4_TXPID5G3		0xFF00
-#define  SSB_SPROM4_TXPID5G3_SHIFT	8
-#define SSB_SPROM4_TXPID5GL01		0x006A 	/* TX Power Index 5GHz low subband */
-#define  SSB_SPROM4_TXPID5GL0		0x00FF
-#define  SSB_SPROM4_TXPID5GL0_SHIFT	0
-#define  SSB_SPROM4_TXPID5GL1		0xFF00
-#define  SSB_SPROM4_TXPID5GL1_SHIFT	8
-#define SSB_SPROM4_TXPID5GL23		0x006C 	/* TX Power Index 5GHz low subband */
-#define  SSB_SPROM4_TXPID5GL2		0x00FF
-#define  SSB_SPROM4_TXPID5GL2_SHIFT	0
-#define  SSB_SPROM4_TXPID5GL3		0xFF00
-#define  SSB_SPROM4_TXPID5GL3_SHIFT	8
-#define SSB_SPROM4_TXPID5GH01		0x006E 	/* TX Power Index 5GHz high subband */
-#define  SSB_SPROM4_TXPID5GH0		0x00FF
-#define  SSB_SPROM4_TXPID5GH0_SHIFT	0
-#define  SSB_SPROM4_TXPID5GH1		0xFF00
-#define  SSB_SPROM4_TXPID5GH1_SHIFT	8
-#define SSB_SPROM4_TXPID5GH23		0x0070 	/* TX Power Index 5GHz high subband */
-#define  SSB_SPROM4_TXPID5GH2		0x00FF
-#define  SSB_SPROM4_TXPID5GH2_SHIFT	0
-#define  SSB_SPROM4_TXPID5GH3		0xFF00
-#define  SSB_SPROM4_TXPID5GH3_SHIFT	8
-
-/* There are 4 blocks with power info sharing the same layout */
-#define SSB_SPROM4_PWR_INFO_CORE0	0x0080
-#define SSB_SPROM4_PWR_INFO_CORE1	0x00AE
-#define SSB_SPROM4_PWR_INFO_CORE2	0x00DC
-#define SSB_SPROM4_PWR_INFO_CORE3	0x010A
-
-#define SSB_SPROM4_2G_MAXP_ITSSI	0x00	/* 2 GHz ITSSI and 2 GHz Max Power */
-#define  SSB_SPROM4_2G_MAXP		0x00FF
-#define  SSB_SPROM4_2G_ITSSI		0xFF00
-#define  SSB_SPROM4_2G_ITSSI_SHIFT	8
-#define SSB_SPROM4_2G_PA_0		0x02	/* 2 GHz power amp */
-#define SSB_SPROM4_2G_PA_1		0x04
-#define SSB_SPROM4_2G_PA_2		0x06
-#define SSB_SPROM4_2G_PA_3		0x08
-#define SSB_SPROM4_5G_MAXP_ITSSI	0x0A	/* 5 GHz ITSSI and 5.3 GHz Max Power */
-#define  SSB_SPROM4_5G_MAXP		0x00FF
-#define  SSB_SPROM4_5G_ITSSI		0xFF00
-#define  SSB_SPROM4_5G_ITSSI_SHIFT	8
-#define SSB_SPROM4_5GHL_MAXP		0x0C	/* 5.2 GHz and 5.8 GHz Max Power */
-#define  SSB_SPROM4_5GH_MAXP		0x00FF
-#define  SSB_SPROM4_5GL_MAXP		0xFF00
-#define  SSB_SPROM4_5GL_MAXP_SHIFT	8
-#define SSB_SPROM4_5G_PA_0		0x0E	/* 5.3 GHz power amp */
-#define SSB_SPROM4_5G_PA_1		0x10
-#define SSB_SPROM4_5G_PA_2		0x12
-#define SSB_SPROM4_5G_PA_3		0x14
-#define SSB_SPROM4_5GL_PA_0		0x16	/* 5.2 GHz power amp */
-#define SSB_SPROM4_5GL_PA_1		0x18
-#define SSB_SPROM4_5GL_PA_2		0x1A
-#define SSB_SPROM4_5GL_PA_3		0x1C
-#define SSB_SPROM4_5GH_PA_0		0x1E	/* 5.8 GHz power amp */
-#define SSB_SPROM4_5GH_PA_1		0x20
-#define SSB_SPROM4_5GH_PA_2		0x22
-#define SSB_SPROM4_5GH_PA_3		0x24
-
-/* TODO: Make it deprecated */
-#define SSB_SPROM4_MAXP_BG		0x0080  /* Max Power BG in path 1 */
-#define  SSB_SPROM4_MAXP_BG_MASK	0x00FF  /* Mask for Max Power BG */
-#define  SSB_SPROM4_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
-#define  SSB_SPROM4_ITSSI_BG_SHIFT	8
-#define SSB_SPROM4_MAXP_A		0x008A  /* Max Power A in path 1 */
-#define  SSB_SPROM4_MAXP_A_MASK		0x00FF  /* Mask for Max Power A */
-#define  SSB_SPROM4_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
-#define  SSB_SPROM4_ITSSI_A_SHIFT	8
-#define SSB_SPROM4_PA0B0		0x0082	/* The paXbY locations are */
-#define SSB_SPROM4_PA0B1		0x0084	/*   only guesses */
-#define SSB_SPROM4_PA0B2		0x0086
-#define SSB_SPROM4_PA1B0		0x008E
-#define SSB_SPROM4_PA1B1		0x0090
-#define SSB_SPROM4_PA1B2		0x0092
-
-/* SPROM Revision 5 (inherits most data from rev 4) */
-#define SSB_SPROM5_CCODE		0x0044	/* Country Code (2 bytes) */
-#define SSB_SPROM5_BFLLO		0x004A	/* Boardflags (low 16 bits) */
-#define SSB_SPROM5_BFLHI		0x004C  /* Board Flags Hi */
-#define SSB_SPROM5_BFL2LO		0x004E	/* Board flags 2 (low 16 bits) */
-#define SSB_SPROM5_BFL2HI		0x0050	/* Board flags 2 Hi */
-#define SSB_SPROM5_IL0MAC		0x0052	/* 6 byte MAC address for a/b/g/n */
-#define SSB_SPROM5_GPIOA		0x0076	/* Gen. Purpose IO # 0 and 1 */
-#define  SSB_SPROM5_GPIOA_P0		0x00FF	/* Pin 0 */
-#define  SSB_SPROM5_GPIOA_P1		0xFF00	/* Pin 1 */
-#define  SSB_SPROM5_GPIOA_P1_SHIFT	8
-#define SSB_SPROM5_GPIOB		0x0078	/* Gen. Purpose IO # 2 and 3 */
-#define  SSB_SPROM5_GPIOB_P2		0x00FF	/* Pin 2 */
-#define  SSB_SPROM5_GPIOB_P3		0xFF00	/* Pin 3 */
-#define  SSB_SPROM5_GPIOB_P3_SHIFT	8
-
-/* SPROM Revision 8 */
-#define SSB_SPROM8_BOARDREV		0x0082	/* Board revision */
-#define SSB_SPROM8_BFLLO		0x0084	/* Board flags (bits 0-15) */
-#define SSB_SPROM8_BFLHI		0x0086	/* Board flags (bits 16-31) */
-#define SSB_SPROM8_BFL2LO		0x0088	/* Board flags (bits 32-47) */
-#define SSB_SPROM8_BFL2HI		0x008A	/* Board flags (bits 48-63) */
-#define SSB_SPROM8_IL0MAC		0x008C	/* 6 byte MAC address */
-#define SSB_SPROM8_CCODE		0x0092	/* 2 byte country code */
-#define SSB_SPROM8_GPIOA		0x0096	/*Gen. Purpose IO # 0 and 1 */
-#define  SSB_SPROM8_GPIOA_P0		0x00FF	/* Pin 0 */
-#define  SSB_SPROM8_GPIOA_P1		0xFF00	/* Pin 1 */
-#define  SSB_SPROM8_GPIOA_P1_SHIFT	8
-#define SSB_SPROM8_GPIOB		0x0098	/* Gen. Purpose IO # 2 and 3 */
-#define  SSB_SPROM8_GPIOB_P2		0x00FF	/* Pin 2 */
-#define  SSB_SPROM8_GPIOB_P3		0xFF00	/* Pin 3 */
-#define  SSB_SPROM8_GPIOB_P3_SHIFT	8
-#define SSB_SPROM8_LEDDC		0x009A
-#define  SSB_SPROM8_LEDDC_ON		0xFF00	/* oncount */
-#define  SSB_SPROM8_LEDDC_ON_SHIFT	8
-#define  SSB_SPROM8_LEDDC_OFF		0x00FF	/* offcount */
-#define  SSB_SPROM8_LEDDC_OFF_SHIFT	0
-#define SSB_SPROM8_ANTAVAIL		0x009C  /* Antenna available bitfields*/
-#define  SSB_SPROM8_ANTAVAIL_A		0xFF00	/* A-PHY bitfield */
-#define  SSB_SPROM8_ANTAVAIL_A_SHIFT	8
-#define  SSB_SPROM8_ANTAVAIL_BG		0x00FF	/* B-PHY and G-PHY bitfield */
-#define  SSB_SPROM8_ANTAVAIL_BG_SHIFT	0
-#define SSB_SPROM8_AGAIN01		0x009E	/* Antenna Gain (in dBm Q5.2) */
-#define  SSB_SPROM8_AGAIN0		0x00FF	/* Antenna 0 */
-#define  SSB_SPROM8_AGAIN0_SHIFT	0
-#define  SSB_SPROM8_AGAIN1		0xFF00	/* Antenna 1 */
-#define  SSB_SPROM8_AGAIN1_SHIFT	8
-#define SSB_SPROM8_AGAIN23		0x00A0
-#define  SSB_SPROM8_AGAIN2		0x00FF	/* Antenna 2 */
-#define  SSB_SPROM8_AGAIN2_SHIFT	0
-#define  SSB_SPROM8_AGAIN3		0xFF00	/* Antenna 3 */
-#define  SSB_SPROM8_AGAIN3_SHIFT	8
-#define SSB_SPROM8_TXRXC		0x00A2
-#define  SSB_SPROM8_TXRXC_TXCHAIN	0x000f
-#define  SSB_SPROM8_TXRXC_TXCHAIN_SHIFT	0
-#define  SSB_SPROM8_TXRXC_RXCHAIN	0x00f0
-#define  SSB_SPROM8_TXRXC_RXCHAIN_SHIFT	4
-#define  SSB_SPROM8_TXRXC_SWITCH	0xff00
-#define  SSB_SPROM8_TXRXC_SWITCH_SHIFT	8
-#define SSB_SPROM8_RSSIPARM2G		0x00A4	/* RSSI params for 2GHz */
-#define  SSB_SPROM8_RSSISMF2G		0x000F
-#define  SSB_SPROM8_RSSISMC2G		0x00F0
-#define  SSB_SPROM8_RSSISMC2G_SHIFT	4
-#define  SSB_SPROM8_RSSISAV2G		0x0700
-#define  SSB_SPROM8_RSSISAV2G_SHIFT	8
-#define  SSB_SPROM8_BXA2G		0x1800
-#define  SSB_SPROM8_BXA2G_SHIFT		11
-#define SSB_SPROM8_RSSIPARM5G		0x00A6	/* RSSI params for 5GHz */
-#define  SSB_SPROM8_RSSISMF5G		0x000F
-#define  SSB_SPROM8_RSSISMC5G		0x00F0
-#define  SSB_SPROM8_RSSISMC5G_SHIFT	4
-#define  SSB_SPROM8_RSSISAV5G		0x0700
-#define  SSB_SPROM8_RSSISAV5G_SHIFT	8
-#define  SSB_SPROM8_BXA5G		0x1800
-#define  SSB_SPROM8_BXA5G_SHIFT		11
-#define SSB_SPROM8_TRI25G		0x00A8	/* TX isolation 2.4&5.3GHz */
-#define  SSB_SPROM8_TRI2G		0x00FF	/* TX isolation 2.4GHz */
-#define  SSB_SPROM8_TRI5G		0xFF00	/* TX isolation 5.3GHz */
-#define  SSB_SPROM8_TRI5G_SHIFT		8
-#define SSB_SPROM8_TRI5GHL		0x00AA	/* TX isolation 5.2/5.8GHz */
-#define  SSB_SPROM8_TRI5GL		0x00FF	/* TX isolation 5.2GHz */
-#define  SSB_SPROM8_TRI5GH		0xFF00	/* TX isolation 5.8GHz */
-#define  SSB_SPROM8_TRI5GH_SHIFT	8
-#define SSB_SPROM8_RXPO			0x00AC  /* RX power offsets */
-#define  SSB_SPROM8_RXPO2G		0x00FF	/* 2GHz RX power offset */
-#define  SSB_SPROM8_RXPO2G_SHIFT	0
-#define  SSB_SPROM8_RXPO5G		0xFF00	/* 5GHz RX power offset */
-#define  SSB_SPROM8_RXPO5G_SHIFT	8
-#define SSB_SPROM8_FEM2G		0x00AE
-#define SSB_SPROM8_FEM5G		0x00B0
-#define  SSB_SROM8_FEM_TSSIPOS		0x0001
-#define  SSB_SROM8_FEM_TSSIPOS_SHIFT	0
-#define  SSB_SROM8_FEM_EXTPA_GAIN	0x0006
-#define  SSB_SROM8_FEM_EXTPA_GAIN_SHIFT	1
-#define  SSB_SROM8_FEM_PDET_RANGE	0x00F8
-#define  SSB_SROM8_FEM_PDET_RANGE_SHIFT	3
-#define  SSB_SROM8_FEM_TR_ISO		0x0700
-#define  SSB_SROM8_FEM_TR_ISO_SHIFT	8
-#define  SSB_SROM8_FEM_ANTSWLUT		0xF800
-#define  SSB_SROM8_FEM_ANTSWLUT_SHIFT	11
-#define SSB_SPROM8_THERMAL		0x00B2
-#define  SSB_SPROM8_THERMAL_OFFSET	0x00ff
-#define  SSB_SPROM8_THERMAL_OFFSET_SHIFT	0
-#define  SSB_SPROM8_THERMAL_TRESH	0xff00
-#define  SSB_SPROM8_THERMAL_TRESH_SHIFT	8
-/* Temp sense related entries */
-#define SSB_SPROM8_RAWTS		0x00B4
-#define  SSB_SPROM8_RAWTS_RAWTEMP	0x01ff
-#define  SSB_SPROM8_RAWTS_RAWTEMP_SHIFT	0
-#define  SSB_SPROM8_RAWTS_MEASPOWER	0xfe00
-#define  SSB_SPROM8_RAWTS_MEASPOWER_SHIFT	9
-#define SSB_SPROM8_OPT_CORRX		0x00B6
-#define  SSB_SPROM8_OPT_CORRX_TEMP_SLOPE	0x00ff
-#define  SSB_SPROM8_OPT_CORRX_TEMP_SLOPE_SHIFT	0
-#define  SSB_SPROM8_OPT_CORRX_TEMPCORRX	0xfc00
-#define  SSB_SPROM8_OPT_CORRX_TEMPCORRX_SHIFT	10
-#define  SSB_SPROM8_OPT_CORRX_TEMP_OPTION	0x0300
-#define  SSB_SPROM8_OPT_CORRX_TEMP_OPTION_SHIFT	8
-/* FOC: freiquency offset correction, HWIQ: H/W IOCAL enable, IQSWP: IQ CAL swap disable */
-#define SSB_SPROM8_HWIQ_IQSWP		0x00B8
-#define  SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR	0x000f
-#define  SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR_SHIFT	0
-#define  SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP	0x0010
-#define  SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP_SHIFT	4
-#define  SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL	0x0020
-#define  SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL_SHIFT	5
-#define SSB_SPROM8_TEMPDELTA		0x00BC
-#define  SSB_SPROM8_TEMPDELTA_PHYCAL	0x00ff
-#define  SSB_SPROM8_TEMPDELTA_PHYCAL_SHIFT	0
-#define  SSB_SPROM8_TEMPDELTA_PERIOD	0x0f00
-#define  SSB_SPROM8_TEMPDELTA_PERIOD_SHIFT	8
-#define  SSB_SPROM8_TEMPDELTA_HYSTERESIS	0xf000
-#define  SSB_SPROM8_TEMPDELTA_HYSTERESIS_SHIFT	12
-
-/* There are 4 blocks with power info sharing the same layout */
-#define SSB_SROM8_PWR_INFO_CORE0	0x00C0
-#define SSB_SROM8_PWR_INFO_CORE1	0x00E0
-#define SSB_SROM8_PWR_INFO_CORE2	0x0100
-#define SSB_SROM8_PWR_INFO_CORE3	0x0120
-
-#define SSB_SROM8_2G_MAXP_ITSSI		0x00
-#define  SSB_SPROM8_2G_MAXP		0x00FF
-#define  SSB_SPROM8_2G_ITSSI		0xFF00
-#define  SSB_SPROM8_2G_ITSSI_SHIFT	8
-#define SSB_SROM8_2G_PA_0		0x02	/* 2GHz power amp settings */
-#define SSB_SROM8_2G_PA_1		0x04
-#define SSB_SROM8_2G_PA_2		0x06
-#define SSB_SROM8_5G_MAXP_ITSSI		0x08	/* 5GHz ITSSI and 5.3GHz Max Power */
-#define  SSB_SPROM8_5G_MAXP		0x00FF
-#define  SSB_SPROM8_5G_ITSSI		0xFF00
-#define  SSB_SPROM8_5G_ITSSI_SHIFT	8
-#define SSB_SPROM8_5GHL_MAXP		0x0A	/* 5.2GHz and 5.8GHz Max Power */
-#define  SSB_SPROM8_5GH_MAXP		0x00FF
-#define  SSB_SPROM8_5GL_MAXP		0xFF00
-#define  SSB_SPROM8_5GL_MAXP_SHIFT	8
-#define SSB_SROM8_5G_PA_0		0x0C	/* 5.3GHz power amp settings */
-#define SSB_SROM8_5G_PA_1		0x0E
-#define SSB_SROM8_5G_PA_2		0x10
-#define SSB_SROM8_5GL_PA_0		0x12	/* 5.2GHz power amp settings */
-#define SSB_SROM8_5GL_PA_1		0x14
-#define SSB_SROM8_5GL_PA_2		0x16
-#define SSB_SROM8_5GH_PA_0		0x18	/* 5.8GHz power amp settings */
-#define SSB_SROM8_5GH_PA_1		0x1A
-#define SSB_SROM8_5GH_PA_2		0x1C
-
-/* TODO: Make it deprecated */
-#define SSB_SPROM8_MAXP_BG		0x00C0  /* Max Power 2GHz in path 1 */
-#define  SSB_SPROM8_MAXP_BG_MASK	0x00FF  /* Mask for Max Power 2GHz */
-#define  SSB_SPROM8_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
-#define  SSB_SPROM8_ITSSI_BG_SHIFT	8
-#define SSB_SPROM8_PA0B0		0x00C2	/* 2GHz power amp settings */
-#define SSB_SPROM8_PA0B1		0x00C4
-#define SSB_SPROM8_PA0B2		0x00C6
-#define SSB_SPROM8_MAXP_A		0x00C8  /* Max Power 5.3GHz */
-#define  SSB_SPROM8_MAXP_A_MASK		0x00FF  /* Mask for Max Power 5.3GHz */
-#define  SSB_SPROM8_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
-#define  SSB_SPROM8_ITSSI_A_SHIFT	8
-#define SSB_SPROM8_MAXP_AHL		0x00CA  /* Max Power 5.2/5.8GHz */
-#define  SSB_SPROM8_MAXP_AH_MASK	0x00FF  /* Mask for Max Power 5.8GHz */
-#define  SSB_SPROM8_MAXP_AL_MASK	0xFF00  /* Mask for Max Power 5.2GHz */
-#define  SSB_SPROM8_MAXP_AL_SHIFT	8
-#define SSB_SPROM8_PA1B0		0x00CC	/* 5.3GHz power amp settings */
-#define SSB_SPROM8_PA1B1		0x00CE
-#define SSB_SPROM8_PA1B2		0x00D0
-#define SSB_SPROM8_PA1LOB0		0x00D2	/* 5.2GHz power amp settings */
-#define SSB_SPROM8_PA1LOB1		0x00D4
-#define SSB_SPROM8_PA1LOB2		0x00D6
-#define SSB_SPROM8_PA1HIB0		0x00D8	/* 5.8GHz power amp settings */
-#define SSB_SPROM8_PA1HIB1		0x00DA
-#define SSB_SPROM8_PA1HIB2		0x00DC
-
-#define SSB_SPROM8_CCK2GPO		0x0140	/* CCK power offset */
-#define SSB_SPROM8_OFDM2GPO		0x0142	/* 2.4GHz OFDM power offset */
-#define SSB_SPROM8_OFDM5GPO		0x0146	/* 5.3GHz OFDM power offset */
-#define SSB_SPROM8_OFDM5GLPO		0x014A	/* 5.2GHz OFDM power offset */
-#define SSB_SPROM8_OFDM5GHPO		0x014E	/* 5.8GHz OFDM power offset */
-
-#define SSB_SPROM8_2G_MCSPO		0x0152
-#define SSB_SPROM8_5G_MCSPO		0x0162
-#define SSB_SPROM8_5GL_MCSPO		0x0172
-#define SSB_SPROM8_5GH_MCSPO		0x0182
-
-#define SSB_SPROM8_CDDPO		0x0192
-#define SSB_SPROM8_STBCPO		0x0194
-#define SSB_SPROM8_BW40PO		0x0196
-#define SSB_SPROM8_BWDUPPO		0x0198
-
-/* Values for boardflags_lo read from SPROM */
-#define SSB_BFL_BTCOEXIST		0x0001	/* implements Bluetooth coexistance */
-#define SSB_BFL_PACTRL			0x0002	/* GPIO 9 controlling the PA */
-#define SSB_BFL_AIRLINEMODE		0x0004	/* implements GPIO 13 radio disable indication */
-#define SSB_BFL_RSSI			0x0008	/* software calculates nrssi slope. */
-#define SSB_BFL_ENETSPI			0x0010	/* has ephy roboswitch spi */
-#define SSB_BFL_XTAL_NOSLOW		0x0020	/* no slow clock available */
-#define SSB_BFL_CCKHIPWR		0x0040	/* can do high power CCK transmission */
-#define SSB_BFL_ENETADM			0x0080	/* has ADMtek switch */
-#define SSB_BFL_ENETVLAN		0x0100	/* can do vlan */
-#define SSB_BFL_AFTERBURNER		0x0200	/* supports Afterburner mode */
-#define SSB_BFL_NOPCI			0x0400	/* board leaves PCI floating */
-#define SSB_BFL_FEM			0x0800	/* supports the Front End Module */
-#define SSB_BFL_EXTLNA			0x1000	/* has an external LNA */
-#define SSB_BFL_HGPA			0x2000	/* had high gain PA */
-#define SSB_BFL_BTCMOD			0x4000	/* BFL_BTCOEXIST is given in alternate GPIOs */
-#define SSB_BFL_ALTIQ			0x8000	/* alternate I/Q settings */
-
-/* Values for boardflags_hi read from SPROM */
-#define SSB_BFH_NOPA			0x0001	/* has no PA */
-#define SSB_BFH_RSSIINV			0x0002	/* RSSI uses positive slope (not TSSI) */
-#define SSB_BFH_PAREF			0x0004	/* uses the PARef LDO */
-#define SSB_BFH_3TSWITCH		0x0008	/* uses a triple throw switch shared with bluetooth */
-#define SSB_BFH_PHASESHIFT		0x0010	/* can support phase shifter */
-#define SSB_BFH_BUCKBOOST		0x0020	/* has buck/booster */
-#define SSB_BFH_FEM_BT			0x0040	/* has FEM and switch to share antenna with bluetooth */
-
-/* Values for boardflags2_lo read from SPROM */
-#define SSB_BFL2_RXBB_INT_REG_DIS	0x0001	/* external RX BB regulator present */
-#define SSB_BFL2_APLL_WAR		0x0002	/* alternative A-band PLL settings implemented */
-#define SSB_BFL2_TXPWRCTRL_EN 		0x0004	/* permits enabling TX Power Control */
-#define SSB_BFL2_2X4_DIV		0x0008	/* 2x4 diversity switch */
-#define SSB_BFL2_5G_PWRGAIN		0x0010	/* supports 5G band power gain */
-#define SSB_BFL2_PCIEWAR_OVR		0x0020	/* overrides ASPM and Clkreq settings */
-#define SSB_BFL2_CAESERS_BRD		0x0040	/* is Caesers board (unused) */
-#define SSB_BFL2_BTC3WIRE		0x0080	/* used 3-wire bluetooth coexist */
-#define SSB_BFL2_SKWRKFEM_BRD		0x0100	/* 4321mcm93 uses Skyworks FEM */
-#define SSB_BFL2_SPUR_WAR		0x0200	/* has a workaround for clock-harmonic spurs */
-#define SSB_BFL2_GPLL_WAR		0x0400	/* altenative G-band PLL settings implemented */
-
-/* Values for SSB_SPROM1_BINF_CCODE */
-enum {
-	SSB_SPROM1CCODE_WORLD = 0,
-	SSB_SPROM1CCODE_THAILAND,
-	SSB_SPROM1CCODE_ISRAEL,
-	SSB_SPROM1CCODE_JORDAN,
-	SSB_SPROM1CCODE_CHINA,
-	SSB_SPROM1CCODE_JAPAN,
-	SSB_SPROM1CCODE_USA_CANADA_ANZ,
-	SSB_SPROM1CCODE_EUROPE,
-	SSB_SPROM1CCODE_USA_LOW,
-	SSB_SPROM1CCODE_JAPAN_HIGH,
-	SSB_SPROM1CCODE_ALL,
-	SSB_SPROM1CCODE_NONE,
-};
-
-/* Address-Match values and masks (SSB_ADMATCHxxx) */
-#define SSB_ADM_TYPE			0x00000003	/* Address type */
-#define  SSB_ADM_TYPE0			0
-#define  SSB_ADM_TYPE1			1
-#define  SSB_ADM_TYPE2			2
-#define SSB_ADM_AD64			0x00000004
-#define SSB_ADM_SZ0			0x000000F8	/* Type0 size */
-#define SSB_ADM_SZ0_SHIFT		3
-#define SSB_ADM_SZ1			0x000001F8	/* Type1 size */
-#define SSB_ADM_SZ1_SHIFT		3
-#define SSB_ADM_SZ2			0x000001F8	/* Type2 size */
-#define SSB_ADM_SZ2_SHIFT		3
-#define SSB_ADM_EN			0x00000400	/* Enable */
-#define SSB_ADM_NEG			0x00000800	/* Negative decode */
-#define SSB_ADM_BASE0			0xFFFFFF00	/* Type0 base address */
-#define SSB_ADM_BASE0_SHIFT		8
-#define SSB_ADM_BASE1			0xFFFFF000	/* Type1 base address for the core */
-#define SSB_ADM_BASE1_SHIFT		12
-#define SSB_ADM_BASE2			0xFFFF0000	/* Type2 base address for the core */
-#define SSB_ADM_BASE2_SHIFT		16
-
-
-#endif /* LINUX_SSB_REGS_H_ */
diff --git a/include/linux/wl12xx.h b/include/linux/wl12xx.h
deleted file mode 100644
index 4cadb3a..0000000
--- a/include/linux/wl12xx.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * This file is part of wl12xx
- *
- * Copyright (C) 2009 Nokia Corporation
- *
- * Contact: Luciano Coelho <luciano.coelho@nokia.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- *
- */
-
-#ifndef _LINUX_WL12XX_H
-#define _LINUX_WL12XX_H
-
-#include <linux/err.h>
-
-struct wl1251_platform_data {
-	int power_gpio;
-	/* SDIO only: IRQ number if WLAN_IRQ line is used, 0 for SDIO IRQs */
-	int irq;
-	bool use_eeprom;
-};
-
-#ifdef CPTCFG_WILINK_PLATFORM_DATA
-
-int wl1251_set_platform_data(const struct wl1251_platform_data *data);
-
-struct wl1251_platform_data *wl1251_get_platform_data(void);
-
-#else
-
-static inline
-int wl1251_set_platform_data(const struct wl1251_platform_data *data)
-{
-	return -ENOSYS;
-}
-
-static inline
-struct wl1251_platform_data *wl1251_get_platform_data(void)
-{
-	return ERR_PTR(-ENODATA);
-}
-
-#endif
-
-#endif
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index c390299..d201db5 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -988,6 +988,7 @@ enum station_parameters_apply_mask {
  * @support_p2p_ps: information if station supports P2P PS mechanism
  * @he_capa: HE capabilities of station
  * @he_capa_len: the length of the HE capabilities
+ * @airtime_weight: airtime scheduler weight for this station
  */
 struct station_parameters {
 	const u8 *supported_rates;
@@ -1017,6 +1018,7 @@ struct station_parameters {
 	int support_p2p_ps;
 	const struct ieee80211_he_cap_elem *he_capa;
 	u8 he_capa_len;
+	u16 airtime_weight;
 };
 
 /**
@@ -1284,6 +1286,8 @@ struct cfg80211_tid_stats {
  * @rx_beacon_signal_avg: signal strength average (in dBm) for beacons received
  *	from this peer
  * @rx_duration: aggregate PPDU duration(usecs) for all the frames from a peer
+ * @tx_duration: aggregate PPDU duration(usecs) for all the frames to a peer
+ * @airtime_weight: current airtime scheduling weight
  * @pertid: per-TID statistics, see &struct cfg80211_tid_stats, using the last
  *	(IEEE80211_NUM_TIDS) index for MSDUs not encapsulated in QoS-MPDUs.
  *	Note that this doesn't use the @filled bit, but is used if non-NULL.
@@ -1330,12 +1334,15 @@ struct station_info {
 
 	u32 expected_throughput;
 
-	u64 rx_beacon;
+	u64 tx_duration;
 	u64 rx_duration;
+	u64 rx_beacon;
 	u8 rx_beacon_signal_avg;
 	struct cfg80211_tid_stats *pertid;
 	s8 ack_signal;
 	s8 avg_ack_signal;
+
+	u16 airtime_weight;
 };
 
 #if IS_ENABLED(CPTCFG_CFG80211)
@@ -2361,6 +2368,8 @@ enum wiphy_params_flags {
 	WIPHY_PARAM_TXQ_QUANTUM		= 1 << 8,
 };
 
+#define IEEE80211_DEFAULT_AIRTIME_WEIGHT	256
+
 /**
  * struct cfg80211_pmksa - PMK Security Association
  *
@@ -2959,6 +2968,7 @@ struct cfg80211_external_auth_params {
  *	(as advertised by the nl80211 feature flag.)
  * @get_tx_power: store the current TX power into the dbm variable;
  *	return 0 if successful
+ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
  *
  * @set_wds_peer: set the WDS peer for a WDS interface
  *
@@ -3259,6 +3269,7 @@ struct cfg80211_ops {
 				enum nl80211_tx_power_setting type, int mbm);
 	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
 				int *dbm);
+	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
 
 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
 				const u8 *addr);
@@ -3448,7 +3459,8 @@ struct cfg80211_ops {
  *	on wiphy_new(), but can be changed by the driver if it has a good
  *	reason to override the default
  * @WIPHY_FLAG_4ADDR_AP: supports 4addr mode even on AP (with a single station
- *	on a VLAN interface)
+ *	on a VLAN interface). This flag also serves an extra purpose of
+ *	supporting 4ADDR AP mode on devices which do not support AP/VLAN iftype.
  * @WIPHY_FLAG_4ADDR_STATION: supports 4addr mode even as a station
  * @WIPHY_FLAG_CONTROL_PORT_PROTOCOL: This device supports setting the
  *	control port protocol ethertype. The device also honours the
diff --git a/include/net/fq_impl.h b/include/net/fq_impl.h
index be7c0fa..2caa866 100644
--- a/include/net/fq_impl.h
+++ b/include/net/fq_impl.h
@@ -107,21 +107,23 @@ begin:
 	return skb;
 }
 
+static u32 fq_flow_idx(struct fq *fq, struct sk_buff *skb)
+{
+	u32 hash = skb_get_hash_perturb(skb, fq->perturbation);
+
+	return reciprocal_scale(hash, fq->flows_cnt);
+}
+
 static struct fq_flow *fq_flow_classify(struct fq *fq,
-					struct fq_tin *tin,
+					struct fq_tin *tin, u32 idx,
 					struct sk_buff *skb,
 					fq_flow_get_default_t get_default_func)
 {
 	struct fq_flow *flow;
-	u32 hash;
-	u32 idx;
 
 	lockdep_assert_held(&fq->lock);
 
-	hash = skb_get_hash_perturb(skb, fq->perturbation);
-	idx = reciprocal_scale(hash, fq->flows_cnt);
 	flow = &fq->flows[idx];
-
 	if (flow->tin && flow->tin != tin) {
 		flow = get_default_func(fq, tin, idx, skb);
 		tin->collisions++;
@@ -153,7 +155,7 @@ static void fq_recalc_backlog(struct fq *fq,
 }
 
 static void fq_tin_enqueue(struct fq *fq,
-			   struct fq_tin *tin,
+			   struct fq_tin *tin, u32 idx,
 			   struct sk_buff *skb,
 			   fq_skb_free_t free_func,
 			   fq_flow_get_default_t get_default_func)
@@ -163,7 +165,7 @@ static void fq_tin_enqueue(struct fq *fq,
 
 	lockdep_assert_held(&fq->lock);
 
-	flow = fq_flow_classify(fq, tin, skb, get_default_func);
+	flow = fq_flow_classify(fq, tin, idx, skb, get_default_func);
 
 	flow->tin = tin;
 	flow->backlog += skb->len;
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 8957bdc..94e831f 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -107,9 +107,15 @@
  * The driver is expected to initialize its private per-queue data for stations
  * and interfaces in the .add_interface and .sta_add ops.
  *
- * The driver can't access the queue directly. To dequeue a frame, it calls
- * ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a queue, it
- * calls the .wake_tx_queue driver op.
+ * The driver can't access the queue directly. To dequeue a frame from a
+ * txq, it calls ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a
+ * queue, it calls the .wake_tx_queue driver op.
+ *
+ * Drivers can optionally delegate responsibility for scheduling queues to
+ * mac80211, to take advantage of airtime fairness accounting. In this case, to
+ * obtain the next queue to pull frames from, the driver calls
+ * ieee80211_next_txq(). The driver is then expected to return the txq using
+ * ieee80211_return_txq().
  *
  * For AP powersave TIM handling, the driver only needs to indicate if it has
  * buffered packets in the driver specific data structures by calling
@@ -1389,6 +1395,7 @@ enum ieee80211_smps_mode {
  *
  * @power_level: requested transmit power (in dBm), backward compatibility
  *	value only that is set to the minimum of all interfaces
+ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
  *
  * @chandef: the channel definition to tune to
  * @radar_enabled: whether radar detection is enabled
@@ -1409,6 +1416,7 @@ enum ieee80211_smps_mode {
 struct ieee80211_conf {
 	u32 flags;
 	int power_level, dynamic_ps_timeout;
+	int max_antenna_gain;
 
 	u16 listen_interval;
 	u8 ps_dtim_period;
@@ -1504,6 +1512,8 @@ enum ieee80211_vif_flags {
  * @drv_priv: data area for driver use, will always be aligned to
  *	sizeof(void \*).
  * @txq: the multicast data TX queue (if driver uses the TXQ abstraction)
+ * @txqs_stopped: per AC flag to indicate that intermediate TXQs are stopped,
+ *	protected by fq->lock.
  */
 struct ieee80211_vif {
 	enum nl80211_iftype type;
@@ -1528,6 +1538,8 @@ struct ieee80211_vif {
 
 	unsigned int probe_req_reg;
 
+	bool txqs_stopped[IEEE80211_NUM_ACS];
+
 	/* must be last */
 	u8 drv_priv[0] __aligned(sizeof(void *));
 };
@@ -2127,6 +2139,12 @@ struct ieee80211_txq {
  * @IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP: The driver (or firmware) doesn't
  *	support QoS NDP for AP probing - that's most likely a driver bug.
  *
+ * @IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN: Driver does not report accurate A-MPDU
+ *	length in tx status information
+ *
+ * @IEEE80211_HW_TX_NEEDS_ALIGNED4_SKBS: Driver need aligned skbs to four-byte.
+ *	Padding will be added after ieee80211_hdr, before IV/LLC.
+ *
  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
  */
 enum ieee80211_hw_flags {
@@ -2172,6 +2190,8 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA,
 	IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP,
 	IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP,
+	IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,
+	IEEE80211_HW_TX_NEEDS_ALIGNED4_SKBS,
 
 	/* keep last, obviously */
 	NUM_IEEE80211_HW_FLAGS
@@ -2290,6 +2310,9 @@ enum ieee80211_hw_flags {
  *	supported by HW.
  * @max_nan_de_entries: maximum number of NAN DE functions supported by the
  *	device.
+ *
+ * @weight_multipler: Driver specific airtime weight multiplier used while
+ *	refilling deficit of each TXQ.
  */
 struct ieee80211_hw {
 	struct ieee80211_conf conf;
@@ -2325,6 +2348,7 @@ struct ieee80211_hw {
 	u8 n_cipher_schemes;
 	const struct ieee80211_cipher_scheme *cipher_schemes;
 	u8 max_nan_de_entries;
+	u8 weight_multiplier;
 };
 
 static inline bool _ieee80211_hw_check(struct ieee80211_hw *hw,
@@ -2453,6 +2477,40 @@ ieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,
  */
 void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
 
+/**
+ * ieee80211_hdr_padsize - get size of padding between 802.11 header and LLC
+ * @hw: the hardware
+ * @hdrlen: 802.11 header length
+ */
+static inline unsigned int
+ieee80211_hdr_padsize(struct ieee80211_hw *hw, unsigned int hdrlen)
+{
+	/*
+	 * While hdrlen is already aligned to two-byte boundaries,
+	 * simple check with & 2 will return correct padsize.
+	 */
+	if (ieee80211_hw_check(hw, TX_NEEDS_ALIGNED4_SKBS))
+		return hdrlen & 2;
+	return 0;
+}
+
+/**
+ * ieee80211_padded_hdrlen - get padded 802.11 header size
+ * @hw: the hardware
+ * @fc: frame control field in little-endian format
+ */
+static inline unsigned int
+ieee80211_padded_hdrlen(struct ieee80211_hw *hw, __le16 fc)
+{
+	unsigned int hdrlen;
+
+	hdrlen = ieee80211_hdrlen(fc);
+	hdrlen += ieee80211_hdr_padsize(hw, hdrlen);
+
+	return hdrlen;
+}
+
+
 /**
  * DOC: Hardware crypto acceleration
  *
@@ -5284,6 +5342,34 @@ void ieee80211_sta_eosp(struct ieee80211_sta *pubsta);
  */
 void ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid);
 
+/**
+ * ieee80211_sta_register_airtime - register airtime usage for a sta/tid
+ *
+ * Register airtime usage for a given sta on a given tid. The driver can call
+ * this function to notify mac80211 that a station used a certain amount of
+ * airtime. This information will be used by the TXQ scheduler to schedule
+ * stations in a way that ensures airtime fairness.
+ *
+ * The reported airtime should as a minimum include all time that is spent
+ * transmitting to the remote station, including overhead and padding, but not
+ * including time spent waiting for a TXOP. If the time is not reported by the
+ * hardware it can in some cases be calculated from the rate and known frame
+ * composition. When possible, the time should include any failed transmission
+ * attempts.
+ *
+ * The driver can either call this function synchronously for every packet or
+ * aggregate, or asynchronously as airtime usage information becomes available.
+ * TX and RX airtime can be reported together, or separately by setting one of
+ * them to 0.
+ *
+ * @pubsta: the station
+ * @tid: the TID to register airtime for
+ * @tx_airtime: airtime used during TX (in usec)
+ * @rx_airtime: airtime used during RX (in usec)
+ */
+void ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,
+				    u32 tx_airtime, u32 rx_airtime);
+
 /**
  * ieee80211_iter_keys - iterate keys programmed into the device
  * @hw: pointer obtained from ieee80211_alloc_hw()
@@ -5971,13 +6057,106 @@ void ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);
  * ieee80211_tx_dequeue - dequeue a packet from a software tx queue
  *
  * @hw: pointer as obtained from ieee80211_alloc_hw()
- * @txq: pointer obtained from station or virtual interface
+ * @txq: pointer obtained from station or virtual interface, or from
+ *	ieee80211_next_txq()
  *
  * Returns the skb if successful, %NULL if no frame was available.
  */
 struct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,
 				     struct ieee80211_txq *txq);
 
+/**
+ * ieee80211_next_txq - get next tx queue to pull packets from
+ *
+ * @hw: pointer as obtained from ieee80211_alloc_hw()
+ * @ac: AC number to return packets from.
+ *
+ * Returns the next txq if successful, %NULL if no queue is eligible. If a txq
+ * is returned, it should be returned with ieee80211_return_txq() after the
+ * driver has finished scheduling it.
+ */
+struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac);
+
+/**
+ * ieee80211_txq_schedule_start - start new scheduling round for TXQs
+ *
+ * @hw: pointer as obtained from ieee80211_alloc_hw()
+ * @ac: AC number to acquire locks for
+ *
+ * Should be called before ieee80211_next_txq() or ieee80211_return_txq().
+ */
+void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac);
+
+/* (deprecated) */
+static inline void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)
+{
+}
+
+void __ieee80211_schedule_txq(struct ieee80211_hw *hw,
+			      struct ieee80211_txq *txq, bool force);
+
+/**
+ * ieee80211_schedule_txq - schedule a TXQ for transmission
+ *
+ * @hw: pointer as obtained from ieee80211_alloc_hw()
+ * @txq: pointer obtained from station or virtual interface
+ *
+ * Schedules a TXQ for transmission if it is not already scheduled,
+ * even if mac80211 does not have any packets buffered.
+ *
+ * The driver may call this function if it has buffered packets for
+ * this TXQ internally.
+ */
+static inline void
+ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
+{
+	__ieee80211_schedule_txq(hw, txq, true);
+}
+
+/**
+ * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()
+ *
+ * @hw: pointer as obtained from ieee80211_alloc_hw()
+ * @txq: pointer obtained from station or virtual interface
+ * @force: schedule txq even if mac80211 does not have any buffered packets.
+ *
+ * The driver may set force=true if it has buffered packets for this TXQ
+ * internally.
+ */
+static inline void
+ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,
+		     bool force)
+{
+	__ieee80211_schedule_txq(hw, txq, force);
+}
+
+/**
+ * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit
+ *
+ * This function is used to check whether given txq is allowed to transmit by
+ * the airtime scheduler, and can be used by drivers to access the airtime
+ * fairness accounting without going using the scheduling order enfored by
+ * next_txq().
+ *
+ * Returns %true if the airtime scheduler thinks the TXQ should be allowed to
+ * transmit, and %false if it should be throttled. This function can also have
+ * the side effect of rotating the TXQ in the scheduler rotation, which will
+ * eventually bring the deficit to positive and allow the station to transmit
+ * again.
+ *
+ * The API ieee80211_txq_may_transmit() also ensures that TXQ list will be
+ * aligned aginst driver's own round-robin scheduler list. i.e it rotates
+ * the TXQ list till it makes the requested node becomes the first entry
+ * in TXQ list. Thus both the TXQ list and driver's list are in sync. If this
+ * function returns %true, the driver is expected to schedule packets
+ * for transmission, and then return the TXQ through ieee80211_return_txq().
+ *
+ * @hw: pointer as obtained from ieee80211_alloc_hw()
+ * @txq: pointer obtained from station or virtual interface
+ */
+bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
+				struct ieee80211_txq *txq);
+
 /**
  * ieee80211_txq_get_depth - get pending frame/byte count of given txq
  *
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index 7acc16f..c8e030f 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -2241,6 +2241,12 @@ enum nl80211_commands {
  *	association request when used with NL80211_CMD_NEW_STATION). Can be set
  *	only if %NL80211_STA_FLAG_WME is set.
  *
+ * @NL80211_ATTR_AIRTIME_WEIGHT: Station's weight when scheduled by the airtime
+ *	scheduler.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
+ *	transmit power to stay within regulatory limits. u32, dBi.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -2682,6 +2688,16 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_HE_CAPABILITY,
 
+	/* not backported yet */
+	NL80211_ATTR_FTM_RESPONDER,
+	NL80211_ATTR_FTM_RESPONDER_STATS,
+	NL80211_ATTR_TIMEOUT,
+	NL80211_ATTR_PEER_MEASUREMENTS,
+
+	NL80211_ATTR_AIRTIME_WEIGHT,
+
+	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -3052,6 +3068,9 @@ enum nl80211_sta_bss_param {
  * @NL80211_STA_INFO_ACK_SIGNAL: signal strength of the last ACK frame(u8, dBm)
  * @NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG: avg signal strength of (data)
  *	ACK frame (s8, dBm)
+ * @NL80211_STA_INFO_TX_DURATION: aggregate PPDU duration for all frames
+ *	sent to the station (u64, usec)
+ * @NL80211_STA_INFO_AIRTIME_WEIGHT: current airtime weight for station (u16)
  * @__NL80211_STA_INFO_AFTER_LAST: internal
  * @NL80211_STA_INFO_MAX: highest possible station info attribute
  */
@@ -3093,6 +3112,14 @@ enum nl80211_sta_info {
 	NL80211_STA_INFO_ACK_SIGNAL,
 	NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG,
 
+	/* not backported yet */
+	NL80211_STA_INFO_RX_MPDUS,
+	NL80211_STA_INFO_FCS_ERROR_COUNT,
+	NL80211_STA_INFO_CONNECTED_TO_GATE,
+
+	NL80211_STA_INFO_TX_DURATION,
+	NL80211_STA_INFO_AIRTIME_WEIGHT,
+
 	/* keep last */
 	__NL80211_STA_INFO_AFTER_LAST,
 	NL80211_STA_INFO_MAX = __NL80211_STA_INFO_AFTER_LAST - 1
@@ -5224,6 +5251,10 @@ enum nl80211_feature_flags {
  *	except for supported rates from the probe request content if requested
  *	by the %NL80211_SCAN_FLAG_MIN_PREQ_CONTENT flag.
  *
+ * @NL80211_EXT_FEATURE_AIRTIME_FAIRNESS: Driver supports getting airtime
+ *	fairness for transmitted packets and has enabled airtime fairness
+ *	scheduling.
+ *
  * @NUM_NL80211_EXT_FEATURES: number of extended features.
  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
  */
@@ -5260,6 +5291,12 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_SCAN_RANDOM_SN,
 	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT,
 
+	/* --- not backported yet --- */
+	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0,
+	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER,
+
+	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS,
+
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
 	MAX_NL80211_EXT_FEATURES = NUM_NL80211_EXT_FEATURES - 1
diff --git a/kconf/Makefile b/kconf/Makefile
index 9edd957..5f55857 100644
--- a/kconf/Makefile
+++ b/kconf/Makefile
@@ -1,9 +1,9 @@
-CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -DKBUILD_NO_NLS
 
 LXDIALOG := lxdialog/checklist.o lxdialog/inputbox.o lxdialog/menubox.o lxdialog/textbox.o lxdialog/util.o lxdialog/yesno.o
 
 conf: conf.o zconf.tab.o
-mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags) -DLOCALE
+mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags)
 mconf_LDFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
 mconf: CFLAGS += $(mconf_CFLAGS)
 
diff --git a/kconf/conf.c b/kconf/conf.c
index 866369f..abf73ef 100644
--- a/kconf/conf.c
+++ b/kconf/conf.c
@@ -594,40 +594,12 @@ int main(int ac, char **av)
 	case oldconfig:
 	case listnewconfig:
 	case olddefconfig:
-		conf_read(NULL);
-		break;
 	case allnoconfig:
 	case allyesconfig:
 	case allmodconfig:
 	case alldefconfig:
 	case randconfig:
-		name = getenv("KCONFIG_ALLCONFIG");
-		if (!name)
-			break;
-		if ((strcmp(name, "") != 0) && (strcmp(name, "1") != 0)) {
-			if (conf_read_simple(name, S_DEF_USER)) {
-				fprintf(stderr,
-					_("*** Can't read seed configuration \"%s\"!\n"),
-					name);
-				exit(1);
-			}
-			break;
-		}
-		switch (input_mode) {
-		case allnoconfig:	name = "allno.config"; break;
-		case allyesconfig:	name = "allyes.config"; break;
-		case allmodconfig:	name = "allmod.config"; break;
-		case alldefconfig:	name = "alldef.config"; break;
-		case randconfig:	name = "allrandom.config"; break;
-		default: break;
-		}
-		if (conf_read_simple(name, S_DEF_USER) &&
-		    conf_read_simple("all.config", S_DEF_USER)) {
-			fprintf(stderr,
-				_("*** KCONFIG_ALLCONFIG set, but no \"%s\" or \"all.config\" file found\n"),
-				name);
-			exit(1);
-		}
+		conf_read(NULL);
 		break;
 	default:
 		break;
diff --git a/kconf/confdata.c b/kconf/confdata.c
index 297b079..c3c5140 100644
--- a/kconf/confdata.c
+++ b/kconf/confdata.c
@@ -1170,6 +1170,8 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 	}
 	bool has_changed = false;
 
+	sym_clear_all_valid();
+
 	for_all_symbols(i, sym) {
 		if (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))
 			continue;
@@ -1213,8 +1215,6 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	}
 
-	sym_clear_all_valid();
-
 	/*
 	 * We have different type of choice blocks.
 	 * If curr.tri equals to mod then we can select several
diff --git a/local-symbols b/local-symbols
index 80a2ca8..46cb36f 100644
--- a/local-symbols
+++ b/local-symbols
@@ -83,6 +83,7 @@ ADM8211=
 ATH_COMMON=
 WLAN_VENDOR_ATH=
 ATH_DEBUG=
+ATH_USER_REGD=
 ATH_TRACEPOINTS=
 ATH_REG_DYNAMIC_USER_REG_HINTS=
 ATH_REG_DYNAMIC_USER_CERT_TESTING=
@@ -109,6 +110,7 @@ ATH9K_WOW=
 ATH9K_RFKILL=
 ATH9K_CHANNEL_CONTEXT=
 ATH9K_PCOEM=
+ATH9K_UBNTHSR=
 ATH9K_HTC=
 ATH9K_HTC_DEBUGFS=
 ATH9K_HWRNG=
@@ -139,6 +141,8 @@ ATH10K_SNOC=
 ATH10K_DEBUG=
 ATH10K_DEBUGFS=
 ATH10K_SPECTRAL=
+ATH10K_THERMAL=
+ATH10K_LEDS=
 ATH10K_TRACING=
 ATH10K_DFS_CERTIFIED=
 WCN36XX=
@@ -396,43 +400,6 @@ USB_IPHETH=
 USB_SIERRA_NET=
 USB_VL600=
 USB_NET_CH9200=
-SSB_POSSIBLE=
-SSB=
-SSB_SPROM=
-SSB_BLOCKIO=
-SSB_PCIHOST_POSSIBLE=
-SSB_PCIHOST=
-SSB_B43_PCI_BRIDGE=
-SSB_PCMCIAHOST_POSSIBLE=
-SSB_PCMCIAHOST=
-SSB_SDIOHOST_POSSIBLE=
-SSB_SDIOHOST=
-SSB_HOST_SOC=
-SSB_SERIAL=
-SSB_DRIVER_PCICORE_POSSIBLE=
-SSB_DRIVER_PCICORE=
-SSB_PCICORE_HOSTMODE=
-SSB_DRIVER_MIPS=
-SSB_SFLASH=
-SSB_EMBEDDED=
-SSB_DRIVER_EXTIF=
-SSB_DRIVER_GIGE=
-SSB_DRIVER_GPIO=
-BCMA_POSSIBLE=
-BCMA=
-BCMA_BLOCKIO=
-BCMA_HOST_PCI_POSSIBLE=
-BCMA_HOST_PCI=
-BCMA_HOST_SOC=
-BCMA_DRIVER_PCI=
-BCMA_DRIVER_PCI_HOSTMODE=
-BCMA_DRIVER_MIPS=
-BCMA_PFLASH=
-BCMA_SFLASH=
-BCMA_NFLASH=
-BCMA_DRIVER_GMAC_CMN=
-BCMA_DRIVER_GPIO=
-BCMA_DEBUG=
 USB_ACM=
 USB_PRINTER=
 USB_WDM=
diff --git a/net/mac80211/Kconfig b/net/mac80211/Kconfig
index 0bc6ff0..889e11d 100644
--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -5,9 +5,6 @@ config MAC80211
 	depends on CRYPTO
 	depends on CRYPTO_ARC4
 	depends on CRYPTO_AES
-	depends on CRYPTO_CCM
-	depends on CRYPTO_GCM
-	depends on CRYPTO_CMAC
 	depends on CRC32
 	---help---
 	  This option enables the hardware independent IEEE 802.11
@@ -28,20 +25,6 @@ config MAC80211_RC_MINSTREL
 	---help---
 	  This option enables the 'minstrel' TX rate control algorithm
 
-config MAC80211_RC_MINSTREL_HT
-	bool "Minstrel 802.11n support" if EXPERT
-	depends on MAC80211_RC_MINSTREL
-	default y
-	---help---
-	  This option enables the 'minstrel_ht' TX rate control algorithm
-
-config MAC80211_RC_MINSTREL_VHT
-	bool "Minstrel 802.11ac support" if EXPERT
-	depends on MAC80211_RC_MINSTREL_HT
-	default n
-	---help---
-	  This option enables VHT in the 'minstrel_ht' TX rate control algorithm
-
 choice
 	prompt "Default rate control algorithm"
 	depends on MAC80211_HAS_RC
@@ -63,8 +46,7 @@ endchoice
 
 config MAC80211_RC_DEFAULT
 	string
-	default "minstrel_ht" if MAC80211_RC_DEFAULT_MINSTREL && MAC80211_RC_MINSTREL_HT
-	default "minstrel" if MAC80211_RC_DEFAULT_MINSTREL
+	default "minstrel_ht" if MAC80211_RC_DEFAULT_MINSTREL
 	default ""
 
 endif
diff --git a/net/mac80211/Makefile b/net/mac80211/Makefile
index bd86595..edbcc19 100644
--- a/net/mac80211/Makefile
+++ b/net/mac80211/Makefile
@@ -7,7 +7,6 @@ mac80211-y := \
 	driver-ops.o \
 	sta_info.o \
 	wep.o \
-	aead_api.o \
 	wpa.o \
 	scan.o offchannel.o \
 	ht.o agg-tx.o agg-rx.o \
@@ -18,8 +17,8 @@ mac80211-y := \
 	rate.o \
 	michael.o \
 	tkip.o \
+	aes_ccm.o \
 	aes_cmac.o \
-	aes_gmac.o \
 	fils_aead.o \
 	cfg.o \
 	ethtool.o \
@@ -53,13 +52,14 @@ mac80211-$(CONFIG_PM) += pm.o
 
 CFLAGS_trace.o := -I$(src)
 
-rc80211_minstrel-y := rc80211_minstrel.o
-rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += rc80211_minstrel_debugfs.o
+rc80211_minstrel-y := \
+	rc80211_minstrel.o \
+	rc80211_minstrel_ht.o
 
-rc80211_minstrel_ht-y := rc80211_minstrel_ht.o
-rc80211_minstrel_ht-$(CPTCFG_MAC80211_DEBUGFS) += rc80211_minstrel_ht_debugfs.o
+rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += \
+	rc80211_minstrel_debugfs.o \
+	rc80211_minstrel_ht_debugfs.o
 
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
-mac80211-$(CPTCFG_MAC80211_RC_MINSTREL_HT) += $(rc80211_minstrel_ht-y)
 
 ccflags-y += -DDEBUG
diff --git a/net/mac80211/aead_api.h b/net/mac80211/aead_api.h
deleted file mode 100644
index 5e39ea8..0000000
--- a/net/mac80211/aead_api.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#ifndef _AEAD_API_H
-#define _AEAD_API_H
-
-#include <crypto/aead.h>
-#include <linux/crypto.h>
-
-struct crypto_aead *
-aead_key_setup_encrypt(const char *alg, const u8 key[],
-		       size_t key_len, size_t mic_len);
-
-int aead_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
-		 size_t aad_len, u8 *data,
-		 size_t data_len, u8 *mic);
-
-int aead_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
-		 size_t aad_len, u8 *data,
-		 size_t data_len, u8 *mic);
-
-void aead_key_free(struct crypto_aead *tfm);
-
-#endif /* _AEAD_API_H */
diff --git a/net/mac80211/aes_ccm.c b/net/mac80211/aes_ccm.c
new file mode 100644
index 0000000..4f60182
--- /dev/null
+++ b/net/mac80211/aes_ccm.c
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2003-2004, Instant802 Networks, Inc.
+ * Copyright 2005-2006, Devicescape Software, Inc.
+ *
+ * Rewrite: Copyright (C) 2013 Linaro Ltd <ard.biesheuvel@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <crypto/aead.h>
+#include <crypto/aes.h>
+
+#include <net/mac80211.h>
+#include "key.h"
+#include "aes_ccm.h"
+
+static void aes_ccm_prepare(struct crypto_cipher *tfm, u8 *b_0, u8 *aad, u8 *s_0,
+			    u8 *a, u8 *b)
+{
+	int i;
+
+	crypto_cipher_encrypt_one(tfm, b, b_0);
+
+	/* Extra Authenticate-only data (always two AES blocks) */
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		aad[i] ^= b[i];
+	crypto_cipher_encrypt_one(tfm, b, aad);
+
+	aad += AES_BLOCK_SIZE;
+
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		aad[i] ^= b[i];
+	crypto_cipher_encrypt_one(tfm, a, aad);
+
+	/* Mask out bits from auth-only-b_0 */
+	b_0[0] &= 0x07;
+
+	/* S_0 is used to encrypt T (= MIC) */
+	b_0[14] = 0;
+	b_0[15] = 0;
+	crypto_cipher_encrypt_one(tfm, s_0, b_0);
+}
+
+
+void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
+			       u8 *data, size_t data_len, u8 *mic,
+			       size_t mic_len)
+{
+	int i, j, last_len, num_blocks;
+	u8 b[AES_BLOCK_SIZE];
+	u8 s_0[AES_BLOCK_SIZE];
+	u8 e[AES_BLOCK_SIZE];
+	u8 *pos, *cpos;
+
+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
+	last_len = data_len % AES_BLOCK_SIZE;
+	aes_ccm_prepare(tfm, b_0, aad, s_0, b, b);
+
+	/* Process payload blocks */
+	pos = data;
+	cpos = data;
+	for (j = 1; j <= num_blocks; j++) {
+		int blen = (j == num_blocks && last_len) ?
+			last_len : AES_BLOCK_SIZE;
+
+		/* Authentication followed by encryption */
+		for (i = 0; i < blen; i++)
+			b[i] ^= pos[i];
+		crypto_cipher_encrypt_one(tfm, b, b);
+
+		b_0[14] = (j >> 8) & 0xff;
+		b_0[15] = j & 0xff;
+		crypto_cipher_encrypt_one(tfm, e, b_0);
+		for (i = 0; i < blen; i++)
+			*cpos++ = *pos++ ^ e[i];
+	}
+
+	for (i = 0; i < mic_len; i++)
+		mic[i] = b[i] ^ s_0[i];
+}
+
+int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
+			      u8 *data, size_t data_len, u8 *mic,
+			      size_t mic_len)
+{
+	int i, j, last_len, num_blocks;
+	u8 *pos, *cpos;
+	u8 a[AES_BLOCK_SIZE];
+	u8 b[AES_BLOCK_SIZE];
+	u8 s_0[AES_BLOCK_SIZE];
+
+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
+	last_len = data_len % AES_BLOCK_SIZE;
+	aes_ccm_prepare(tfm, b_0, aad, s_0, a, b);
+
+	/* Process payload blocks */
+	cpos = data;
+	pos = data;
+	for (j = 1; j <= num_blocks; j++) {
+		int blen = (j == num_blocks && last_len) ?
+			last_len : AES_BLOCK_SIZE;
+
+		/* Decryption followed by authentication */
+		b_0[14] = (j >> 8) & 0xff;
+		b_0[15] = j & 0xff;
+		crypto_cipher_encrypt_one(tfm, b, b_0);
+		for (i = 0; i < blen; i++) {
+			*pos = *cpos++ ^ b[i];
+			a[i] ^= *pos++;
+		}
+		crypto_cipher_encrypt_one(tfm, a, a);
+	}
+
+	for (i = 0; i < mic_len; i++) {
+		if ((mic[i] ^ s_0[i]) != a[i])
+			return -1;
+	}
+
+	return 0;
+}
+
+struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[],
+						      size_t key_len,
+						      size_t mic_len)
+{
+	struct crypto_cipher *tfm;
+
+	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
+	if (!IS_ERR(tfm))
+		crypto_cipher_setkey(tfm, key, key_len);
+
+	return tfm;
+}
+
+
+void ieee80211_aes_key_free(struct crypto_cipher *tfm)
+{
+	crypto_free_cipher(tfm);
+}
diff --git a/net/mac80211/aes_ccm.h b/net/mac80211/aes_ccm.h
index e9b7ca0..cdc6e35 100644
--- a/net/mac80211/aes_ccm.h
+++ b/net/mac80211/aes_ccm.h
@@ -10,39 +10,17 @@
 #ifndef AES_CCM_H
 #define AES_CCM_H
 
-#include "aead_api.h"
-
-#define CCM_AAD_LEN	32
-
-static inline struct crypto_aead *
-ieee80211_aes_key_setup_encrypt(const u8 key[], size_t key_len, size_t mic_len)
-{
-	return aead_key_setup_encrypt("ccm(aes)", key, key_len, mic_len);
-}
-
-static inline int
-ieee80211_aes_ccm_encrypt(struct crypto_aead *tfm,
-			  u8 *b_0, u8 *aad, u8 *data,
-			  size_t data_len, u8 *mic)
-{
-	return aead_encrypt(tfm, b_0, aad + 2,
-			    be16_to_cpup((__be16 *)aad),
-			    data, data_len, mic);
-}
-
-static inline int
-ieee80211_aes_ccm_decrypt(struct crypto_aead *tfm,
-			  u8 *b_0, u8 *aad, u8 *data,
-			  size_t data_len, u8 *mic)
-{
-	return aead_decrypt(tfm, b_0, aad + 2,
-			    be16_to_cpup((__be16 *)aad),
-			    data, data_len, mic);
-}
-
-static inline void ieee80211_aes_key_free(struct crypto_aead *tfm)
-{
-	return aead_key_free(tfm);
-}
+#include <linux/crypto.h>
+
+struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[],
+						      size_t key_len,
+						      size_t mic_len);
+void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
+			       u8 *data, size_t data_len, u8 *mic,
+			       size_t mic_len);
+int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *b_0, u8 *aad,
+			      u8 *data, size_t data_len, u8 *mic,
+			      size_t mic_len);
+void ieee80211_aes_key_free(struct crypto_cipher *tfm);
 
 #endif /* AES_CCM_H */
diff --git a/net/mac80211/aes_cmac.c b/net/mac80211/aes_cmac.c
index 2fb6558..d0bd5ff 100644
--- a/net/mac80211/aes_cmac.c
+++ b/net/mac80211/aes_cmac.c
@@ -22,50 +22,126 @@
 #define CMAC_TLEN_256 16 /* CMAC TLen = 128 bits (16 octets) */
 #define AAD_LEN 20
 
-static const u8 zero[CMAC_TLEN_256];
 
-void ieee80211_aes_cmac(struct crypto_shash *tfm, const u8 *aad,
-			const u8 *data, size_t data_len, u8 *mic)
+void gf_mulx(u8 *pad)
+{
+	int i, carry;
+
+	carry = pad[0] & 0x80;
+	for (i = 0; i < AES_BLOCK_SIZE - 1; i++)
+		pad[i] = (pad[i] << 1) | (pad[i + 1] >> 7);
+	pad[AES_BLOCK_SIZE - 1] <<= 1;
+	if (carry)
+		pad[AES_BLOCK_SIZE - 1] ^= 0x87;
+}
+
+void aes_cmac_vector(struct crypto_cipher *tfm, size_t num_elem,
+		     const u8 *addr[], const size_t *len, u8 *mac,
+		     size_t mac_len)
 {
-	SHASH_DESC_ON_STACK(desc, tfm);
-	u8 out[AES_BLOCK_SIZE];
+	u8 cbc[AES_BLOCK_SIZE], pad[AES_BLOCK_SIZE];
+	const u8 *pos, *end;
+	size_t i, e, left, total_len;
+
+	memset(cbc, 0, AES_BLOCK_SIZE);
+
+	total_len = 0;
+	for (e = 0; e < num_elem; e++)
+		total_len += len[e];
+	left = total_len;
+
+	e = 0;
+	pos = addr[0];
+	end = pos + len[0];
+
+	while (left >= AES_BLOCK_SIZE) {
+		for (i = 0; i < AES_BLOCK_SIZE; i++) {
+			cbc[i] ^= *pos++;
+			if (pos >= end) {
+				e++;
+				pos = addr[e];
+				end = pos + len[e];
+			}
+		}
+		if (left > AES_BLOCK_SIZE)
+			crypto_cipher_encrypt_one(tfm, cbc, cbc);
+		left -= AES_BLOCK_SIZE;
+	}
 
-	desc->tfm = tfm;
+	memset(pad, 0, AES_BLOCK_SIZE);
+	crypto_cipher_encrypt_one(tfm, pad, pad);
+	gf_mulx(pad);
 
-	crypto_shash_init(desc);
-	crypto_shash_update(desc, aad, AAD_LEN);
-	crypto_shash_update(desc, data, data_len - CMAC_TLEN);
-	crypto_shash_finup(desc, zero, CMAC_TLEN, out);
+	if (left || total_len == 0) {
+		for (i = 0; i < left; i++) {
+			cbc[i] ^= *pos++;
+			if (pos >= end) {
+				e++;
+				pos = addr[e];
+				end = pos + len[e];
+			}
+		}
+		cbc[left] ^= 0x80;
+		gf_mulx(pad);
+	}
 
-	memcpy(mic, out, CMAC_TLEN);
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		pad[i] ^= cbc[i];
+	crypto_cipher_encrypt_one(tfm, pad, pad);
+	memcpy(mac, pad, mac_len);
 }
 
-void ieee80211_aes_cmac_256(struct crypto_shash *tfm, const u8 *aad,
+
+void ieee80211_aes_cmac(struct crypto_cipher *tfm, const u8 *aad,
+			const u8 *data, size_t data_len, u8 *mic)
+{
+	const u8 *addr[3];
+	size_t len[3];
+	u8 zero[CMAC_TLEN];
+
+	memset(zero, 0, CMAC_TLEN);
+	addr[0] = aad;
+	len[0] = AAD_LEN;
+	addr[1] = data;
+	len[1] = data_len - CMAC_TLEN;
+	addr[2] = zero;
+	len[2] = CMAC_TLEN;
+
+	aes_cmac_vector(tfm, 3, addr, len, mic, CMAC_TLEN);
+}
+
+void ieee80211_aes_cmac_256(struct crypto_cipher *tfm, const u8 *aad,
 			    const u8 *data, size_t data_len, u8 *mic)
 {
-	SHASH_DESC_ON_STACK(desc, tfm);
+	const u8 *addr[3];
+	size_t len[3];
+	u8 zero[CMAC_TLEN_256];
 
-	desc->tfm = tfm;
+	memset(zero, 0, CMAC_TLEN_256);
+	addr[0] = aad;
+	len[0] = AAD_LEN;
+	addr[1] = data;
+	len[1] = data_len - CMAC_TLEN_256;
+	addr[2] = zero;
+	len[2] = CMAC_TLEN_256;
 
-	crypto_shash_init(desc);
-	crypto_shash_update(desc, aad, AAD_LEN);
-	crypto_shash_update(desc, data, data_len - CMAC_TLEN_256);
-	crypto_shash_finup(desc, zero, CMAC_TLEN_256, mic);
+	aes_cmac_vector(tfm, 3, addr, len, mic, CMAC_TLEN_256);
 }
 
-struct crypto_shash *ieee80211_aes_cmac_key_setup(const u8 key[],
-						  size_t key_len)
+struct crypto_cipher *ieee80211_aes_cmac_key_setup(const u8 key[],
+						   size_t key_len)
 {
-	struct crypto_shash *tfm;
+	struct crypto_cipher *tfm;
 
-	tfm = crypto_alloc_shash("cmac(aes)", 0, 0);
+	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
 	if (!IS_ERR(tfm))
-		crypto_shash_setkey(tfm, key, key_len);
+		crypto_cipher_setkey(tfm, key, key_len);
 
 	return tfm;
 }
 
-void ieee80211_aes_cmac_key_free(struct crypto_shash *tfm)
+
+void ieee80211_aes_cmac_key_free(struct crypto_cipher *tfm)
 {
-	crypto_free_shash(tfm);
+	crypto_free_cipher(tfm);
 }
diff --git a/net/mac80211/aes_cmac.h b/net/mac80211/aes_cmac.h
index fef531f..3702041 100644
--- a/net/mac80211/aes_cmac.h
+++ b/net/mac80211/aes_cmac.h
@@ -10,14 +10,13 @@
 #define AES_CMAC_H
 
 #include <linux/crypto.h>
-#include <crypto/hash.h>
 
-struct crypto_shash *ieee80211_aes_cmac_key_setup(const u8 key[],
-						  size_t key_len);
-void ieee80211_aes_cmac(struct crypto_shash *tfm, const u8 *aad,
+struct crypto_cipher *ieee80211_aes_cmac_key_setup(const u8 key[],
+						   size_t key_len);
+void ieee80211_aes_cmac(struct crypto_cipher *tfm, const u8 *aad,
 			const u8 *data, size_t data_len, u8 *mic);
-void ieee80211_aes_cmac_256(struct crypto_shash *tfm, const u8 *aad,
+void ieee80211_aes_cmac_256(struct crypto_cipher *tfm, const u8 *aad,
 			    const u8 *data, size_t data_len, u8 *mic);
-void ieee80211_aes_cmac_key_free(struct crypto_shash *tfm);
+void ieee80211_aes_cmac_key_free(struct crypto_cipher *tfm);
 
 #endif /* AES_CMAC_H */
diff --git a/net/mac80211/aead_api.c b/net/mac80211/aes_gcm.c
similarity index 54%
rename from net/mac80211/aead_api.c
rename to net/mac80211/aes_gcm.c
index 160f9df..8a4397c 100644
--- a/net/mac80211/aead_api.c
+++ b/net/mac80211/aes_gcm.c
@@ -1,10 +1,6 @@
 /*
- * Copyright 2003-2004, Instant802 Networks, Inc.
- * Copyright 2005-2006, Devicescape Software, Inc.
  * Copyright 2014-2015, Qualcomm Atheros, Inc.
  *
- * Rewrite: Copyright (C) 2013 Linaro Ltd <ard.biesheuvel@linaro.org>
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -13,46 +9,44 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/err.h>
-#include <linux/scatterlist.h>
 #include <crypto/aead.h>
 
-#include "aead_api.h"
+#include <net/mac80211.h>
+#include "key.h"
+#include "aes_gcm.h"
 
-int aead_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad, size_t aad_len,
-		 u8 *data, size_t data_len, u8 *mic)
+int ieee80211_aes_gcm_encrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
+			      u8 *data, size_t data_len, u8 *mic)
 {
-	size_t mic_len = crypto_aead_authsize(tfm);
 	struct scatterlist sg[3];
 	struct aead_request *aead_req;
 	int reqsize = sizeof(*aead_req) + crypto_aead_reqsize(tfm);
 	u8 *__aad;
 
-	aead_req = kzalloc(reqsize + aad_len, GFP_ATOMIC);
+	aead_req = kzalloc(reqsize + GCM_AAD_LEN, GFP_ATOMIC);
 	if (!aead_req)
 		return -ENOMEM;
 
 	__aad = (u8 *)aead_req + reqsize;
-	memcpy(__aad, aad, aad_len);
+	memcpy(__aad, aad, GCM_AAD_LEN);
 
 	sg_init_table(sg, 3);
-	sg_set_buf(&sg[0], __aad, aad_len);
+	sg_set_buf(&sg[0], &__aad[2], be16_to_cpup((__be16 *)__aad));
 	sg_set_buf(&sg[1], data, data_len);
-	sg_set_buf(&sg[2], mic, mic_len);
+	sg_set_buf(&sg[2], mic, IEEE80211_GCMP_MIC_LEN);
 
 	aead_request_set_tfm(aead_req, tfm);
-	aead_request_set_crypt(aead_req, sg, sg, data_len, b_0);
+	aead_request_set_crypt(aead_req, sg, sg, data_len, j_0);
 	aead_request_set_ad(aead_req, sg[0].length);
 
 	crypto_aead_encrypt(aead_req);
 	kzfree(aead_req);
-
 	return 0;
 }
 
-int aead_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad, size_t aad_len,
-		 u8 *data, size_t data_len, u8 *mic)
+int ieee80211_aes_gcm_decrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
+			      u8 *data, size_t data_len, u8 *mic)
 {
-	size_t mic_len = crypto_aead_authsize(tfm);
 	struct scatterlist sg[3];
 	struct aead_request *aead_req;
 	int reqsize = sizeof(*aead_req) + crypto_aead_reqsize(tfm);
@@ -62,20 +56,21 @@ int aead_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad, size_t aad_len,
 	if (data_len == 0)
 		return -EINVAL;
 
-	aead_req = kzalloc(reqsize + aad_len, GFP_ATOMIC);
+	aead_req = kzalloc(reqsize + GCM_AAD_LEN, GFP_ATOMIC);
 	if (!aead_req)
 		return -ENOMEM;
 
 	__aad = (u8 *)aead_req + reqsize;
-	memcpy(__aad, aad, aad_len);
+	memcpy(__aad, aad, GCM_AAD_LEN);
 
 	sg_init_table(sg, 3);
-	sg_set_buf(&sg[0], __aad, aad_len);
+	sg_set_buf(&sg[0], &__aad[2], be16_to_cpup((__be16 *)__aad));
 	sg_set_buf(&sg[1], data, data_len);
-	sg_set_buf(&sg[2], mic, mic_len);
+	sg_set_buf(&sg[2], mic, IEEE80211_GCMP_MIC_LEN);
 
 	aead_request_set_tfm(aead_req, tfm);
-	aead_request_set_crypt(aead_req, sg, sg, data_len + mic_len, b_0);
+	aead_request_set_crypt(aead_req, sg, sg,
+			       data_len + IEEE80211_GCMP_MIC_LEN, j_0);
 	aead_request_set_ad(aead_req, sg[0].length);
 
 	err = crypto_aead_decrypt(aead_req);
@@ -84,21 +79,20 @@ int aead_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad, size_t aad_len,
 	return err;
 }
 
-struct crypto_aead *
-aead_key_setup_encrypt(const char *alg, const u8 key[],
-		       size_t key_len, size_t mic_len)
+struct crypto_aead *ieee80211_aes_gcm_key_setup_encrypt(const u8 key[],
+							size_t key_len)
 {
 	struct crypto_aead *tfm;
 	int err;
 
-	tfm = crypto_alloc_aead(alg, 0, CRYPTO_ALG_ASYNC);
+	tfm = crypto_alloc_aead("gcm(aes)", 0, CRYPTO_ALG_ASYNC);
 	if (IS_ERR(tfm))
 		return tfm;
 
 	err = crypto_aead_setkey(tfm, key, key_len);
 	if (err)
 		goto free_aead;
-	err = crypto_aead_setauthsize(tfm, mic_len);
+	err = crypto_aead_setauthsize(tfm, IEEE80211_GCMP_MIC_LEN);
 	if (err)
 		goto free_aead;
 
@@ -109,7 +103,7 @@ free_aead:
 	return ERR_PTR(err);
 }
 
-void aead_key_free(struct crypto_aead *tfm)
+void ieee80211_aes_gcm_key_free(struct crypto_aead *tfm)
 {
 	crypto_free_aead(tfm);
 }
diff --git a/net/mac80211/aes_gcm.h b/net/mac80211/aes_gcm.h
index d2b0960..6ab67e4 100644
--- a/net/mac80211/aes_gcm.h
+++ b/net/mac80211/aes_gcm.h
@@ -9,38 +9,30 @@
 #ifndef AES_GCM_H
 #define AES_GCM_H
 
-#include "aead_api.h"
+#include <linux/crypto.h>
 
-#define GCM_AAD_LEN	32
-
-static inline int ieee80211_aes_gcm_encrypt(struct crypto_aead *tfm,
-					    u8 *j_0, u8 *aad,  u8 *data,
-					    size_t data_len, u8 *mic)
+static inline void
+ieee80211_aes_gcm_encrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
+			  u8 *data, size_t data_len, u8 *mic)
 {
-	return aead_encrypt(tfm, j_0, aad + 2,
-			    be16_to_cpup((__be16 *)aad),
-			    data, data_len, mic);
 }
 
-static inline int ieee80211_aes_gcm_decrypt(struct crypto_aead *tfm,
-					    u8 *j_0, u8 *aad, u8 *data,
-					    size_t data_len, u8 *mic)
+static inline int
+ieee80211_aes_gcm_decrypt(struct crypto_aead *tfm, u8 *j_0, u8 *aad,
+			  u8 *data, size_t data_len, u8 *mic)
 {
-	return aead_decrypt(tfm, j_0, aad + 2,
-			    be16_to_cpup((__be16 *)aad),
-			    data, data_len, mic);
+    return -EOPNOTSUPP;
 }
 
 static inline struct crypto_aead *
 ieee80211_aes_gcm_key_setup_encrypt(const u8 key[], size_t key_len)
 {
-	return aead_key_setup_encrypt("gcm(aes)", key,
-				      key_len, IEEE80211_GCMP_MIC_LEN);
+    return NULL;
 }
 
-static inline void ieee80211_aes_gcm_key_free(struct crypto_aead *tfm)
+static inline void
+ieee80211_aes_gcm_key_free(struct crypto_aead *tfm)
 {
-	return aead_key_free(tfm);
 }
 
 #endif /* AES_GCM_H */
diff --git a/net/mac80211/aes_gmac.h b/net/mac80211/aes_gmac.h
index 32e6442..0b8fee6 100644
--- a/net/mac80211/aes_gmac.h
+++ b/net/mac80211/aes_gmac.h
@@ -15,10 +15,22 @@
 #define GMAC_MIC_LEN	16
 #define GMAC_NONCE_LEN	12
 
-struct crypto_aead *ieee80211_aes_gmac_key_setup(const u8 key[],
-						 size_t key_len);
-int ieee80211_aes_gmac(struct crypto_aead *tfm, const u8 *aad, u8 *nonce,
-		       const u8 *data, size_t data_len, u8 *mic);
-void ieee80211_aes_gmac_key_free(struct crypto_aead *tfm);
+static inline struct crypto_aead *
+ieee80211_aes_gmac_key_setup(const u8 key[], size_t key_len)
+{
+	return NULL;
+}
+
+static inline int
+ieee80211_aes_gmac(struct crypto_aead *tfm, const u8 *aad, u8 *nonce,
+		   const u8 *data, size_t data_len, u8 *mic)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void
+ieee80211_aes_gmac_key_free(struct crypto_aead *tfm)
+{
+}
 
 #endif /* AES_GMAC_H */
diff --git a/net/mac80211/agg-tx.c b/net/mac80211/agg-tx.c
index 54821fb..2c4cd41 100644
--- a/net/mac80211/agg-tx.c
+++ b/net/mac80211/agg-tx.c
@@ -229,7 +229,7 @@ ieee80211_agg_start_txq(struct sta_info *sta, int tid, bool enable)
 	clear_bit(IEEE80211_TXQ_STOP, &txqi->flags);
 	local_bh_disable();
 	rcu_read_lock();
-	drv_wake_tx_queue(sta->sdata->local, txqi);
+	schedule_and_wake_txq(sta->sdata->local, txqi);
 	rcu_read_unlock();
 	local_bh_enable();
 }
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index dc4d682..5d741c2 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1067,7 +1067,6 @@ static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
 	sdata->u.ap.driver_smps_mode = IEEE80211_SMPS_OFF;
 
 	__sta_info_flush(sdata, true);
-	ieee80211_free_keys(sdata, true);
 
 	sdata->vif.bss_conf.enable_beacon = false;
 	sdata->vif.bss_conf.ssid_len = 0;
@@ -1435,6 +1434,9 @@ static int sta_apply_parameters(struct ieee80211_local *local,
 	if (ieee80211_vif_is_mesh(&sdata->vif))
 		sta_apply_mesh_params(local, sta, params);
 
+	if (params->airtime_weight)
+		sta->airtime_weight = params->airtime_weight;
+
 	/* set the STA state after all sta info from usermode has been set */
 	if (test_sta_flag(sta, WLAN_STA_TDLS_PEER) ||
 	    set & BIT(NL80211_STA_FLAG_ASSOCIATED)) {
@@ -2238,7 +2240,7 @@ static int ieee80211_scan(struct wiphy *wiphy,
 		 * the  frames sent while scanning on other channel will be
 		 * lost)
 		 */
-		if (sdata->u.ap.beacon &&
+		if (0 && sdata->u.ap.beacon &&
 		    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||
 		     !(req->flags & NL80211_SCAN_FLAG_AP)))
 			return -EOPNOTSUPP;
@@ -2503,6 +2505,19 @@ static int ieee80211_get_tx_power(struct wiphy *wiphy,
 	return 0;
 }
 
+static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
+{
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+
+	if (dbi < 0)
+		return -EINVAL;
+
+	local->user_antenna_gain = dbi;
+	ieee80211_hw_config(local, 0);
+
+	return 0;
+}
+
 static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
 				  const u8 *addr)
 {
@@ -3870,6 +3885,7 @@ const struct cfg80211_ops mac80211_config_ops = {
 	.set_wiphy_params = ieee80211_set_wiphy_params,
 	.set_tx_power = ieee80211_set_tx_power,
 	.get_tx_power = ieee80211_get_tx_power,
+	.set_antenna_gain = ieee80211_set_antenna_gain,
 	.set_wds_peer = ieee80211_set_wds_peer,
 	.rfkill_poll = ieee80211_rfkill_poll,
 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index 927319d..d77f3e4 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -214,6 +214,8 @@ static const char *hw_flag_names[] = {
 	FLAG(SUPPORTS_TDLS_BUFFER_STA),
 	FLAG(DEAUTH_NEED_MGD_TX_PREP),
 	FLAG(DOESNT_SUPPORT_QOS_NDP),
+	FLAG(TX_STATUS_NO_AMPDU_LEN),
+	FLAG(TX_NEEDS_ALIGNED4_SKBS),
 #undef FLAG
 };
 
@@ -379,6 +381,9 @@ void debugfs_hw_add(struct ieee80211_local *local)
 	if (local->ops->wake_tx_queue)
 		DEBUGFS_ADD_MODE(aqm, 0600);
 
+	debugfs_create_u16("airtime_flags", 0600,
+			   phyd, &local->airtime_flags);
+
 	statsd = debugfs_create_dir("statistics", phyd);
 
 	/* if the dir failed, don't put all the other things into the root! */
diff --git a/net/mac80211/debugfs_sta.c b/net/mac80211/debugfs_sta.c
index 4105081..4b48d18 100644
--- a/net/mac80211/debugfs_sta.c
+++ b/net/mac80211/debugfs_sta.c
@@ -178,9 +178,9 @@ static ssize_t sta_aqm_read(struct file *file, char __user *userbuf,
 			       txqi->tin.tx_bytes,
 			       txqi->tin.tx_packets,
 			       txqi->flags,
-			       txqi->flags & (1<<IEEE80211_TXQ_STOP) ? "STOP" : "RUN",
-			       txqi->flags & (1<<IEEE80211_TXQ_AMPDU) ? " AMPDU" : "",
-			       txqi->flags & (1<<IEEE80211_TXQ_NO_AMSDU) ? " NO-AMSDU" : "");
+			       test_bit(IEEE80211_TXQ_STOP, &txqi->flags) ? "STOP" : "RUN",
+			       test_bit(IEEE80211_TXQ_AMPDU, &txqi->flags) ? " AMPDU" : "",
+			       test_bit(IEEE80211_TXQ_NO_AMSDU, &txqi->flags) ? " NO-AMSDU" : "");
 	}
 
 	rcu_read_unlock();
@@ -192,6 +192,64 @@ static ssize_t sta_aqm_read(struct file *file, char __user *userbuf,
 }
 STA_OPS(aqm);
 
+static ssize_t sta_airtime_read(struct file *file, char __user *userbuf,
+				size_t count, loff_t *ppos)
+{
+	struct sta_info *sta = file->private_data;
+	struct ieee80211_local *local = sta->sdata->local;
+	size_t bufsz = 200;
+	char *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;
+	u64 rx_airtime = 0, tx_airtime = 0;
+	s64 deficit[IEEE80211_NUM_ACS];
+	ssize_t rv;
+	int ac;
+
+	if (!buf)
+		return -ENOMEM;
+
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+		spin_lock_bh(&local->active_txq_lock[ac]);
+		rx_airtime += sta->airtime[ac].rx_airtime;
+		tx_airtime += sta->airtime[ac].tx_airtime;
+		deficit[ac] = sta->airtime[ac].deficit;
+		spin_unlock_bh(&local->active_txq_lock[ac]);
+	}
+
+	p += scnprintf(p, bufsz + buf - p,
+		"RX: %llu us\nTX: %llu us\nWeight: %u\n"
+		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
+		rx_airtime,
+		tx_airtime,
+		sta->airtime_weight,
+		deficit[0],
+		deficit[1],
+		deficit[2],
+		deficit[3]);
+
+	rv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
+	kfree(buf);
+	return rv;
+}
+
+static ssize_t sta_airtime_write(struct file *file, const char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct sta_info *sta = file->private_data;
+	struct ieee80211_local *local = sta->sdata->local;
+	int ac;
+
+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+		spin_lock_bh(&local->active_txq_lock[ac]);
+		sta->airtime[ac].rx_airtime = 0;
+		sta->airtime[ac].tx_airtime = 0;
+		sta->airtime[ac].deficit = sta->airtime_weight;
+		spin_unlock_bh(&local->active_txq_lock[ac]);
+	}
+
+	return count;
+}
+STA_OPS_RW(airtime);
+
 static ssize_t sta_agg_status_read(struct file *file, char __user *userbuf,
 					size_t count, loff_t *ppos)
 {
@@ -546,6 +604,10 @@ void ieee80211_sta_debugfs_add(struct sta_info *sta)
 	if (local->ops->wake_tx_queue)
 		DEBUGFS_ADD(aqm);
 
+	if (wiphy_ext_feature_isset(local->hw.wiphy,
+				    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
+		DEBUGFS_ADD(airtime);
+
 	if (sizeof(sta->driver_buffered_tids) == sizeof(u32))
 		debugfs_create_x32("driver_buffered_tids", 0400,
 				   sta->debugfs_dir,
diff --git a/net/mac80211/driver-ops.h b/net/mac80211/driver-ops.h
index 434f5ec..b2a0ca8 100644
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@ -1166,6 +1166,9 @@ static inline void drv_wake_tx_queue(struct ieee80211_local *local,
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(txq->txq.vif);
 
+	if (local->in_reconfig)
+		return;
+
 	if (!check_sdata_in_driver(sdata))
 		return;
 
@@ -1173,6 +1176,13 @@ static inline void drv_wake_tx_queue(struct ieee80211_local *local,
 	local->ops->wake_tx_queue(&local->hw, &txq->txq);
 }
 
+static inline void schedule_and_wake_txq(struct ieee80211_local *local,
+					 struct txq_info *txqi)
+{
+	ieee80211_schedule_txq(&local->hw, &txqi->txq);
+	drv_wake_tx_queue(local, txqi);
+}
+
 static inline int drv_start_nan(struct ieee80211_local *local,
 				struct ieee80211_sub_if_data *sdata,
 				struct cfg80211_nan_conf *conf)
diff --git a/net/mac80211/fils_aead.c b/net/mac80211/fils_aead.c
index d0810f5..1c43290 100644
--- a/net/mac80211/fils_aead.c
+++ b/net/mac80211/fils_aead.c
@@ -1,4 +1,4 @@
-#if LINUX_VERSION_IS_GEQ(4,3,0)
+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
 /*
  * FILS AEAD for (Re)Association Request/Response frames
  * Copyright 2016, Qualcomm Atheros, Inc.
diff --git a/net/mac80211/fils_aead.h b/net/mac80211/fils_aead.h
index 7f1398e..c0546e5 100644
--- a/net/mac80211/fils_aead.h
+++ b/net/mac80211/fils_aead.h
@@ -10,7 +10,7 @@
 #ifndef FILS_AEAD_H
 #define FILS_AEAD_H
 
-#if LINUX_VERSION_IS_GEQ(4,3,0)
+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
 int fils_encrypt_assoc_req(struct sk_buff *skb,
 			   struct ieee80211_mgd_assoc_data *assoc_data);
 int fils_decrypt_assoc_resp(struct ieee80211_sub_if_data *sdata,
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 789ce53..c1b045f 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -179,6 +179,7 @@ struct ieee80211_tx_data {
 	struct ieee80211_tx_rate rate;
 
 	unsigned int flags;
+	unsigned int hdrlen;
 };
 
 
@@ -818,6 +819,7 @@ enum txq_info_flags {
 	IEEE80211_TXQ_STOP,
 	IEEE80211_TXQ_AMPDU,
 	IEEE80211_TXQ_NO_AMSDU,
+	IEEE80211_TXQ_STOP_NETIF_TX,
 };
 
 /**
@@ -828,6 +830,8 @@ enum txq_info_flags {
  *	a fq_flow which is already owned by a different tin
  * @def_cvars: codel vars for @def_flow
  * @frags: used to keep fragments created after dequeue
+ * @schedule_order: used with ieee80211_local->active_txqs
+ * @schedule_round: counter to prevent infinite loops on TXQ scheduling
  */
 struct txq_info {
 	struct fq_tin tin;
@@ -835,6 +839,8 @@ struct txq_info {
 	struct codel_vars def_cvars;
 	struct codel_stats cstats;
 	struct sk_buff_head frags;
+	struct list_head schedule_order;
+	u16 schedule_round;
 	unsigned long flags;
 
 	/* keep last! */
@@ -1126,6 +1132,13 @@ struct ieee80211_local {
 	struct codel_vars *cvars;
 	struct codel_params cparams;
 
+	/* protects active_txqs and txqi->schedule_order */
+	spinlock_t active_txq_lock[IEEE80211_NUM_ACS];
+	struct list_head active_txqs[IEEE80211_NUM_ACS];
+	u16 schedule_round[IEEE80211_NUM_ACS];
+
+	u16 airtime_flags;
+
 	const struct ieee80211_ops *ops;
 
 	/*
@@ -1226,6 +1239,7 @@ struct ieee80211_local {
 
 	struct sk_buff_head pending[IEEE80211_MAX_QUEUES];
 	struct tasklet_struct tx_pending_tasklet;
+	struct tasklet_struct wake_txqs_tasklet;
 
 	atomic_t agg_queue_stop[IEEE80211_MAX_QUEUES];
 
@@ -1351,6 +1365,7 @@ struct ieee80211_local {
 	int dynamic_ps_forced_timeout;
 
 	int user_power_level; /* in dBm, for all interfaces */
+	int user_antenna_gain; /* in dBi */
 
 	enum ieee80211_smps_mode smps_mode;
 
@@ -1747,6 +1762,9 @@ void ieee80211_clear_fast_xmit(struct sta_info *sta);
 int ieee80211_tx_control_port(struct wiphy *wiphy, struct net_device *dev,
 			      const u8 *buf, size_t len,
 			      const u8 *dest, __be16 proto, bool unencrypted);
+int ieee80211_skb_resize(struct ieee80211_local *local,
+			 struct ieee80211_sub_if_data *sdata,
+			 struct sk_buff *skb, int hdrlen, int hdr_add);
 
 /* HT */
 void ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,
@@ -2039,6 +2057,7 @@ void ieee80211_txq_remove_vlan(struct ieee80211_local *local,
 			       struct ieee80211_sub_if_data *sdata);
 void ieee80211_fill_txq_stats(struct cfg80211_txq_stats *txqstats,
 			      struct txq_info *txqi);
+void ieee80211_wake_txqs(unsigned long data);
 void ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,
 			 u16 transaction, u16 auth_alg, u16 status,
 			 const u8 *extra, size_t extra_len, const u8 *bssid,
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index b587f5c..c56e730 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -1301,6 +1301,7 @@ static void ieee80211_if_setup(struct net_device *dev)
 static void ieee80211_if_setup_no_queue(struct net_device *dev)
 {
 	ieee80211_if_setup(dev);
+	dev->features |= NETIF_F_LLTX;
 #if LINUX_VERSION_IS_GEQ(4,3,0)
 	dev->priv_flags |= IFF_NO_QUEUE;
 #else
@@ -1871,6 +1872,10 @@ int ieee80211_if_add(struct ieee80211_local *local, const char *name,
 					+ 8 /* rfc1042/bridge tunnel */
 					- ETH_HLEN /* ethernet hard_header_len */
 					+ IEEE80211_ENCRYPT_HEADROOM;
+
+		if (ieee80211_hw_check(&local->hw, TX_NEEDS_ALIGNED4_SKBS))
+			ndev->needed_headroom += 2; /* padding */
+
 		ndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;
 
 		ret = dev_alloc_name(ndev, ndev->name);
diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index e542d6b..9220496 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -88,12 +88,12 @@ struct ieee80211_key {
 			 * Management frames.
 			 */
 			u8 rx_pn[IEEE80211_NUM_TIDS + 1][IEEE80211_CCMP_PN_LEN];
-			struct crypto_aead *tfm;
+			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
 		} ccmp;
 		struct {
 			u8 rx_pn[IEEE80211_CMAC_PN_LEN];
-			struct crypto_shash *tfm;
+			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
 		} aes_cmac;
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index c86a097..959eb17 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -94,7 +94,7 @@ static u32 ieee80211_hw_conf_chan(struct ieee80211_local *local)
 	struct ieee80211_sub_if_data *sdata;
 	struct cfg80211_chan_def chandef = {};
 	u32 changed = 0;
-	int power;
+	int power, max_power;
 	u32 offchannel_flag;
 
 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
@@ -151,6 +151,12 @@ static u32 ieee80211_hw_conf_chan(struct ieee80211_local *local)
 	}
 	rcu_read_unlock();
 
+	max_power = chandef.chan->max_reg_power;
+	if (local->user_antenna_gain > 0) {
+		max_power -= local->user_antenna_gain;
+		power = min(power, max_power);
+	}
+
 	if (local->hw.conf.power_level != power) {
 		changed |= IEEE80211_CONF_CHANGE_POWER;
 		local->hw.conf.power_level = power;
@@ -315,7 +321,7 @@ void ieee80211_restart_hw(struct ieee80211_hw *hw)
 }
 EXPORT_SYMBOL(ieee80211_restart_hw);
 
-#ifdef CONFIG_INET
+#ifdef __disabled__CONFIG_INET
 static int ieee80211_ifa_changed(struct notifier_block *nb,
 				 unsigned long data, void *arg)
 {
@@ -374,7 +380,7 @@ static int ieee80211_ifa_changed(struct notifier_block *nb,
 }
 #endif
 
-#if IS_ENABLED(CONFIG_IPV6)
+#if IS_ENABLED(__disabled__CONFIG_IPV6)
 static int ieee80211_ifa6_changed(struct notifier_block *nb,
 				  unsigned long data, void *arg)
 {
@@ -570,7 +576,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
 			   NL80211_FEATURE_MAC_ON_CREATE |
 			   NL80211_FEATURE_USERSPACE_MPM |
 			   NL80211_FEATURE_FULL_AP_CLIENT_STATE;
-#if LINUX_VERSION_IS_GEQ(4,3,0)
+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_FILS_STA);
 #endif
 	wiphy_ext_feature_set(wiphy,
@@ -626,6 +632,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
+	local->user_antenna_gain = 0;
 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
 	local->user_power_level = IEEE80211_UNSET_POWER_LEVEL;
@@ -652,6 +659,12 @@ struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
 	spin_lock_init(&local->rx_path_lock);
 	spin_lock_init(&local->queue_stop_reason_lock);
 
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		INIT_LIST_HEAD(&local->active_txqs[i]);
+		spin_lock_init(&local->active_txq_lock[i]);
+	}
+	local->airtime_flags = AIRTIME_USE_TX | AIRTIME_USE_RX;
+
 	INIT_LIST_HEAD(&local->chanctx_list);
 	mutex_init(&local->chanctx_mtx);
 
@@ -686,6 +699,10 @@ struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
 	tasklet_init(&local->tx_pending_tasklet, ieee80211_tx_pending,
 		     (unsigned long)local);
 
+	if (ops->wake_tx_queue)
+		tasklet_init(&local->wake_txqs_tasklet, ieee80211_wake_txqs,
+			     (unsigned long)local);
+
 	tasklet_init(&local->tasklet,
 		     ieee80211_tasklet_handler,
 		     (unsigned long) local);
@@ -1133,6 +1150,9 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 	if (!local->hw.max_nan_de_entries)
 		local->hw.max_nan_de_entries = IEEE80211_MAX_NAN_INSTANCE_ID;
 
+	if (!local->hw.weight_multiplier)
+		local->hw.weight_multiplier = 1;
+
 	result = ieee80211_wep_init(local);
 	if (result < 0)
 		wiphy_debug(local->hw.wiphy, "Failed to initialize wep: %d\n",
@@ -1168,14 +1188,14 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 
 	rtnl_unlock();
 
-#ifdef CONFIG_INET
+#ifdef __disabled__CONFIG_INET
 	local->ifa_notifier.notifier_call = ieee80211_ifa_changed;
 	result = register_inetaddr_notifier(&local->ifa_notifier);
 	if (result)
 		goto fail_ifa;
 #endif
 
-#if IS_ENABLED(CONFIG_IPV6)
+#if IS_ENABLED(__disabled__CONFIG_IPV6)
 	local->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;
 	result = register_inet6addr_notifier(&local->ifa6_notifier);
 	if (result)
@@ -1184,13 +1204,13 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 
 	return 0;
 
-#if IS_ENABLED(CONFIG_IPV6)
+#if IS_ENABLED(__disabled__CONFIG_IPV6)
  fail_ifa6:
-#ifdef CONFIG_INET
+#ifdef __disabled__CONFIG_INET
 	unregister_inetaddr_notifier(&local->ifa_notifier);
 #endif
 #endif
-#if defined(CONFIG_INET) || defined(CONFIG_IPV6)
+#if defined(__disabled__CONFIG_INET) || defined(__disabled__CONFIG_IPV6)
  fail_ifa:
 #endif
 	rtnl_lock();
@@ -1219,10 +1239,10 @@ void ieee80211_unregister_hw(struct ieee80211_hw *hw)
 	tasklet_kill(&local->tx_pending_tasklet);
 	tasklet_kill(&local->tasklet);
 
-#ifdef CONFIG_INET
+#ifdef __disabled__CONFIG_INET
 	unregister_inetaddr_notifier(&local->ifa_notifier);
 #endif
-#if IS_ENABLED(CONFIG_IPV6)
+#if IS_ENABLED(__disabled__CONFIG_IPV6)
 	unregister_inet6addr_notifier(&local->ifa6_notifier);
 #endif
 
@@ -1304,18 +1324,12 @@ static int __init ieee80211_init(void)
 	if (ret)
 		return ret;
 
-	ret = rc80211_minstrel_ht_init();
-	if (ret)
-		goto err_minstrel;
-
 	ret = ieee80211_iface_init();
 	if (ret)
 		goto err_netdev;
 
 	return 0;
  err_netdev:
-	rc80211_minstrel_ht_exit();
- err_minstrel:
 	rc80211_minstrel_exit();
 
 	return ret;
@@ -1323,7 +1337,6 @@ static int __init ieee80211_init(void)
 
 static void __exit ieee80211_exit(void)
 {
-	rc80211_minstrel_ht_exit();
 	rc80211_minstrel_exit();
 
 	ieee80211s_stop();
diff --git a/net/mac80211/mesh_hwmp.c b/net/mac80211/mesh_hwmp.c
index 6950cd0..299ff12 100644
--- a/net/mac80211/mesh_hwmp.c
+++ b/net/mac80211/mesh_hwmp.c
@@ -1112,16 +1112,13 @@ int mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,
 	struct mesh_path *mpath;
 	struct sk_buff *skb_to_free = NULL;
 	u8 *target_addr = hdr->addr3;
-	int err = 0;
 
 	/* Nulls are only sent to peers for PS and should be pre-addressed */
 	if (ieee80211_is_qos_nullfunc(hdr->frame_control))
 		return 0;
 
-	rcu_read_lock();
-	err = mesh_nexthop_lookup(sdata, skb);
-	if (!err)
-		goto endlookup;
+	if (!mesh_nexthop_lookup(sdata, skb))
+		return 0;
 
 	/* no nexthop found, start resolving */
 	mpath = mesh_path_lookup(sdata, target_addr);
@@ -1129,8 +1126,7 @@ int mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,
 		mpath = mesh_path_add(sdata, target_addr);
 		if (IS_ERR(mpath)) {
 			mesh_path_discard_frame(sdata, skb);
-			err = PTR_ERR(mpath);
-			goto endlookup;
+			return PTR_ERR(mpath);
 		}
 	}
 
@@ -1143,13 +1139,10 @@ int mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,
 	info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
 	ieee80211_set_qos_hdr(sdata, skb);
 	skb_queue_tail(&mpath->frame_queue, skb);
-	err = -ENOENT;
 	if (skb_to_free)
 		mesh_path_discard_frame(sdata, skb_to_free);
 
-endlookup:
-	rcu_read_unlock();
-	return err;
+	return -ENOENT;
 }
 
 /**
@@ -1169,13 +1162,10 @@ int mesh_nexthop_lookup(struct ieee80211_sub_if_data *sdata,
 	struct sta_info *next_hop;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
 	u8 *target_addr = hdr->addr3;
-	int err = -ENOENT;
 
-	rcu_read_lock();
 	mpath = mesh_path_lookup(sdata, target_addr);
-
 	if (!mpath || !(mpath->flags & MESH_PATH_ACTIVE))
-		goto endlookup;
+		return -ENOENT;
 
 	if (time_after(jiffies,
 		       mpath->exp_time -
@@ -1190,12 +1180,10 @@ int mesh_nexthop_lookup(struct ieee80211_sub_if_data *sdata,
 		memcpy(hdr->addr1, next_hop->sta.addr, ETH_ALEN);
 		memcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);
 		ieee80211_mps_set_frame_flags(sdata, next_hop, hdr);
-		err = 0;
+		return 0;
 	}
 
-endlookup:
-	rcu_read_unlock();
-	return err;
+	return -ENOENT;
 }
 
 void mesh_path_timer(struct timer_list *t)
diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c
index c3a7396..98d854d 100644
--- a/net/mac80211/mesh_pathtbl.c
+++ b/net/mac80211/mesh_pathtbl.c
@@ -23,7 +23,7 @@ static void mesh_path_free_rcu(struct mesh_table *tbl, struct mesh_path *mpath);
 static u32 mesh_table_hash(const void *addr, u32 len, u32 seed)
 {
 	/* Use last four bytes of hw addr as hash index */
-	return jhash_1word(*(u32 *)(addr+2), seed);
+	return jhash_1word(__get_unaligned_cpu32(addr+2), seed);
 }
 
 static const struct rhashtable_params mesh_rht_params = {
@@ -105,13 +105,15 @@ void mesh_path_assign_nexthop(struct mesh_path *mpath, struct sta_info *sta)
 static void prepare_for_gate(struct sk_buff *skb, char *dst_addr,
 			     struct mesh_path *gate_mpath)
 {
+	struct ieee80211_sub_if_data *sdata = gate_mpath->sdata;
+	struct ieee80211_hw *hw = &sdata->local->hw;
 	struct ieee80211_hdr *hdr;
 	struct ieee80211s_hdr *mshdr;
 	int mesh_hdrlen, hdrlen;
 	char *next_hop;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_padded_hdrlen(hw, hdr->frame_control);
 	mshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
 
 	if (!(mshdr->flags & MESH_FLAGS_AE)) {
@@ -217,7 +219,7 @@ static struct mesh_path *mpath_lookup(struct mesh_table *tbl, const u8 *dst,
 {
 	struct mesh_path *mpath;
 
-	mpath = rhashtable_lookup_fast(&tbl->rhead, dst, mesh_rht_params);
+	mpath = rhashtable_lookup(&tbl->rhead, dst, mesh_rht_params);
 
 	if (mpath && mpath_expired(mpath)) {
 		spin_lock_bh(&mpath->state_lock);
diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 19044bb..5f454b9 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -95,18 +95,5 @@ static inline void rc80211_minstrel_exit(void)
 }
 #endif
 
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_HT
-int rc80211_minstrel_ht_init(void);
-void rc80211_minstrel_ht_exit(void);
-#else
-static inline int rc80211_minstrel_ht_init(void)
-{
-	return 0;
-}
-static inline void rc80211_minstrel_ht_exit(void)
-{
-}
-#endif
-
 
 #endif /* IEEE80211_RATE_H */
diff --git a/net/mac80211/rc80211_minstrel.c b/net/mac80211/rc80211_minstrel.c
index 503805a..f496685 100644
--- a/net/mac80211/rc80211_minstrel.c
+++ b/net/mac80211/rc80211_minstrel.c
@@ -572,141 +572,6 @@ minstrel_rate_init(void *priv, struct ieee80211_supported_band *sband,
 	minstrel_update_rates(mp, mi);
 }
 
-static void *
-minstrel_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)
-{
-	struct ieee80211_supported_band *sband;
-	struct minstrel_sta_info *mi;
-	struct minstrel_priv *mp = priv;
-	struct ieee80211_hw *hw = mp->hw;
-	int max_rates = 0;
-	int i;
-
-	mi = kzalloc(sizeof(struct minstrel_sta_info), gfp);
-	if (!mi)
-		return NULL;
-
-	for (i = 0; i < NUM_NL80211_BANDS; i++) {
-		sband = hw->wiphy->bands[i];
-		if (sband && sband->n_bitrates > max_rates)
-			max_rates = sband->n_bitrates;
-	}
-
-	mi->r = kcalloc(max_rates, sizeof(struct minstrel_rate), gfp);
-	if (!mi->r)
-		goto error;
-
-	mi->sample_table = kmalloc_array(max_rates, SAMPLE_COLUMNS, gfp);
-	if (!mi->sample_table)
-		goto error1;
-
-	mi->last_stats_update = jiffies;
-	return mi;
-
-error1:
-	kfree(mi->r);
-error:
-	kfree(mi);
-	return NULL;
-}
-
-static void
-minstrel_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
-{
-	struct minstrel_sta_info *mi = priv_sta;
-
-	kfree(mi->sample_table);
-	kfree(mi->r);
-	kfree(mi);
-}
-
-static void
-minstrel_init_cck_rates(struct minstrel_priv *mp)
-{
-	static const int bitrates[4] = { 10, 20, 55, 110 };
-	struct ieee80211_supported_band *sband;
-	u32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);
-	int i, j;
-
-	sband = mp->hw->wiphy->bands[NL80211_BAND_2GHZ];
-	if (!sband)
-		return;
-
-	for (i = 0, j = 0; i < sband->n_bitrates; i++) {
-		struct ieee80211_rate *rate = &sband->bitrates[i];
-
-		if (rate->flags & IEEE80211_RATE_ERP_G)
-			continue;
-
-		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
-			continue;
-
-		for (j = 0; j < ARRAY_SIZE(bitrates); j++) {
-			if (rate->bitrate != bitrates[j])
-				continue;
-
-			mp->cck_rates[j] = i;
-			break;
-		}
-	}
-}
-
-static void *
-minstrel_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
-{
-	struct minstrel_priv *mp;
-
-	mp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);
-	if (!mp)
-		return NULL;
-
-	/* contention window settings
-	 * Just an approximation. Using the per-queue values would complicate
-	 * the calculations and is probably unnecessary */
-	mp->cw_min = 15;
-	mp->cw_max = 1023;
-
-	/* number of packets (in %) to use for sampling other rates
-	 * sample less often for non-mrr packets, because the overhead
-	 * is much higher than with mrr */
-	mp->lookaround_rate = 5;
-	mp->lookaround_rate_mrr = 10;
-
-	/* maximum time that the hw is allowed to stay in one MRR segment */
-	mp->segment_size = 6000;
-
-	if (hw->max_rate_tries > 0)
-		mp->max_retry = hw->max_rate_tries;
-	else
-		/* safe default, does not necessarily have to match hw properties */
-		mp->max_retry = 7;
-
-	if (hw->max_rates >= 4)
-		mp->has_mrr = true;
-
-	mp->hw = hw;
-	mp->update_interval = 100;
-
-#ifdef CPTCFG_MAC80211_DEBUGFS
-	mp->fixed_rate_idx = (u32) -1;
-	mp->dbg_fixed_rate = debugfs_create_u32("fixed_rate_idx",
-			0666, debugfsdir, &mp->fixed_rate_idx);
-#endif
-
-	minstrel_init_cck_rates(mp);
-
-	return mp;
-}
-
-static void
-minstrel_free(void *priv)
-{
-#ifdef CPTCFG_MAC80211_DEBUGFS
-	debugfs_remove(((struct minstrel_priv *)priv)->dbg_fixed_rate);
-#endif
-	kfree(priv);
-}
-
 static u32 minstrel_get_expected_throughput(void *priv_sta)
 {
 	struct minstrel_sta_info *mi = priv_sta;
@@ -725,29 +590,8 @@ static u32 minstrel_get_expected_throughput(void *priv_sta)
 }
 
 const struct rate_control_ops mac80211_minstrel = {
-	.name = "minstrel",
 	.tx_status_ext = minstrel_tx_status,
 	.get_rate = minstrel_get_rate,
 	.rate_init = minstrel_rate_init,
-	.alloc = minstrel_alloc,
-	.free = minstrel_free,
-	.alloc_sta = minstrel_alloc_sta,
-	.free_sta = minstrel_free_sta,
-#ifdef CPTCFG_MAC80211_DEBUGFS
-	.add_sta_debugfs = minstrel_add_sta_debugfs,
-	.remove_sta_debugfs = minstrel_remove_sta_debugfs,
-#endif
 	.get_expected_throughput = minstrel_get_expected_throughput,
 };
-
-int __init
-rc80211_minstrel_init(void)
-{
-	return ieee80211_rate_control_register(&mac80211_minstrel);
-}
-
-void
-rc80211_minstrel_exit(void)
-{
-	ieee80211_rate_control_unregister(&mac80211_minstrel);
-}
diff --git a/net/mac80211/rc80211_minstrel.h b/net/mac80211/rc80211_minstrel.h
index 6ec62d5..9dc09c9 100644
--- a/net/mac80211/rc80211_minstrel.h
+++ b/net/mac80211/rc80211_minstrel.h
@@ -109,11 +109,6 @@ struct minstrel_sta_info {
 
 	/* sampling table */
 	u8 *sample_table;
-
-#ifdef CPTCFG_MAC80211_DEBUGFS
-	struct dentry *dbg_stats;
-	struct dentry *dbg_stats_csv;
-#endif
 };
 
 struct minstrel_priv {
@@ -137,7 +132,6 @@ struct minstrel_priv {
 	 *   - setting will be applied on next update
 	 */
 	u32 fixed_rate_idx;
-	struct dentry *dbg_fixed_rate;
 #endif
 };
 
@@ -156,7 +150,6 @@ minstrel_get_ewmsd10(struct minstrel_rate_stats *mrs)
 
 extern const struct rate_control_ops mac80211_minstrel;
 void minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
-void minstrel_remove_sta_debugfs(void *priv, void *priv_sta);
 
 /* Recalculate success probabilities and counters for a given rate using EWMA */
 void minstrel_calc_rate_stats(struct minstrel_rate_stats *mrs);
@@ -165,7 +158,5 @@ int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_ewma);
 /* debugfs */
 int minstrel_stats_open(struct inode *inode, struct file *file);
 int minstrel_stats_csv_open(struct inode *inode, struct file *file);
-ssize_t minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos);
-int minstrel_stats_release(struct inode *inode, struct file *file);
 
 #endif
diff --git a/net/mac80211/rc80211_minstrel_debugfs.c b/net/mac80211/rc80211_minstrel_debugfs.c
index 9ad7d63..698a668 100644
--- a/net/mac80211/rc80211_minstrel_debugfs.c
+++ b/net/mac80211/rc80211_minstrel_debugfs.c
@@ -54,22 +54,6 @@
 #include <net/mac80211.h>
 #include "rc80211_minstrel.h"
 
-ssize_t
-minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos)
-{
-	struct minstrel_debugfs_info *ms;
-
-	ms = file->private_data;
-	return simple_read_from_buffer(buf, len, ppos, ms->buf, ms->len);
-}
-
-int
-minstrel_stats_release(struct inode *inode, struct file *file)
-{
-	kfree(file->private_data);
-	return 0;
-}
-
 int
 minstrel_stats_open(struct inode *inode, struct file *file)
 {
@@ -135,14 +119,6 @@ minstrel_stats_open(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static const struct file_operations minstrel_stat_fops = {
-	.owner = THIS_MODULE,
-	.open = minstrel_stats_open,
-	.read = minstrel_stats_read,
-	.release = minstrel_stats_release,
-	.llseek = default_llseek,
-};
-
 int
 minstrel_stats_csv_open(struct inode *inode, struct file *file)
 {
@@ -200,33 +176,3 @@ minstrel_stats_csv_open(struct inode *inode, struct file *file)
 
 	return 0;
 }
-
-static const struct file_operations minstrel_stat_csv_fops = {
-	.owner = THIS_MODULE,
-	.open = minstrel_stats_csv_open,
-	.read = minstrel_stats_read,
-	.release = minstrel_stats_release,
-	.llseek = default_llseek,
-};
-
-void
-minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir)
-{
-	struct minstrel_sta_info *mi = priv_sta;
-
-	mi->dbg_stats = debugfs_create_file("rc_stats", 0444, dir, mi,
-					    &minstrel_stat_fops);
-
-	mi->dbg_stats_csv = debugfs_create_file("rc_stats_csv", 0444, dir, mi,
-						&minstrel_stat_csv_fops);
-}
-
-void
-minstrel_remove_sta_debugfs(void *priv, void *priv_sta)
-{
-	struct minstrel_sta_info *mi = priv_sta;
-
-	debugfs_remove(mi->dbg_stats);
-
-	debugfs_remove(mi->dbg_stats_csv);
-}
diff --git a/net/mac80211/rc80211_minstrel_ht.c b/net/mac80211/rc80211_minstrel_ht.c
index 97f765e..6d20d7a 100644
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -52,22 +52,23 @@
 	_streams - 1
 
 /* MCS rate information for an MCS group */
-#define MCS_GROUP(_streams, _sgi, _ht40)				\
+#define MCS_GROUP(_streams, _sgi, _ht40, _s)				\
 	[GROUP_IDX(_streams, _sgi, _ht40)] = {				\
 	.streams = _streams,						\
+	.shift = _s,							\
 	.flags =							\
 		IEEE80211_TX_RC_MCS |					\
 		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
 		(_ht40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),		\
 	.duration = {							\
-		MCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26),		\
-		MCS_DURATION(_streams, _sgi, _ht40 ? 108 : 52),		\
-		MCS_DURATION(_streams, _sgi, _ht40 ? 162 : 78),		\
-		MCS_DURATION(_streams, _sgi, _ht40 ? 216 : 104),	\
-		MCS_DURATION(_streams, _sgi, _ht40 ? 324 : 156),	\
-		MCS_DURATION(_streams, _sgi, _ht40 ? 432 : 208),	\
-		MCS_DURATION(_streams, _sgi, _ht40 ? 486 : 234),	\
-		MCS_DURATION(_streams, _sgi, _ht40 ? 540 : 260)		\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26) >> _s,	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 108 : 52) >> _s,	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 162 : 78) >> _s,	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 216 : 104) >> _s,	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 324 : 156) >> _s,	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 432 : 208) >> _s,	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 486 : 234) >> _s,	\
+		MCS_DURATION(_streams, _sgi, _ht40 ? 540 : 260) >> _s	\
 	}								\
 }
 
@@ -80,9 +81,10 @@
 #define BW2VBPS(_bw, r3, r2, r1)					\
 	(_bw == BW_80 ? r3 : _bw == BW_40 ? r2 : r1)
 
-#define VHT_GROUP(_streams, _sgi, _bw)					\
+#define VHT_GROUP(_streams, _sgi, _bw, _s)				\
 	[VHT_GROUP_IDX(_streams, _sgi, _bw)] = {			\
 	.streams = _streams,						\
+	.shift = _s,							\
 	.flags =							\
 		IEEE80211_TX_RC_VHT_MCS |				\
 		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
@@ -90,25 +92,25 @@
 		 _bw == BW_40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),	\
 	.duration = {							\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw,  117,  54,  26)),		\
+			     BW2VBPS(_bw,  117,  54,  26)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw,  234, 108,  52)),		\
+			     BW2VBPS(_bw,  234, 108,  52)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw,  351, 162,  78)),		\
+			     BW2VBPS(_bw,  351, 162,  78)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw,  468, 216, 104)),		\
+			     BW2VBPS(_bw,  468, 216, 104)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw,  702, 324, 156)),		\
+			     BW2VBPS(_bw,  702, 324, 156)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw,  936, 432, 208)),		\
+			     BW2VBPS(_bw,  936, 432, 208)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw, 1053, 486, 234)),		\
+			     BW2VBPS(_bw, 1053, 486, 234)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw, 1170, 540, 260)),		\
+			     BW2VBPS(_bw, 1170, 540, 260)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw, 1404, 648, 312)),		\
+			     BW2VBPS(_bw, 1404, 648, 312)) >> _s,	\
 		MCS_DURATION(_streams, _sgi,				\
-			     BW2VBPS(_bw, 1560, 720, 346))		\
+			     BW2VBPS(_bw, 1560, 720, 346)) >> _s	\
 	}								\
 }
 
@@ -121,28 +123,27 @@
 	(CCK_DURATION((_bitrate > 10 ? 20 : 10), false, 60) +	\
 	 CCK_DURATION(_bitrate, _short, AVG_PKT_SIZE))
 
-#define CCK_DURATION_LIST(_short)			\
-	CCK_ACK_DURATION(10, _short),			\
-	CCK_ACK_DURATION(20, _short),			\
-	CCK_ACK_DURATION(55, _short),			\
-	CCK_ACK_DURATION(110, _short)
+#define CCK_DURATION_LIST(_short, _s)			\
+	CCK_ACK_DURATION(10, _short) >> _s,		\
+	CCK_ACK_DURATION(20, _short) >> _s,		\
+	CCK_ACK_DURATION(55, _short) >> _s,		\
+	CCK_ACK_DURATION(110, _short) >> _s
 
-#define CCK_GROUP					\
+#define CCK_GROUP(_s)					\
 	[MINSTREL_CCK_GROUP] = {			\
-		.streams = 0,				\
+		.streams = 1,				\
 		.flags = 0,				\
+		.shift = _s,				\
 		.duration = {				\
-			CCK_DURATION_LIST(false),	\
-			CCK_DURATION_LIST(true)		\
+			CCK_DURATION_LIST(false, _s),	\
+			CCK_DURATION_LIST(true, _s)	\
 		}					\
 	}
 
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
 static bool minstrel_vht_only = true;
 module_param(minstrel_vht_only, bool, 0644);
 MODULE_PARM_DESC(minstrel_vht_only,
 		 "Use only VHT rates when VHT is supported by sta.");
-#endif
 
 /*
  * To enable sufficiently targeted rate sampling, MCS rates are divided into
@@ -153,49 +154,47 @@ MODULE_PARM_DESC(minstrel_vht_only,
  * BW -> SGI -> #streams
  */
 const struct mcs_group minstrel_mcs_groups[] = {
-	MCS_GROUP(1, 0, BW_20),
-	MCS_GROUP(2, 0, BW_20),
-	MCS_GROUP(3, 0, BW_20),
+	MCS_GROUP(1, 0, BW_20, 5),
+	MCS_GROUP(2, 0, BW_20, 4),
+	MCS_GROUP(3, 0, BW_20, 4),
 
-	MCS_GROUP(1, 1, BW_20),
-	MCS_GROUP(2, 1, BW_20),
-	MCS_GROUP(3, 1, BW_20),
+	MCS_GROUP(1, 1, BW_20, 5),
+	MCS_GROUP(2, 1, BW_20, 4),
+	MCS_GROUP(3, 1, BW_20, 4),
 
-	MCS_GROUP(1, 0, BW_40),
-	MCS_GROUP(2, 0, BW_40),
-	MCS_GROUP(3, 0, BW_40),
+	MCS_GROUP(1, 0, BW_40, 4),
+	MCS_GROUP(2, 0, BW_40, 4),
+	MCS_GROUP(3, 0, BW_40, 4),
 
-	MCS_GROUP(1, 1, BW_40),
-	MCS_GROUP(2, 1, BW_40),
-	MCS_GROUP(3, 1, BW_40),
+	MCS_GROUP(1, 1, BW_40, 4),
+	MCS_GROUP(2, 1, BW_40, 4),
+	MCS_GROUP(3, 1, BW_40, 4),
 
-	CCK_GROUP,
+	CCK_GROUP(8),
 
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
-	VHT_GROUP(1, 0, BW_20),
-	VHT_GROUP(2, 0, BW_20),
-	VHT_GROUP(3, 0, BW_20),
+	VHT_GROUP(1, 0, BW_20, 5),
+	VHT_GROUP(2, 0, BW_20, 4),
+	VHT_GROUP(3, 0, BW_20, 4),
 
-	VHT_GROUP(1, 1, BW_20),
-	VHT_GROUP(2, 1, BW_20),
-	VHT_GROUP(3, 1, BW_20),
+	VHT_GROUP(1, 1, BW_20, 5),
+	VHT_GROUP(2, 1, BW_20, 4),
+	VHT_GROUP(3, 1, BW_20, 4),
 
-	VHT_GROUP(1, 0, BW_40),
-	VHT_GROUP(2, 0, BW_40),
-	VHT_GROUP(3, 0, BW_40),
+	VHT_GROUP(1, 0, BW_40, 4),
+	VHT_GROUP(2, 0, BW_40, 4),
+	VHT_GROUP(3, 0, BW_40, 4),
 
-	VHT_GROUP(1, 1, BW_40),
-	VHT_GROUP(2, 1, BW_40),
-	VHT_GROUP(3, 1, BW_40),
+	VHT_GROUP(1, 1, BW_40, 4),
+	VHT_GROUP(2, 1, BW_40, 4),
+	VHT_GROUP(3, 1, BW_40, 4),
 
-	VHT_GROUP(1, 0, BW_80),
-	VHT_GROUP(2, 0, BW_80),
-	VHT_GROUP(3, 0, BW_80),
+	VHT_GROUP(1, 0, BW_80, 4),
+	VHT_GROUP(2, 0, BW_80, 4),
+	VHT_GROUP(3, 0, BW_80, 4),
 
-	VHT_GROUP(1, 1, BW_80),
-	VHT_GROUP(2, 1, BW_80),
-	VHT_GROUP(3, 1, BW_80),
-#endif
+	VHT_GROUP(1, 1, BW_80, 4),
+	VHT_GROUP(2, 1, BW_80, 4),
+	VHT_GROUP(3, 1, BW_80, 4),
 };
 
 static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
@@ -282,7 +281,8 @@ minstrel_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
 				break;
 
 		/* short preamble */
-		if (!(mi->supported[group] & BIT(idx)))
+		if ((mi->supported[group] & BIT(idx + 4)) &&
+		    (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE))
 			idx += 4;
 	}
 	return &mi->groups[group].rates[idx];
@@ -294,6 +294,15 @@ minstrel_get_ratestats(struct minstrel_ht_sta *mi, int index)
 	return &mi->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];
 }
 
+static unsigned int
+minstrel_ht_avg_ampdu_len(struct minstrel_ht_sta *mi)
+{
+	if (!mi->avg_ampdu_len)
+		return AVG_AMPDU_SIZE;
+
+	return MINSTREL_TRUNC(mi->avg_ampdu_len);
+}
+
 /*
  * Return current throughput based on the average A-MPDU length, taking into
  * account the expected number of retransmissions and their expected length
@@ -309,9 +318,10 @@ minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
 		return 0;
 
 	if (group != MINSTREL_CCK_GROUP)
-		nsecs = 1000 * mi->overhead / MINSTREL_TRUNC(mi->avg_ampdu_len);
+		nsecs = 1000 * mi->overhead / minstrel_ht_avg_ampdu_len(mi);
 
-	nsecs += minstrel_mcs_groups[group].duration[rate];
+	nsecs += minstrel_mcs_groups[group].duration[rate] <<
+		 minstrel_mcs_groups[group].shift;
 
 	/*
 	 * For the throughput calculation, limit the probability value to 90% to
@@ -502,8 +512,12 @@ minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 	u16 tmp_cck_tp_rate[MAX_THR_RATES], index;
 
 	if (mi->ampdu_packets > 0) {
-		mi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,
-			MINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets), EWMA_LEVEL);
+		if (!ieee80211_hw_check(mp->hw, TX_STATUS_NO_AMPDU_LEN))
+			mi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,
+				MINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets),
+					      EWMA_LEVEL);
+		else
+			mi->avg_ampdu_len = 0;
 		mi->ampdu_len = 0;
 		mi->ampdu_packets = 0;
 	}
@@ -708,7 +722,9 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 	mi->ampdu_len += info->status.ampdu_len;
 
 	if (!mi->sample_wait && !mi->sample_tries && mi->sample_count > 0) {
-		mi->sample_wait = 16 + 2 * MINSTREL_TRUNC(mi->avg_ampdu_len);
+		int avg_ampdu_len = minstrel_ht_avg_ampdu_len(mi);
+
+		mi->sample_wait = 16 + 2 * avg_ampdu_len;
 		mi->sample_tries = 1;
 		mi->sample_count--;
 	}
@@ -759,17 +775,24 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 		minstrel_ht_update_rates(mp, mi);
 }
 
+static inline int
+minstrel_get_duration(int index)
+{
+	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
+	unsigned int duration = group->duration[index % MCS_GROUP_RATES];
+	return duration << group->shift;
+}
+
 static void
 minstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
                          int index)
 {
 	struct minstrel_rate_stats *mrs;
-	const struct mcs_group *group;
 	unsigned int tx_time, tx_time_rtscts, tx_time_data;
 	unsigned int cw = mp->cw_min;
 	unsigned int ctime = 0;
 	unsigned int t_slot = 9; /* FIXME */
-	unsigned int ampdu_len = MINSTREL_TRUNC(mi->avg_ampdu_len);
+	unsigned int ampdu_len = minstrel_ht_avg_ampdu_len(mi);
 	unsigned int overhead = 0, overhead_rtscts = 0;
 
 	mrs = minstrel_get_ratestats(mi, index);
@@ -783,8 +806,7 @@ minstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
 	mrs->retry_count_rtscts = 2;
 	mrs->retry_updated = true;
 
-	group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
-	tx_time_data = group->duration[index % MCS_GROUP_RATES] * ampdu_len / 1000;
+	tx_time_data = minstrel_get_duration(index) * ampdu_len / 1000;
 
 	/* Contention time for first 2 tries */
 	ctime = (t_slot * cw) >> 1;
@@ -878,20 +900,24 @@ minstrel_ht_get_max_amsdu_len(struct minstrel_ht_sta *mi)
 	int group = mi->max_prob_rate / MCS_GROUP_RATES;
 	const struct mcs_group *g = &minstrel_mcs_groups[group];
 	int rate = mi->max_prob_rate % MCS_GROUP_RATES;
+	unsigned int duration;
 
 	/* Disable A-MSDU if max_prob_rate is bad */
 	if (mi->groups[group].rates[rate].prob_ewma < MINSTREL_FRAC(50, 100))
 		return 1;
 
+	duration = g->duration[rate];
+	duration <<= g->shift;
+
 	/* If the rate is slower than single-stream MCS1, make A-MSDU limit small */
-	if (g->duration[rate] > MCS_DURATION(1, 0, 52))
+	if (duration > MCS_DURATION(1, 0, 52))
 		return 500;
 
 	/*
 	 * If the rate is slower than single-stream MCS4, limit A-MSDU to usual
 	 * data packet size
 	 */
-	if (g->duration[rate] > MCS_DURATION(1, 0, 104))
+	if (duration > MCS_DURATION(1, 0, 104))
 		return 1600;
 
 	/*
@@ -899,7 +925,7 @@ minstrel_ht_get_max_amsdu_len(struct minstrel_ht_sta *mi)
 	 * rate success probability is less than 75%, limit A-MSDU to twice the usual
 	 * data packet size
 	 */
-	if (g->duration[rate] > MCS_DURATION(1, 0, 260) ||
+	if (duration > MCS_DURATION(1, 0, 260) ||
 	    (minstrel_ht_get_prob_ewma(mi, mi->max_tp_rate[0]) <
 	     MINSTREL_FRAC(75, 100)))
 		return 3200;
@@ -946,13 +972,6 @@ minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 	rate_control_set_rates(mp->hw, mi->sta, rates);
 }
 
-static inline int
-minstrel_get_duration(int index)
-{
-	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
-	return group->duration[index % MCS_GROUP_RATES];
-}
-
 static int
 minstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 {
@@ -1000,10 +1019,13 @@ minstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 		return -1;
 
 	/*
-	 * Do not sample if the probability is already higher than 95%
-	 * to avoid wasting airtime.
+	 * Do not sample if the probability is already higher than 95%,
+	 * or if the rate is 3 times slower than the current max probability
+	 * rate, to avoid wasting airtime.
 	 */
-	if (mrs->prob_ewma > MINSTREL_FRAC(95, 100))
+	sample_dur = minstrel_get_duration(sample_idx);
+	if (mrs->prob_ewma > MINSTREL_FRAC(95, 100) ||
+	    minstrel_get_duration(mi->max_prob_rate) * 3 < sample_dur)
 		return -1;
 
 	/*
@@ -1013,7 +1035,6 @@ minstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 
 	cur_max_tp_streams = minstrel_mcs_groups[tp_rate1 /
 		MCS_GROUP_RATES].streams;
-	sample_dur = minstrel_get_duration(sample_idx);
 	if (sample_dur >= minstrel_get_duration(tp_rate2) &&
 	    (cur_max_tp_streams - 1 <
 	     minstrel_mcs_groups[sample_group].streams ||
@@ -1077,18 +1098,23 @@ minstrel_ht_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,
 		return;
 
 	sample_group = &minstrel_mcs_groups[sample_idx / MCS_GROUP_RATES];
+	sample_idx %= MCS_GROUP_RATES;
+
+	if (sample_group == &minstrel_mcs_groups[MINSTREL_CCK_GROUP] &&
+	    (sample_idx >= 4) != txrc->short_preamble)
+		return;
+
 	info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
 	rate->count = 1;
 
-	if (sample_idx / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) {
+	if (sample_group == &minstrel_mcs_groups[MINSTREL_CCK_GROUP]) {
 		int idx = sample_idx % ARRAY_SIZE(mp->cck_rates);
 		rate->idx = mp->cck_rates[idx];
 	} else if (sample_group->flags & IEEE80211_TX_RC_VHT_MCS) {
 		ieee80211_rate_set_vht(rate, sample_idx % MCS_GROUP_RATES,
 				       sample_group->streams);
 	} else {
-		rate->idx = sample_idx % MCS_GROUP_RATES +
-			    (sample_group->streams - 1) * 8;
+		rate->idx = sample_idx + (sample_group->streams - 1) * 8;
 	}
 
 	rate->flags = sample_group->flags;
@@ -1130,14 +1156,14 @@ minstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
 	struct minstrel_ht_sta_priv *msp = priv_sta;
 	struct minstrel_ht_sta *mi = &msp->ht;
 	struct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;
-	u16 sta_cap = sta->ht_cap.cap;
+	u16 ht_cap = sta->ht_cap.cap;
 	struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;
-	struct sta_info *sinfo = container_of(sta, struct sta_info, sta);
 	int use_vht;
 	int n_supported = 0;
 	int ack_dur;
 	int stbc;
 	int i;
+	bool ldpc = false;
 
 	/* fall back to the old minstrel for legacy stations */
 	if (!sta->ht_cap.ht_supported)
@@ -1145,12 +1171,10 @@ minstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
 
 	BUILD_BUG_ON(ARRAY_SIZE(minstrel_mcs_groups) != MINSTREL_GROUPS_NB);
 
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
 	if (vht_cap->vht_supported)
 		use_vht = vht_cap->vht_mcs.tx_mcs_map != cpu_to_le16(~0);
 	else
-#endif
-	use_vht = 0;
+		use_vht = 0;
 
 	msp->is_ht = true;
 	memset(mi, 0, sizeof(*mi));
@@ -1175,16 +1199,24 @@ minstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
 	}
 	mi->sample_tries = 4;
 
-	/* TODO tx_flags for vht - ATM the RC API is not fine-grained enough */
 	if (!use_vht) {
-		stbc = (sta_cap & IEEE80211_HT_CAP_RX_STBC) >>
+		stbc = (ht_cap & IEEE80211_HT_CAP_RX_STBC) >>
 			IEEE80211_HT_CAP_RX_STBC_SHIFT;
-		mi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;
 
-		if (sta_cap & IEEE80211_HT_CAP_LDPC_CODING)
-			mi->tx_flags |= IEEE80211_TX_CTL_LDPC;
+		if (ht_cap & IEEE80211_HT_CAP_LDPC_CODING)
+			ldpc = true;
+	} else {
+		stbc = (vht_cap->cap & IEEE80211_VHT_CAP_RXSTBC_MASK) >>
+			IEEE80211_VHT_CAP_RXSTBC_SHIFT;
+
+		if (vht_cap->cap & IEEE80211_VHT_CAP_RXLDPC)
+			ldpc = true;
 	}
 
+	mi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;
+	if (ldpc)
+		mi->tx_flags |= IEEE80211_TX_CTL_LDPC;
+
 	for (i = 0; i < ARRAY_SIZE(mi->groups); i++) {
 		u32 gflags = minstrel_mcs_groups[i].flags;
 		int bw, nss;
@@ -1197,10 +1229,10 @@ minstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
 
 		if (gflags & IEEE80211_TX_RC_SHORT_GI) {
 			if (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH) {
-				if (!(sta_cap & IEEE80211_HT_CAP_SGI_40))
+				if (!(ht_cap & IEEE80211_HT_CAP_SGI_40))
 					continue;
 			} else {
-				if (!(sta_cap & IEEE80211_HT_CAP_SGI_20))
+				if (!(ht_cap & IEEE80211_HT_CAP_SGI_20))
 					continue;
 			}
 		}
@@ -1217,10 +1249,9 @@ minstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
 
 		/* HT rate */
 		if (gflags & IEEE80211_TX_RC_MCS) {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
 			if (use_vht && minstrel_vht_only)
 				continue;
-#endif
+
 			mi->supported[i] = mcs->rx_mask[nss - 1];
 			if (mi->supported[i])
 				n_supported++;
@@ -1258,8 +1289,7 @@ minstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,
 	if (!n_supported)
 		goto use_legacy;
 
-	if (test_sta_flag(sinfo, WLAN_STA_SHORT_PREAMBLE))
-		mi->cck_supported_short |= mi->cck_supported_short << 4;
+	mi->supported[MINSTREL_CCK_GROUP] |= mi->cck_supported_short << 4;
 
 	/* create an initial rate table with the lowest supported rates */
 	minstrel_ht_update_stats(mp, mi);
@@ -1340,16 +1370,88 @@ minstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
 	kfree(msp);
 }
 
+static void
+minstrel_ht_init_cck_rates(struct minstrel_priv *mp)
+{
+	static const int bitrates[4] = { 10, 20, 55, 110 };
+	struct ieee80211_supported_band *sband;
+	u32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);
+	int i, j;
+
+	sband = mp->hw->wiphy->bands[NL80211_BAND_2GHZ];
+	if (!sband)
+		return;
+
+	for (i = 0, j = 0; i < sband->n_bitrates; i++) {
+		struct ieee80211_rate *rate = &sband->bitrates[i];
+
+		if (rate->flags & IEEE80211_RATE_ERP_G)
+			continue;
+
+		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
+			continue;
+
+		for (j = 0; j < ARRAY_SIZE(bitrates); j++) {
+			if (rate->bitrate != bitrates[j])
+				continue;
+
+			mp->cck_rates[j] = i;
+			break;
+		}
+	}
+}
+
 static void *
 minstrel_ht_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
 {
-	return mac80211_minstrel.alloc(hw, debugfsdir);
+	struct minstrel_priv *mp;
+
+	mp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);
+	if (!mp)
+		return NULL;
+
+	/* contention window settings
+	 * Just an approximation. Using the per-queue values would complicate
+	 * the calculations and is probably unnecessary */
+	mp->cw_min = 15;
+	mp->cw_max = 1023;
+
+	/* number of packets (in %) to use for sampling other rates
+	 * sample less often for non-mrr packets, because the overhead
+	 * is much higher than with mrr */
+	mp->lookaround_rate = 5;
+	mp->lookaround_rate_mrr = 10;
+
+	/* maximum time that the hw is allowed to stay in one MRR segment */
+	mp->segment_size = 6000;
+
+	if (hw->max_rate_tries > 0)
+		mp->max_retry = hw->max_rate_tries;
+	else
+		/* safe default, does not necessarily have to match hw properties */
+		mp->max_retry = 7;
+
+	if (hw->max_rates >= 4)
+		mp->has_mrr = true;
+
+	mp->hw = hw;
+	mp->update_interval = 100;
+
+#ifdef CPTCFG_MAC80211_DEBUGFS
+	mp->fixed_rate_idx = (u32) -1;
+	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
+			   &mp->fixed_rate_idx);
+#endif
+
+	minstrel_ht_init_cck_rates(mp);
+
+	return mp;
 }
 
 static void
 minstrel_ht_free(void *priv)
 {
-	mac80211_minstrel.free(priv);
+	kfree(priv);
 }
 
 static u32 minstrel_ht_get_expected_throughput(void *priv_sta)
@@ -1384,7 +1486,6 @@ static const struct rate_control_ops mac80211_minstrel_ht = {
 	.free = minstrel_ht_free,
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	.add_sta_debugfs = minstrel_ht_add_sta_debugfs,
-	.remove_sta_debugfs = minstrel_ht_remove_sta_debugfs,
 #endif
 	.get_expected_throughput = minstrel_ht_get_expected_throughput,
 };
@@ -1409,14 +1510,14 @@ static void __init init_sample_table(void)
 }
 
 int __init
-rc80211_minstrel_ht_init(void)
+rc80211_minstrel_init(void)
 {
 	init_sample_table();
 	return ieee80211_rate_control_register(&mac80211_minstrel_ht);
 }
 
 void
-rc80211_minstrel_ht_exit(void)
+rc80211_minstrel_exit(void)
 {
 	ieee80211_rate_control_unregister(&mac80211_minstrel_ht);
 }
diff --git a/net/mac80211/rc80211_minstrel_ht.h b/net/mac80211/rc80211_minstrel_ht.h
index 9bc0e66..26b7a32 100644
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -15,11 +15,7 @@
  */
 #define MINSTREL_MAX_STREAMS		3
 #define MINSTREL_HT_STREAM_GROUPS	4 /* BW(=2) * SGI(=2) */
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
 #define MINSTREL_VHT_STREAM_GROUPS	6 /* BW(=3) * SGI(=2) */
-#else
-#define MINSTREL_VHT_STREAM_GROUPS	0
-#endif
 
 #define MINSTREL_HT_GROUPS_NB	(MINSTREL_MAX_STREAMS *		\
 				 MINSTREL_HT_STREAM_GROUPS)
@@ -34,16 +30,13 @@
 #define MINSTREL_CCK_GROUP	(MINSTREL_HT_GROUP_0 + MINSTREL_HT_GROUPS_NB)
 #define MINSTREL_VHT_GROUP_0	(MINSTREL_CCK_GROUP + 1)
 
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
 #define MCS_GROUP_RATES		10
-#else
-#define MCS_GROUP_RATES		8
-#endif
 
 struct mcs_group {
-	u32 flags;
-	unsigned int streams;
-	unsigned int duration[MCS_GROUP_RATES];
+	u16 flags;
+	u8 streams;
+	u8 shift;
+	u16 duration[MCS_GROUP_RATES];
 };
 
 extern const struct mcs_group minstrel_mcs_groups[];
@@ -110,17 +103,12 @@ struct minstrel_ht_sta_priv {
 		struct minstrel_ht_sta ht;
 		struct minstrel_sta_info legacy;
 	};
-#ifdef CPTCFG_MAC80211_DEBUGFS
-	struct dentry *dbg_stats;
-	struct dentry *dbg_stats_csv;
-#endif
 	void *ratelist;
 	void *sample_table;
 	bool is_ht;
 };
 
 void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
-void minstrel_ht_remove_sta_debugfs(void *priv, void *priv_sta);
 int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
 			   int prob_ewma);
 
diff --git a/net/mac80211/rc80211_minstrel_ht_debugfs.c b/net/mac80211/rc80211_minstrel_ht_debugfs.c
index bfcc031..c3ffafb 100644
--- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
+++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
@@ -15,6 +15,22 @@
 #include "rc80211_minstrel.h"
 #include "rc80211_minstrel_ht.h"
 
+static ssize_t
+minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos)
+{
+	struct minstrel_debugfs_info *ms;
+
+	ms = file->private_data;
+	return simple_read_from_buffer(buf, len, ppos, ms->buf, ms->len);
+}
+
+static int
+minstrel_stats_release(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	return 0;
+}
+
 static char *
 minstrel_ht_stats_dump(struct minstrel_ht_sta *mi, int i, char *p)
 {
@@ -42,6 +58,7 @@ minstrel_ht_stats_dump(struct minstrel_ht_sta *mi, int i, char *p)
 		static const int bitrates[4] = { 10, 20, 55, 110 };
 		int idx = i * MCS_GROUP_RATES + j;
 		unsigned int prob_ewmsd;
+		unsigned int duration;
 
 		if (!(mi->supported[i] & BIT(j)))
 			continue;
@@ -79,7 +96,9 @@ minstrel_ht_stats_dump(struct minstrel_ht_sta *mi, int i, char *p)
 		p += sprintf(p, "  %3u  ", idx);
 
 		/* tx_time[rate(i)] in usec */
-		tx_time = DIV_ROUND_CLOSEST(mg->duration[j], 1000);
+		duration = mg->duration[j];
+		duration <<= mg->shift;
+		tx_time = DIV_ROUND_CLOSEST(duration, 1000);
 		p += sprintf(p, "%6u  ", tx_time);
 
 		tp_max = minstrel_ht_get_tp_avg(mi, i, j, MINSTREL_FRAC(100, 100));
@@ -144,9 +163,10 @@ minstrel_ht_stats_open(struct inode *inode, struct file *file)
 			"lookaround %d\n",
 			max(0, (int) mi->total_packets - (int) mi->sample_packets),
 			mi->sample_packets);
-	p += sprintf(p, "Average # of aggregated frames per A-MPDU: %d.%d\n",
-		MINSTREL_TRUNC(mi->avg_ampdu_len),
-		MINSTREL_TRUNC(mi->avg_ampdu_len * 10) % 10);
+	if (mi->avg_ampdu_len)
+		p += sprintf(p, "Average # of aggregated frames per A-MPDU: %d.%d\n",
+			MINSTREL_TRUNC(mi->avg_ampdu_len),
+			MINSTREL_TRUNC(mi->avg_ampdu_len * 10) % 10);
 	ms->len = p - ms->buf;
 	WARN_ON(ms->len + sizeof(*ms) > 32768);
 
@@ -188,6 +208,7 @@ minstrel_ht_stats_csv_dump(struct minstrel_ht_sta *mi, int i, char *p)
 		static const int bitrates[4] = { 10, 20, 55, 110 };
 		int idx = i * MCS_GROUP_RATES + j;
 		unsigned int prob_ewmsd;
+		unsigned int duration;
 
 		if (!(mi->supported[i] & BIT(j)))
 			continue;
@@ -222,7 +243,10 @@ minstrel_ht_stats_csv_dump(struct minstrel_ht_sta *mi, int i, char *p)
 		}
 
 		p += sprintf(p, "%u,", idx);
-		tx_time = DIV_ROUND_CLOSEST(mg->duration[j], 1000);
+
+		duration = mg->duration[j];
+		duration <<= mg->shift;
+		tx_time = DIV_ROUND_CLOSEST(duration, 1000);
 		p += sprintf(p, "%u,", tx_time);
 
 		tp_max = minstrel_ht_get_tp_avg(mi, i, j, MINSTREL_FRAC(100, 100));
@@ -303,17 +327,8 @@ minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir)
 {
 	struct minstrel_ht_sta_priv *msp = priv_sta;
 
-	msp->dbg_stats = debugfs_create_file("rc_stats", 0444, dir, msp,
-					     &minstrel_ht_stat_fops);
-	msp->dbg_stats_csv = debugfs_create_file("rc_stats_csv", 0444, dir, msp,
-						 &minstrel_ht_stat_csv_fops);
-}
-
-void
-minstrel_ht_remove_sta_debugfs(void *priv, void *priv_sta)
-{
-	struct minstrel_ht_sta_priv *msp = priv_sta;
-
-	debugfs_remove(msp->dbg_stats);
-	debugfs_remove(msp->dbg_stats_csv);
+	debugfs_create_file("rc_stats", S_IRUGO, dir, msp,
+			    &minstrel_ht_stat_fops);
+	debugfs_create_file("rc_stats_csv", S_IRUGO, dir, msp,
+			    &minstrel_ht_stat_csv_fops);
 }
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 4638ade..e1c1e6b 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -1508,7 +1508,15 @@ static void sta_ps_start(struct sta_info *sta)
 		return;
 
 	for (tid = 0; tid < ARRAY_SIZE(sta->sta.txq); tid++) {
-		if (txq_has_queue(sta->sta.txq[tid]))
+		struct ieee80211_txq *txq = sta->sta.txq[tid];
+		struct txq_info *txqi = to_txq_info(txq);
+
+		spin_lock(&local->active_txq_lock[txq->ac]);
+		if (!list_empty(&txqi->schedule_order))
+			list_del_init(&txqi->schedule_order);
+		spin_unlock(&local->active_txq_lock[txq->ac]);
+
+		if (txq_has_queue(txq))
 			set_bit(tid, &sta->txq_buffered_tids);
 		else
 			clear_bit(tid, &sta->txq_buffered_tids);
@@ -2597,7 +2605,7 @@ ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)
 	struct ieee80211_local *local = rx->local;
 	struct ieee80211_sub_if_data *sdata = rx->sdata;
 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
-	u16 ac, q, hdrlen;
+	u16 ac, q, hdrlen, padsize;
 	int tailroom = 0;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
@@ -2690,7 +2698,9 @@ ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)
 	if (sdata->crypto_tx_tailroom_needed_cnt)
 		tailroom = IEEE80211_ENCRYPT_TAILROOM;
 
-	fwd_skb = skb_copy_expand(skb, local->tx_headroom +
+	padsize = ieee80211_hdr_padsize(&local->hw, hdrlen);
+
+	fwd_skb = skb_copy_expand(skb, local->tx_headroom + padsize +
 				       sdata->encrypt_headroom,
 				  tailroom, GFP_ATOMIC);
 	if (!fwd_skb)
@@ -2722,6 +2732,12 @@ ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)
 		return RX_DROP_MONITOR;
 	}
 
+	if (padsize) {
+		skb_push(fwd_skb, padsize);
+		memmove(fwd_skb->data, skb->data + padsize, hdrlen);
+		memset(fwd_skb->data + hdrlen, 0, padsize);
+	}
+
 	IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);
 	ieee80211_add_pending_skb(local, fwd_skb);
  out:
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index f639f15..dbd8c54 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -90,7 +90,6 @@ static void __cleanup_single_sta(struct sta_info *sta)
 	struct tid_ampdu_tx *tid_tx;
 	struct ieee80211_sub_if_data *sdata = sta->sdata;
 	struct ieee80211_local *local = sdata->local;
-	struct fq *fq = &local->fq;
 	struct ps_data *ps;
 
 	if (test_sta_flag(sta, WLAN_STA_PS_STA) ||
@@ -115,9 +114,7 @@ static void __cleanup_single_sta(struct sta_info *sta)
 		for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
 			struct txq_info *txqi = to_txq_info(sta->sta.txq[i]);
 
-			spin_lock_bh(&fq->lock);
 			ieee80211_txq_purge(local, txqi);
-			spin_unlock_bh(&fq->lock);
 		}
 	}
 
@@ -381,9 +378,12 @@ struct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 	if (sta_prepare_rate_control(local, sta, gfp))
 		goto free_txq;
 
+	sta->airtime_weight = IEEE80211_DEFAULT_AIRTIME_WEIGHT;
+
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		skb_queue_head_init(&sta->ps_tx_buf[i]);
 		skb_queue_head_init(&sta->tx_filtered[i]);
+		sta->airtime[i].deficit = sta->airtime_weight;
 	}
 
 	for (i = 0; i < IEEE80211_NUM_TIDS; i++)
@@ -1244,7 +1244,7 @@ void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
 			if (!txq_has_queue(sta->sta.txq[i]))
 				continue;
 
-			drv_wake_tx_queue(local, to_txq_info(sta->sta.txq[i]));
+			schedule_and_wake_txq(local, to_txq_info(sta->sta.txq[i]));
 		}
 	}
 
@@ -1821,6 +1821,27 @@ void ieee80211_sta_set_buffered(struct ieee80211_sta *pubsta,
 }
 EXPORT_SYMBOL(ieee80211_sta_set_buffered);
 
+void ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,
+				    u32 tx_airtime, u32 rx_airtime)
+{
+	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+	struct ieee80211_local *local = sta->sdata->local;
+	u8 ac = ieee80211_ac_from_tid(tid);
+	u32 airtime = 0;
+
+	if (sta->local->airtime_flags & AIRTIME_USE_TX)
+		airtime += tx_airtime;
+	if (sta->local->airtime_flags & AIRTIME_USE_RX)
+		airtime += rx_airtime;
+
+	spin_lock_bh(&local->active_txq_lock[ac]);
+	sta->airtime[ac].tx_airtime += tx_airtime;
+	sta->airtime[ac].rx_airtime += rx_airtime;
+	sta->airtime[ac].deficit -= airtime;
+	spin_unlock_bh(&local->active_txq_lock[ac]);
+}
+EXPORT_SYMBOL(ieee80211_sta_register_airtime);
+
 int sta_info_move_state(struct sta_info *sta,
 			enum ieee80211_sta_state new_state)
 {
@@ -2183,6 +2204,23 @@ void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
 	}
 
+	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_DURATION))) {
+		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+			sinfo->rx_duration += sta->airtime[ac].rx_airtime;
+		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);
+	}
+
+	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_DURATION))) {
+		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
+			sinfo->tx_duration += sta->airtime[ac].tx_airtime;
+		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_DURATION);
+	}
+
+	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT))) {
+		sinfo->airtime_weight = sta->airtime_weight;
+		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT);
+	}
+
 	sinfo->rx_dropped_misc = sta->rx_stats.dropped;
 	if (sta->pcpu_rx_stats) {
 		for_each_possible_cpu(cpu) {
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index a8b984f..51a7b13 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -127,6 +127,16 @@ enum ieee80211_agg_stop_reason {
 	AGG_STOP_DESTROY_STA,
 };
 
+/* Debugfs flags to enable/disable use of RX/TX airtime in scheduler */
+#define AIRTIME_USE_TX		BIT(0)
+#define AIRTIME_USE_RX		BIT(1)
+
+struct airtime_info {
+	u64 rx_airtime;
+	u64 tx_airtime;
+	s64 deficit;
+};
+
 struct sta_info;
 
 /**
@@ -301,7 +311,7 @@ struct ieee80211_fast_tx {
 	u8 hdr_len;
 	u8 sa_offs, da_offs, pn_offs;
 	u8 band;
-	u8 hdr[30 + 2 + IEEE80211_FAST_XMIT_MAX_IV +
+	u8 hdr[30 + 2 + 2 + IEEE80211_FAST_XMIT_MAX_IV +
 	       sizeof(rfc1042_header)] __aligned(2);
 
 	struct rcu_head rcu_head;
@@ -563,6 +573,9 @@ struct sta_info {
 	} tx_stats;
 	u16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];
 
+	struct airtime_info airtime[IEEE80211_NUM_ACS];
+	u16 airtime_weight;
+
 	/*
 	 * Aggregation information, locked with lock.
 	 */
diff --git a/net/mac80211/status.c b/net/mac80211/status.c
index 46dcd07..70fa27f 100644
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -515,6 +515,7 @@ static void ieee80211_report_used_skb(struct ieee80211_local *local,
 {
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr = (void *)skb->data;
+	struct ieee80211_hw *hw = &local->hw;
 	bool acked = info->flags & IEEE80211_TX_STAT_ACK;
 
 	if (dropped)
@@ -531,7 +532,7 @@ static void ieee80211_report_used_skb(struct ieee80211_local *local,
 			skb->dev = NULL;
 		} else {
 			unsigned int hdr_size =
-				ieee80211_hdrlen(hdr->frame_control);
+				ieee80211_padded_hdrlen(hw, hdr->frame_control);
 
 			/* Check to see if packet is a TDLS teardown packet */
 			if (ieee80211_is_data(hdr->frame_control) &&
@@ -655,9 +656,27 @@ void ieee80211_tx_monitor(struct ieee80211_local *local, struct sk_buff *skb,
 	struct sk_buff *skb2;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_hdr *hdr = (void *)skb->data;
 	struct net_device *prev_dev = NULL;
+	unsigned int hdrlen, padsize;
 	int rtap_len;
 
+	/* Remove padding if was added */
+	if (ieee80211_hw_check(&local->hw, TX_NEEDS_ALIGNED4_SKBS)) {
+		hdrlen = ieee80211_hdrlen(hdr->frame_control);
+		padsize = ieee80211_hdr_padsize(&local->hw, hdrlen);
+
+		if (padsize && skb->len > hdrlen + padsize) {
+			memmove(skb->data + padsize, skb->data, hdrlen);
+			skb_pull(skb, padsize);
+		}
+	}
+
+	if (ieee80211_skb_resize(local, NULL, skb, 0, 0)) {
+		dev_kfree_skb(skb);
+		return;
+	}
+
 	/* send frame to monitor interfaces now */
 	rtap_len = ieee80211_tx_radiotap_len(info);
 	if (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {
@@ -825,6 +844,12 @@ static void __ieee80211_tx_status(struct ieee80211_hw *hw,
 			ieee80211_sta_tx_notify(sta->sdata, (void *) skb->data,
 						acked, info->status.tx_time);
 
+		if (info->status.tx_time &&
+		    wiphy_ext_feature_isset(local->hw.wiphy,
+					    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
+			ieee80211_sta_register_airtime(&sta->sta, tid,
+						       info->status.tx_time, 0);
+
 		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
 			if (info->flags & IEEE80211_TX_STAT_ACK) {
 				if (sta->status_stats.lost_packets)
diff --git a/net/mac80211/tkip.c b/net/mac80211/tkip.c
index b362282..505026e 100644
--- a/net/mac80211/tkip.c
+++ b/net/mac80211/tkip.c
@@ -201,10 +201,12 @@ void ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,
 {
 	struct ieee80211_key *key = (struct ieee80211_key *)
 			container_of(keyconf, struct ieee80211_key, conf);
+	struct ieee80211_hw *hw = &key->local->hw;
 	const u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];
 	struct tkip_ctx *ctx = &key->u.tkip.tx;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
+	const u8 *data = (u8 *)hdr + ieee80211_padded_hdrlen(hw,
+							hdr->frame_control);
 	u32 iv32 = get_unaligned_le32(&data[4]);
 	u16 iv16 = data[2] | (data[0] << 8);
 
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 98da714..600390d 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -925,7 +925,7 @@ ieee80211_tx_h_fragment(struct ieee80211_tx_data *tx)
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr = (void *)skb->data;
 	int frag_threshold = tx->local->hw.wiphy->frag_threshold;
-	int hdrlen;
+	int hdrlen = tx->hdrlen;
 	int fragnum;
 
 	/* no matter what happens, tx->skb moves to tx->skbs */
@@ -946,8 +946,6 @@ ieee80211_tx_h_fragment(struct ieee80211_tx_data *tx)
 	if (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))
 		return TX_DROP;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-
 	/* internal error, why isn't DONTFRAG set? */
 	if (WARN_ON(skb->len + FCS_LEN <= frag_threshold))
 		return TX_DROP;
@@ -1177,6 +1175,7 @@ ieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,
 	info->flags &= ~IEEE80211_TX_INTFL_NEED_TXPROCESSING;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
+	tx->hdrlen = ieee80211_padded_hdrlen(&local->hw, hdr->frame_control);
 
 	if (likely(sta)) {
 		if (!IS_ERR(sta))
@@ -1391,11 +1390,15 @@ static void ieee80211_txq_enqueue(struct ieee80211_local *local,
 {
 	struct fq *fq = &local->fq;
 	struct fq_tin *tin = &txqi->tin;
+	u32 flow_idx = fq_flow_idx(fq, skb);
 
 	ieee80211_set_skb_enqueue_time(skb);
-	fq_tin_enqueue(fq, tin, skb,
+
+	spin_lock_bh(&fq->lock);
+	fq_tin_enqueue(fq, tin, flow_idx, skb,
 		       fq_skb_free_func,
 		       fq_flow_get_default_func);
+	spin_unlock_bh(&fq->lock);
 }
 
 static bool fq_vlan_filter_func(struct fq *fq, struct fq_tin *tin,
@@ -1441,6 +1444,7 @@ void ieee80211_txq_init(struct ieee80211_sub_if_data *sdata,
 	codel_vars_init(&txqi->def_cvars);
 	codel_stats_init(&txqi->cstats);
 	__skb_queue_head_init(&txqi->frags);
+	INIT_LIST_HEAD(&txqi->schedule_order);
 
 	txqi->txq.vif = &sdata->vif;
 
@@ -1462,8 +1466,14 @@ void ieee80211_txq_purge(struct ieee80211_local *local,
 	struct fq *fq = &local->fq;
 	struct fq_tin *tin = &txqi->tin;
 
+	spin_lock_bh(&fq->lock);
 	fq_tin_reset(fq, tin, fq_skb_free_func);
 	ieee80211_purge_tx_queue(&local->hw, &txqi->frags);
+	spin_unlock_bh(&fq->lock);
+
+	spin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);
+	list_del_init(&txqi->schedule_order);
+	spin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);
 }
 
 void ieee80211_txq_set_params(struct ieee80211_local *local)
@@ -1558,7 +1568,6 @@ static bool ieee80211_queue_skb(struct ieee80211_local *local,
 				struct sta_info *sta,
 				struct sk_buff *skb)
 {
-	struct fq *fq = &local->fq;
 	struct ieee80211_vif *vif;
 	struct txq_info *txqi;
 
@@ -1576,11 +1585,9 @@ static bool ieee80211_queue_skb(struct ieee80211_local *local,
 	if (!txqi)
 		return false;
 
-	spin_lock_bh(&fq->lock);
 	ieee80211_txq_enqueue(local, txqi, skb);
-	spin_unlock_bh(&fq->lock);
 
-	drv_wake_tx_queue(local, txqi);
+	schedule_and_wake_txq(local, txqi);
 
 	return true;
 }
@@ -1907,37 +1914,53 @@ static bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,
 }
 
 /* device xmit handlers */
-
-static int ieee80211_skb_resize(struct ieee80211_sub_if_data *sdata,
-				struct sk_buff *skb,
-				int head_need, bool may_encrypt)
+int ieee80211_skb_resize(struct ieee80211_local *local,
+			 struct ieee80211_sub_if_data *sdata,
+			 struct sk_buff *skb, int hdr_len, int hdr_extra)
 {
-	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr;
-	bool enc_tailroom;
-	int tail_need = 0;
+	int head_need, head_max;
+	int tail_need, tail_max;
+	bool enc_tailroom = false;
 
-	hdr = (struct ieee80211_hdr *) skb->data;
-	enc_tailroom = may_encrypt &&
-		       (sdata->crypto_tx_tailroom_needed_cnt ||
-			ieee80211_is_mgmt(hdr->frame_control));
-
-	if (enc_tailroom) {
-		tail_need = IEEE80211_ENCRYPT_TAILROOM;
-		tail_need -= skb_tailroom(skb);
-		tail_need = max_t(int, tail_need, 0);
+	if (sdata && !hdr_len &&
+	    !(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)) {
+		hdr = (struct ieee80211_hdr *) skb->data;
+		enc_tailroom = (sdata->crypto_tx_tailroom_needed_cnt ||
+				ieee80211_is_mgmt(hdr->frame_control));
+		hdr_len += sdata->encrypt_headroom;
+	}
+
+	head_need = head_max = hdr_len;
+	tail_need = tail_max = 0;
+	if (!sdata) {
+		head_need = head_max = local->tx_headroom;
+	} else {
+		head_max += hdr_extra;
+		head_max += max_t(int, local->tx_headroom,
+				  local->hw.extra_tx_headroom);
+		head_need += local->hw.extra_tx_headroom;
+
+		tail_max = IEEE80211_ENCRYPT_TAILROOM;
+		if (enc_tailroom)
+			tail_need = tail_max;
 	}
 
 	if (skb_cloned(skb) &&
 	    (!ieee80211_hw_check(&local->hw, SUPPORTS_CLONED_SKBS) ||
 	     !skb_clone_writable(skb, ETH_HLEN) || enc_tailroom))
 		I802_DEBUG_INC(local->tx_expand_skb_head_cloned);
-	else if (head_need || tail_need)
+	else if (head_need > skb_headroom(skb) ||
+		 tail_need > skb_tailroom(skb))
 		I802_DEBUG_INC(local->tx_expand_skb_head);
 	else
 		return 0;
 
-	if (pskb_expand_head(skb, head_need, tail_need, GFP_ATOMIC)) {
+	head_max = max_t(int, 0, head_max - skb_headroom(skb));
+	tail_max = max_t(int, 0, tail_max - skb_tailroom(skb));
+
+	if (pskb_expand_head(skb, head_max, tail_max, GFP_ATOMIC)) {
 		wiphy_debug(local->hw.wiphy,
 			    "failed to reallocate TX buffer\n");
 		return -ENOMEM;
@@ -1953,18 +1976,8 @@ void ieee80211_xmit(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_local *local = sdata->local;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_hdr *hdr;
-	int headroom;
-	bool may_encrypt;
-
-	may_encrypt = !(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT);
 
-	headroom = local->tx_headroom;
-	if (may_encrypt)
-		headroom += sdata->encrypt_headroom;
-	headroom -= skb_headroom(skb);
-	headroom = max_t(int, 0, headroom);
-
-	if (ieee80211_skb_resize(sdata, skb, headroom, may_encrypt)) {
+	if (ieee80211_skb_resize(local, sdata, skb, 0, 0)) {
 		ieee80211_free_txskb(&local->hw, skb);
 		return;
 	}
@@ -2215,7 +2228,7 @@ netdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,
 		goto fail;
 
 	hdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = ieee80211_padded_hdrlen(&local->hw, hdr->frame_control);
 
 	if (skb->len < len_rthdr + hdrlen)
 		goto fail;
@@ -2433,7 +2446,7 @@ static struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_chanctx_conf *chanctx_conf;
 	struct ieee80211_sub_if_data *ap_sdata;
 	enum nl80211_band band;
-	int ret;
+	int padsize, ret;
 
 	if (IS_ERR(sta))
 		sta = NULL;
@@ -2732,29 +2745,15 @@ static struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,
 	}
 
 	skb_pull(skb, skip_header_bytes);
-	head_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);
+	padsize = ieee80211_hdr_padsize(&local->hw, hdrlen);
+	head_need = hdrlen + encaps_len + meshhdrlen;
+	head_need += padsize;
 
-	/*
-	 * So we need to modify the skb header and hence need a copy of
-	 * that. The head_need variable above doesn't, so far, include
-	 * the needed header space that we don't need right away. If we
-	 * can, then we don't reallocate right now but only after the
-	 * frame arrives at the master device (if it does...)
-	 *
-	 * If we cannot, however, then we will reallocate to include all
-	 * the ever needed space. Also, if we need to reallocate it anyway,
-	 * make it big enough for everything we may ever need.
-	 */
-
-	if (head_need > 0 || skb_cloned(skb)) {
-		head_need += sdata->encrypt_headroom;
-		head_need += local->tx_headroom;
-		head_need = max_t(int, 0, head_need);
-		if (ieee80211_skb_resize(sdata, skb, head_need, true)) {
-			ieee80211_free_txskb(&local->hw, skb);
-			skb = NULL;
-			return ERR_PTR(-ENOMEM);
-		}
+	if (ieee80211_skb_resize(local, sdata, skb, head_need,
+				 sdata->encrypt_headroom)) {
+		ieee80211_free_txskb(&local->hw, skb);
+		skb = NULL;
+		return ERR_PTR(-ENOMEM);
 	}
 
 	if (encaps_data)
@@ -2765,6 +2764,9 @@ static struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,
 		memcpy(skb_push(skb, meshhdrlen), &mesh_hdr, meshhdrlen);
 #endif
 
+	if (padsize)
+		memset(skb_push(skb, padsize), 0, padsize);
+
 	if (ieee80211_is_data_qos(fc)) {
 		__le16 *qos_control;
 
@@ -2940,6 +2942,8 @@ void ieee80211_check_fast_xmit(struct sta_info *sta)
 		fc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);
 	}
 
+	build.hdr_len += ieee80211_hdr_padsize(&local->hw, build.hdr_len);
+
 	/* We store the key here so there's no point in using rcu_dereference()
 	 * but that's fine because the code that changes the pointers will call
 	 * this function after doing so. For a single CPU that would be enough,
@@ -3185,6 +3189,8 @@ static bool ieee80211_amsdu_aggregate(struct ieee80211_sub_if_data *sdata,
 	u8 max_subframes = sta->sta.max_amsdu_subframes;
 	int max_frags = local->hw.max_tx_fragments;
 	int max_amsdu_len = sta->sta.max_amsdu_len;
+	u32 flow_idx;
+	int orig_truesize;
 	__be16 len;
 	void *data;
 	bool ret = false;
@@ -3206,6 +3212,8 @@ static bool ieee80211_amsdu_aggregate(struct ieee80211_sub_if_data *sdata,
 		max_amsdu_len = min_t(int, max_amsdu_len,
 				      sta->sta.max_rc_amsdu_len);
 
+	flow_idx = fq_flow_idx(fq, skb);
+
 	spin_lock_bh(&fq->lock);
 
 	/* TODO: Ideally aggregation should be done on dequeue to remain
@@ -3213,15 +3221,17 @@ static bool ieee80211_amsdu_aggregate(struct ieee80211_sub_if_data *sdata,
 	 */
 
 	tin = &txqi->tin;
-	flow = fq_flow_classify(fq, tin, skb, fq_flow_get_default_func);
+	flow = fq_flow_classify(fq, tin, flow_idx, skb,
+				fq_flow_get_default_func);
 	head = skb_peek_tail(&flow->queue);
 	if (!head)
-		goto out;
+		goto unlock;
 
+	orig_truesize = head->truesize;
 	orig_len = head->len;
 
 	if (skb->len + head->len > max_amsdu_len)
-		goto out;
+		goto unlock;
 
 	nfrags = 1 + skb_shinfo(skb)->nr_frags;
 	nfrags += 1 + skb_shinfo(head)->nr_frags;
@@ -3279,6 +3289,9 @@ out_recalc:
 		fq_recalc_backlog(fq, tin, flow);
 	}
 out:
+	fq->memory_usage += head->truesize - orig_truesize;
+
+unlock:
 	spin_unlock_bh(&fq->lock);
 
 	return ret;
@@ -3354,7 +3367,6 @@ static bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_local *local = sdata->local;
 	u16 ethertype = (skb->data[12] << 8) | skb->data[13];
 	int extra_head = fast_tx->hdr_len - (ETH_HLEN - 2);
-	int hw_headroom = sdata->local->hw.extra_tx_headroom;
 	struct ethhdr eth;
 	struct ieee80211_tx_info *info;
 	struct ieee80211_hdr *hdr = (void *)fast_tx->hdr;
@@ -3406,10 +3418,7 @@ static bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,
 	 * as the may-encrypt argument for the resize to not account for
 	 * more room than we already have in 'extra_head'
 	 */
-	if (unlikely(ieee80211_skb_resize(sdata, skb,
-					  max_t(int, extra_head + hw_headroom -
-						     skb_headroom(skb), 0),
-					  false))) {
+	if (unlikely(ieee80211_skb_resize(local, sdata, skb, extra_head, 0))) {
 		kfree_skb(skb);
 		return true;
 	}
@@ -3482,23 +3491,31 @@ struct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,
 	struct ieee80211_tx_info *info;
 	struct ieee80211_tx_data tx;
 	ieee80211_tx_result r;
-	struct ieee80211_vif *vif;
+	struct ieee80211_vif *vif = txq->vif;
 
+begin:
 	spin_lock_bh(&fq->lock);
 
-	if (test_bit(IEEE80211_TXQ_STOP, &txqi->flags))
+	if (test_bit(IEEE80211_TXQ_STOP, &txqi->flags) ||
+	    test_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags))
 		goto out;
 
+	if (vif->txqs_stopped[ieee80211_ac_from_tid(txq->tid)]) {
+		set_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags);
+		goto out;
+	}
+
 	/* Make sure fragments stay together. */
 	skb = __skb_dequeue(&txqi->frags);
 	if (skb)
 		goto out;
 
-begin:
 	skb = fq_tin_dequeue(fq, tin, fq_tin_dequeue_func);
 	if (!skb)
 		goto out;
 
+	spin_unlock_bh(&fq->lock);
+
 	hdr = (struct ieee80211_hdr *)skb->data;
 	info = IEEE80211_SKB_CB(skb);
 
@@ -3507,6 +3524,7 @@ begin:
 	tx.local = local;
 	tx.skb = skb;
 	tx.sdata = vif_to_sdata(info->control.vif);
+	tx.hdrlen = ieee80211_padded_hdrlen(hw, hdr->frame_control);
 
 	if (txq->sta)
 		tx.sta = container_of(txq->sta, struct sta_info, sta);
@@ -3533,7 +3551,7 @@ begin:
 
 		if (tx.key &&
 		    (tx.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV))
-			pn_offs = ieee80211_hdrlen(hdr->frame_control);
+			pn_offs = tx.hdrlen;
 
 		ieee80211_xmit_fast_finish(sta->sdata, sta, pn_offs,
 					   tx.key, skb);
@@ -3543,8 +3561,11 @@ begin:
 
 		skb = __skb_dequeue(&tx.skbs);
 
-		if (!skb_queue_empty(&tx.skbs))
+		if (!skb_queue_empty(&tx.skbs)) {
+			spin_lock_bh(&fq->lock);
 			skb_queue_splice_tail(&tx.skbs, &txqi->frags);
+			spin_unlock_bh(&fq->lock);
+		}
 	}
 
 	if (skb && skb_has_frag_list(skb) &&
@@ -3583,6 +3604,8 @@ begin:
 	}
 
 	IEEE80211_SKB_CB(skb)->control.vif = vif;
+	return skb;
+
 out:
 	spin_unlock_bh(&fq->lock);
 
@@ -3590,11 +3613,147 @@ out:
 }
 EXPORT_SYMBOL(ieee80211_tx_dequeue);
 
+struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct ieee80211_txq *ret = NULL;
+	struct txq_info *txqi = NULL;
+
+	spin_lock_bh(&local->active_txq_lock[ac]);
+
+ begin:
+	txqi = list_first_entry_or_null(&local->active_txqs[ac],
+					struct txq_info,
+					schedule_order);
+	if (!txqi)
+		goto out;
+
+	if (txqi->txq.sta) {
+		struct sta_info *sta = container_of(txqi->txq.sta,
+						struct sta_info, sta);
+
+		if (sta->airtime[txqi->txq.ac].deficit < 0) {
+			sta->airtime[txqi->txq.ac].deficit +=
+				sta->airtime_weight;
+			list_move_tail(&txqi->schedule_order,
+				       &local->active_txqs[txqi->txq.ac]);
+			goto begin;
+		}
+	}
+
+
+	if (txqi->schedule_round == local->schedule_round[ac])
+		goto out;
+
+	list_del_init(&txqi->schedule_order);
+	txqi->schedule_round = local->schedule_round[ac];
+	ret = &txqi->txq;
+
+out:
+	spin_unlock_bh(&local->active_txq_lock[ac]);
+	return ret;
+}
+EXPORT_SYMBOL(ieee80211_next_txq);
+
+void __ieee80211_schedule_txq(struct ieee80211_hw *hw,
+			      struct ieee80211_txq *txq,
+			      bool force)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct txq_info *txqi = to_txq_info(txq);
+
+	spin_lock_bh(&local->active_txq_lock[txq->ac]);
+
+	if (list_empty(&txqi->schedule_order) &&
+	    (force || !skb_queue_empty(&txqi->frags) ||
+	     txqi->tin.backlog_packets)) {
+		/* If airtime accounting is active, always enqueue STAs at the
+		 * head of the list to ensure that they only get moved to the
+		 * back by the airtime DRR scheduler once they have a negative
+		 * deficit. A station that already has a negative deficit will
+		 * get immediately moved to the back of the list on the next
+		 * call to ieee80211_next_txq().
+		 */
+		if (txqi->txq.sta &&
+		    wiphy_ext_feature_isset(local->hw.wiphy,
+					    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
+			list_add(&txqi->schedule_order,
+				 &local->active_txqs[txq->ac]);
+		else
+			list_add_tail(&txqi->schedule_order,
+				      &local->active_txqs[txq->ac]);
+	}
+
+	spin_unlock_bh(&local->active_txq_lock[txq->ac]);
+}
+EXPORT_SYMBOL(__ieee80211_schedule_txq);
+
+bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
+				struct ieee80211_txq *txq)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+	struct txq_info *iter, *tmp, *txqi = to_txq_info(txq);
+	struct sta_info *sta;
+	u8 ac = txq->ac;
+
+	spin_lock_bh(&local->active_txq_lock[ac]);
+
+	if (!txqi->txq.sta)
+		goto out;
+
+	if (list_empty(&txqi->schedule_order))
+		goto out;
+
+	list_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],
+				 schedule_order) {
+		if (iter == txqi)
+			break;
+
+		if (!iter->txq.sta) {
+			list_move_tail(&iter->schedule_order,
+				       &local->active_txqs[ac]);
+			continue;
+		}
+		sta = container_of(iter->txq.sta, struct sta_info, sta);
+		if (sta->airtime[ac].deficit < 0)
+			sta->airtime[ac].deficit += sta->airtime_weight;
+		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
+	}
+
+	sta = container_of(txqi->txq.sta, struct sta_info, sta);
+	if (sta->airtime[ac].deficit >= 0)
+		goto out;
+
+	sta->airtime[ac].deficit += sta->airtime_weight;
+	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
+	spin_unlock_bh(&local->active_txq_lock[ac]);
+
+	return false;
+out:
+	if (!list_empty(&txqi->schedule_order))
+		list_del_init(&txqi->schedule_order);
+	spin_unlock_bh(&local->active_txq_lock[ac]);
+
+	return true;
+}
+EXPORT_SYMBOL(ieee80211_txq_may_transmit);
+
+void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	spin_lock_bh(&local->active_txq_lock[ac]);
+	local->schedule_round[ac]++;
+	spin_unlock_bh(&local->active_txq_lock[ac]);
+}
+EXPORT_SYMBOL(ieee80211_txq_schedule_start);
+
 void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 				  struct net_device *dev,
 				  u32 info_flags)
 {
 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
 	struct sta_info *sta;
 	struct sk_buff *next;
 
@@ -3608,7 +3767,15 @@ void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 	if (ieee80211_lookup_ra_sta(sdata, skb, &sta))
 		goto out_free;
 
-	if (!IS_ERR_OR_NULL(sta)) {
+	if (IS_ERR(sta))
+		sta = NULL;
+
+	if (local->ops->wake_tx_queue) {
+		u16 queue = __ieee80211_select_queue(sdata, sta, skb);
+		skb_set_queue_mapping(skb, queue);
+	}
+
+	if (sta) {
 		struct ieee80211_fast_tx *fast_tx;
 
 		/* We need a bit of data queued to build aggregates properly, so
@@ -3797,6 +3964,12 @@ out:
 netdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,
 				       struct net_device *dev)
 {
+#if defined(sk_pacing_shift) || LINUX_VERSION_IS_GEQ(4,15,0)
+	if (skb->sk && sk_fullsock(skb->sk) &&
+	    skb->sk->sk_pacing_shift != 6)
+		skb->sk->sk_pacing_shift = 6;
+#endif
+
 	if (unlikely(ieee80211_multicast_to_unicast(skb, dev))) {
 		struct sk_buff_head queue;
 
@@ -3837,6 +4010,7 @@ ieee80211_build_data_template(struct ieee80211_sub_if_data *sdata,
 	hdr = (void *)skb->data;
 	tx.sta = sta_info_get(sdata, hdr->addr1);
 	tx.skb = skb;
+	tx.hdrlen = ieee80211_padded_hdrlen(&tx.local->hw, hdr->frame_control);
 
 	if (ieee80211_tx_h_select_key(&tx) != TX_CONTINUE) {
 		rcu_read_unlock();
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index 3deaa01..5a1c923 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -240,6 +240,99 @@ __le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,
 }
 EXPORT_SYMBOL(ieee80211_ctstoself_duration);
 
+static void __ieee80211_wake_txqs(struct ieee80211_sub_if_data *sdata, int ac)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_vif *vif = &sdata->vif;
+	struct fq *fq = &local->fq;
+	struct ps_data *ps = NULL;
+	struct txq_info *txqi;
+	struct sta_info *sta;
+	int i;
+
+	spin_lock_bh(&fq->lock);
+
+	if (sdata->vif.type == NL80211_IFTYPE_AP)
+		ps = &sdata->bss->ps;
+
+	sdata->vif.txqs_stopped[ac] = false;
+
+	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+		if (sdata != sta->sdata)
+			continue;
+
+		for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
+			struct ieee80211_txq *txq = sta->sta.txq[i];
+
+			txqi = to_txq_info(txq);
+
+			if (ac != txq->ac)
+				continue;
+
+			if (!test_and_clear_bit(IEEE80211_TXQ_STOP_NETIF_TX,
+						&txqi->flags))
+				continue;
+
+			spin_unlock_bh(&fq->lock);
+			drv_wake_tx_queue(local, txqi);
+			spin_lock_bh(&fq->lock);
+		}
+	}
+
+	if (!vif->txq)
+		goto out;
+
+	txqi = to_txq_info(vif->txq);
+
+	if (!test_and_clear_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags) ||
+	    (ps && atomic_read(&ps->num_sta_ps)) || ac != vif->txq->ac)
+		goto out;
+
+	spin_unlock_bh(&fq->lock);
+
+	drv_wake_tx_queue(local, txqi);
+	return;
+out:
+	spin_unlock_bh(&fq->lock);
+}
+
+void ieee80211_wake_txqs(unsigned long data)
+{
+	struct ieee80211_local *local = (struct ieee80211_local *)data;
+	struct ieee80211_sub_if_data *sdata;
+	int n_acs = IEEE80211_NUM_ACS;
+	unsigned long flags;
+	int i;
+
+	rcu_read_lock();
+	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+
+	if (local->hw.queues < IEEE80211_NUM_ACS)
+		n_acs = 1;
+
+	for (i = 0; i < local->hw.queues; i++) {
+		if (local->queue_stop_reasons[i])
+			continue;
+
+		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+		list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+			int ac;
+
+			for (ac = 0; ac < n_acs; ac++) {
+				int ac_queue = sdata->vif.hw_queue[ac];
+
+				if (ac_queue == i ||
+				    sdata->vif.cab_queue == i)
+					__ieee80211_wake_txqs(sdata, ac);
+			}
+		}
+		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
+	}
+
+	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
+	rcu_read_unlock();
+}
+
 void ieee80211_propagate_queue_wake(struct ieee80211_local *local, int queue)
 {
 	struct ieee80211_sub_if_data *sdata;
@@ -308,6 +401,9 @@ static void __ieee80211_wake_queue(struct ieee80211_hw *hw, int queue,
 		rcu_read_unlock();
 	} else
 		tasklet_schedule(&local->tx_pending_tasklet);
+
+	if (local->ops->wake_tx_queue)
+		tasklet_schedule(&local->wake_txqs_tasklet);
 }
 
 void ieee80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,
@@ -351,9 +447,6 @@ static void __ieee80211_stop_queue(struct ieee80211_hw *hw, int queue,
 	if (__test_and_set_bit(reason, &local->queue_stop_reasons[queue]))
 		return;
 
-	if (local->ops->wake_tx_queue)
-		return;
-
 	if (local->hw.queues < IEEE80211_NUM_ACS)
 		n_acs = 1;
 
@@ -366,8 +459,15 @@ static void __ieee80211_stop_queue(struct ieee80211_hw *hw, int queue,
 
 		for (ac = 0; ac < n_acs; ac++) {
 			if (sdata->vif.hw_queue[ac] == queue ||
-			    sdata->vif.cab_queue == queue)
-				netif_stop_subqueue(sdata->dev, ac);
+			    sdata->vif.cab_queue == queue) {
+				if (!local->ops->wake_tx_queue) {
+					netif_stop_subqueue(sdata->dev, ac);
+					continue;
+				}
+				spin_lock(&local->fq.lock);
+				sdata->vif.txqs_stopped[ac] = true;
+				spin_unlock(&local->fq.lock);
+			}
 		}
 	}
 	rcu_read_unlock();
@@ -1290,6 +1390,7 @@ void ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_local *local = sdata->local;
 	struct sk_buff *skb;
 	struct ieee80211_mgmt *mgmt;
+	unsigned int hdrlen;
 	int err;
 
 	/* 24 + 6 = header + auth_algo + auth_transaction + status_code */
@@ -1313,8 +1414,10 @@ void ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,
 		skb_put_data(skb, extra, extra_len);
 
 	if (auth_alg == WLAN_AUTH_SHARED_KEY && transaction == 3) {
+		hdrlen = ieee80211_hdrlen(mgmt->frame_control);
 		mgmt->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
-		err = ieee80211_wep_encrypt(local, skb, key, key_len, key_idx);
+		err = ieee80211_wep_encrypt(local, skb, hdrlen, key,
+					    key_len, key_idx);
 		WARN_ON(err);
 	}
 
@@ -3523,7 +3626,9 @@ int ieee80211_check_combinations(struct ieee80211_sub_if_data *sdata,
 	}
 
 	/* Always allow software iftypes */
-	if (local->hw.wiphy->software_iftypes & BIT(iftype)) {
+	if (local->hw.wiphy->software_iftypes & BIT(iftype) ||
+	    (iftype == NL80211_IFTYPE_AP_VLAN &&
+	     local->hw.wiphy->flags & WIPHY_FLAG_4ADDR_AP)) {
 		if (radar_detect)
 			return -EINVAL;
 		return 0;
diff --git a/net/mac80211/wep.c b/net/mac80211/wep.c
index 73e8f34..478b54f 100644
--- a/net/mac80211/wep.c
+++ b/net/mac80211/wep.c
@@ -89,11 +89,11 @@ static void ieee80211_wep_get_iv(struct ieee80211_local *local,
 
 static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,
 				struct sk_buff *skb,
+				unsigned int hdrlen,
 				int keylen, int keyidx)
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	unsigned int hdrlen;
 	u8 *newhdr;
 
 	hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
@@ -101,7 +101,6 @@ static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,
 	if (WARN_ON(skb_headroom(skb) < IEEE80211_WEP_IV_LEN))
 		return NULL;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
 	newhdr = skb_push(skb, IEEE80211_WEP_IV_LEN);
 	memmove(newhdr, newhdr + IEEE80211_WEP_IV_LEN, hdrlen);
 
@@ -160,6 +159,7 @@ int ieee80211_wep_encrypt_data(struct crypto_cipher *tfm, u8 *rc4key,
  */
 int ieee80211_wep_encrypt(struct ieee80211_local *local,
 			  struct sk_buff *skb,
+			  unsigned int hdrlen,
 			  const u8 *key, int keylen, int keyidx)
 {
 	u8 *iv;
@@ -169,7 +169,7 @@ int ieee80211_wep_encrypt(struct ieee80211_local *local,
 	if (WARN_ON(skb_tailroom(skb) < IEEE80211_WEP_ICV_LEN))
 		return -1;
 
-	iv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);
+	iv = ieee80211_wep_add_iv(local, skb, hdrlen, keylen, keyidx);
 	if (!iv)
 		return -1;
 
@@ -307,13 +307,14 @@ static int wep_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
 	struct ieee80211_key_conf *hw_key = info->control.hw_key;
 
 	if (!hw_key) {
-		if (ieee80211_wep_encrypt(tx->local, skb, tx->key->conf.key,
+		if (ieee80211_wep_encrypt(tx->local, skb, tx->hdrlen,
+					  tx->key->conf.key,
 					  tx->key->conf.keylen,
 					  tx->key->conf.keyidx))
 			return -1;
 	} else if ((hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) ||
 		   (hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE)) {
-		if (!ieee80211_wep_add_iv(tx->local, skb,
+		if (!ieee80211_wep_add_iv(tx->local, skb, tx->hdrlen,
 					  tx->key->conf.keylen,
 					  tx->key->conf.keyidx))
 			return -1;
diff --git a/net/mac80211/wep.h b/net/mac80211/wep.h
index 9615749..ad0a52b 100644
--- a/net/mac80211/wep.h
+++ b/net/mac80211/wep.h
@@ -22,6 +22,7 @@ int ieee80211_wep_encrypt_data(struct crypto_cipher *tfm, u8 *rc4key,
 				size_t klen, u8 *data, size_t data_len);
 int ieee80211_wep_encrypt(struct ieee80211_local *local,
 			  struct sk_buff *skb,
+			  unsigned int hdrlen,
 			  const u8 *key, int keylen, int keyidx);
 int ieee80211_wep_decrypt_data(struct crypto_cipher *tfm, u8 *rc4key,
 			       size_t klen, u8 *data, size_t data_len);
diff --git a/net/mac80211/wme.c b/net/mac80211/wme.c
index 54eb635..6a31878 100644
--- a/net/mac80211/wme.c
+++ b/net/mac80211/wme.c
@@ -141,6 +141,42 @@ u16 ieee80211_select_queue_80211(struct ieee80211_sub_if_data *sdata,
 	return ieee80211_downgrade_queue(sdata, NULL, skb);
 }
 
+u16 __ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
+			     struct sta_info *sta, struct sk_buff *skb)
+{
+	struct mac80211_qos_map *qos_map;
+	bool qos;
+
+	/* all mesh/ocb stations are required to support WME */
+	if (sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||
+	    sdata->vif.type == NL80211_IFTYPE_OCB)
+		qos = true;
+	else if (sta)
+		qos = sta->sta.wme;
+	else
+		qos = false;
+
+	if (!qos) {
+		skb->priority = 0; /* required for correct WPA/11i MIC */
+		return IEEE80211_AC_BE;
+	}
+
+	if (skb->protocol == sdata->control_port_protocol) {
+		skb->priority = 7;
+		goto downgrade;
+	}
+
+	/* use the data classifier to determine what 802.1d tag the
+	 * data frame has */
+	qos_map = rcu_dereference(sdata->qos_map);
+	skb->priority = cfg80211_classify8021d(skb, qos_map ?
+					       &qos_map->qos_map : NULL);
+
+ downgrade:
+	return ieee80211_downgrade_queue(sdata, sta, skb);
+}
+
+
 /* Indicate which queue to use. */
 u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
 			   struct sk_buff *skb)
@@ -148,10 +184,12 @@ u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_local *local = sdata->local;
 	struct sta_info *sta = NULL;
 	const u8 *ra = NULL;
-	bool qos = false;
-	struct mac80211_qos_map *qos_map;
 	u16 ret;
 
+	/* when using iTXQ, we can do this later */
+	if (local->ops->wake_tx_queue)
+		return 0;
+
 	if (local->hw.queues < IEEE80211_NUM_ACS || skb->len < 6) {
 		skb->priority = 0; /* required for correct WPA/11i MIC */
 		return 0;
@@ -161,10 +199,8 @@ u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
 	switch (sdata->vif.type) {
 	case NL80211_IFTYPE_AP_VLAN:
 		sta = rcu_dereference(sdata->u.vlan.sta);
-		if (sta) {
-			qos = sta->sta.wme;
+		if (sta)
 			break;
-		}
 		/* fall through */
 	case NL80211_IFTYPE_AP:
 		ra = skb->data;
@@ -172,56 +208,26 @@ u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
 	case NL80211_IFTYPE_WDS:
 		ra = sdata->u.wds.remote_addr;
 		break;
-#ifdef CPTCFG_MAC80211_MESH
-	case NL80211_IFTYPE_MESH_POINT:
-		qos = true;
-		break;
-#endif
 	case NL80211_IFTYPE_STATION:
 		/* might be a TDLS station */
 		sta = sta_info_get(sdata, skb->data);
 		if (sta)
-			qos = sta->sta.wme;
+			break;
 
 		ra = sdata->u.mgd.bssid;
 		break;
 	case NL80211_IFTYPE_ADHOC:
 		ra = skb->data;
 		break;
-	case NL80211_IFTYPE_OCB:
-		/* all stations are required to support WME */
-		qos = true;
-		break;
 	default:
 		break;
 	}
 
-	if (!sta && ra && !is_multicast_ether_addr(ra)) {
+	if (!sta && ra && !is_multicast_ether_addr(ra))
 		sta = sta_info_get(sdata, ra);
-		if (sta)
-			qos = sta->sta.wme;
-	}
 
-	if (!qos) {
-		skb->priority = 0; /* required for correct WPA/11i MIC */
-		ret = IEEE80211_AC_BE;
-		goto out;
-	}
+	ret = __ieee80211_select_queue(sdata, sta, skb);
 
-	if (skb->protocol == sdata->control_port_protocol) {
-		skb->priority = 7;
-		goto downgrade;
-	}
-
-	/* use the data classifier to determine what 802.1d tag the
-	 * data frame has */
-	qos_map = rcu_dereference(sdata->qos_map);
-	skb->priority = cfg80211_classify8021d(skb, qos_map ?
-					       &qos_map->qos_map : NULL);
-
- downgrade:
-	ret = ieee80211_downgrade_queue(sdata, sta, skb);
- out:
 	rcu_read_unlock();
 	return ret;
 }
diff --git a/net/mac80211/wme.h b/net/mac80211/wme.h
index 80151ed..b1b1439 100644
--- a/net/mac80211/wme.h
+++ b/net/mac80211/wme.h
@@ -16,6 +16,8 @@
 u16 ieee80211_select_queue_80211(struct ieee80211_sub_if_data *sdata,
 				 struct sk_buff *skb,
 				 struct ieee80211_hdr *hdr);
+u16 __ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
+			     struct sta_info *sta, struct sk_buff *skb);
 u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
 			   struct sk_buff *skb);
 void ieee80211_set_qos_hdr(struct ieee80211_sub_if_data *sdata,
diff --git a/net/mac80211/wpa.c b/net/mac80211/wpa.c
index 58d0b25..309845e 100644
--- a/net/mac80211/wpa.c
+++ b/net/mac80211/wpa.c
@@ -44,7 +44,7 @@ ieee80211_tx_h_michael_mic_add(struct ieee80211_tx_data *tx)
 	    skb->len < 24 || !ieee80211_is_data_present(hdr->frame_control))
 		return TX_CONTINUE;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = tx->hdrlen;
 	if (skb->len < hdrlen)
 		return TX_DROP;
 
@@ -195,7 +195,6 @@ mic_fail_no_key:
 
 static int tkip_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
 {
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
 	struct ieee80211_key *key = tx->key;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	unsigned int hdrlen;
@@ -210,7 +209,7 @@ static int tkip_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
 		return 0;
 	}
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = tx->hdrlen;
 	len = skb->len - hdrlen;
 
 	if (info->control.hw_key)
@@ -314,7 +313,8 @@ ieee80211_crypto_tkip_decrypt(struct ieee80211_rx_data *rx)
 }
 
 
-static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad)
+static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad,
+				u16 data_len)
 {
 	__le16 mask_fc;
 	int a4_included, mgmt;
@@ -344,14 +344,8 @@ static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad)
 	else
 		qos_tid = 0;
 
-	/* In CCM, the initial vectors (IV) used for CTR mode encryption and CBC
-	 * mode authentication are not allowed to collide, yet both are derived
-	 * from this vector b_0. We only set L := 1 here to indicate that the
-	 * data size can be represented in (L+1) bytes. The CCM layer will take
-	 * care of storing the data length in the top (L+1) bytes and setting
-	 * and clearing the other bits as is required to derive the two IVs.
-	 */
-	b_0[0] = 0x1;
+	/* First block, b_0 */
+	b_0[0] = 0x59; /* flags: Adata: 1, M: 011, L: 001 */
 
 	/* Nonce: Nonce Flags | A2 | PN
 	 * Nonce Flags: Priority (b0..b3) | Management (b4) | Reserved (b5..b7)
@@ -359,6 +353,8 @@ static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad)
 	b_0[1] = qos_tid | (mgmt << 4);
 	memcpy(&b_0[2], hdr->addr2, ETH_ALEN);
 	memcpy(&b_0[8], pn, IEEE80211_CCMP_PN_LEN);
+	/* l(m) */
+	put_unaligned_be16(data_len, &b_0[14]);
 
 	/* AAD (extra authenticate-only data) / masked 802.11 header
 	 * FC | A1 | A2 | A3 | SC | [A4] | [QC] */
@@ -415,7 +411,7 @@ static int ccmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb,
 	u8 *pos;
 	u8 pn[6];
 	u64 pn64;
-	u8 aad[CCM_AAD_LEN];
+	u8 aad[2 * AES_BLOCK_SIZE];
 	u8 b_0[AES_BLOCK_SIZE];
 
 	if (info->control.hw_key &&
@@ -431,7 +427,7 @@ static int ccmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb,
 		return 0;
 	}
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = tx->hdrlen;
 	len = skb->len - hdrlen;
 
 	if (info->control.hw_key)
@@ -470,9 +466,11 @@ static int ccmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb,
 		return 0;
 
 	pos += IEEE80211_CCMP_HDR_LEN;
-	ccmp_special_blocks(skb, pn, b_0, aad);
-	return ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,
-					 skb_put(skb, mic_len));
+	ccmp_special_blocks(skb, pn, b_0, aad, len);
+	ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,
+				  skb_put(skb, mic_len), mic_len);
+
+	return 0;
 }
 
 
@@ -545,13 +543,13 @@ ieee80211_crypto_ccmp_decrypt(struct ieee80211_rx_data *rx,
 			u8 aad[2 * AES_BLOCK_SIZE];
 			u8 b_0[AES_BLOCK_SIZE];
 			/* hardware didn't decrypt/verify MIC */
-			ccmp_special_blocks(skb, pn, b_0, aad);
+			ccmp_special_blocks(skb, pn, b_0, aad, data_len);
 
 			if (ieee80211_aes_ccm_decrypt(
 				    key->u.ccmp.tfm, b_0, aad,
 				    skb->data + hdrlen + IEEE80211_CCMP_HDR_LEN,
 				    data_len,
-				    skb->data + skb->len - mic_len))
+				    skb->data + skb->len - mic_len, mic_len))
 				return RX_DROP_UNUSABLE;
 		}
 
@@ -646,7 +644,7 @@ static int gcmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
 	u8 *pos;
 	u8 pn[6];
 	u64 pn64;
-	u8 aad[GCM_AAD_LEN];
+	u8 aad[2 * AES_BLOCK_SIZE];
 	u8 j_0[AES_BLOCK_SIZE];
 
 	if (info->control.hw_key &&
@@ -661,7 +659,7 @@ static int gcmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
 		return 0;
 	}
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+	hdrlen = tx->hdrlen;
 	len = skb->len - hdrlen;
 
 	if (info->control.hw_key)
@@ -703,8 +701,10 @@ static int gcmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
 
 	pos += IEEE80211_GCMP_HDR_LEN;
 	gcmp_special_blocks(skb, pn, j_0, aad);
-	return ieee80211_aes_gcm_encrypt(key->u.gcmp.tfm, j_0, aad, pos, len,
-					 skb_put(skb, IEEE80211_GCMP_MIC_LEN));
+	ieee80211_aes_gcm_encrypt(key->u.gcmp.tfm, j_0, aad, pos, len,
+				  skb_put(skb, IEEE80211_GCMP_MIC_LEN));
+
+	return 0;
 }
 
 ieee80211_tx_result
@@ -799,7 +799,6 @@ static ieee80211_tx_result
 ieee80211_crypto_cs_encrypt(struct ieee80211_tx_data *tx,
 			    struct sk_buff *skb)
 {
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_key *key = tx->key;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	int hdrlen;
@@ -815,8 +814,7 @@ ieee80211_crypto_cs_encrypt(struct ieee80211_tx_data *tx,
 		     pskb_expand_head(skb, iv_len, 0, GFP_ATOMIC)))
 		return TX_DROP;
 
-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
-
+	hdrlen = tx->hdrlen;
 	pos = skb_push(skb, iv_len);
 	memmove(pos, pos + iv_len, hdrlen);
 
@@ -1127,9 +1125,9 @@ ieee80211_crypto_aes_gmac_encrypt(struct ieee80211_tx_data *tx)
 	struct ieee80211_key *key = tx->key;
 	struct ieee80211_mmie_16 *mmie;
 	struct ieee80211_hdr *hdr;
-	u8 aad[GMAC_AAD_LEN];
+	u8 aad[20];
 	u64 pn64;
-	u8 nonce[GMAC_NONCE_LEN];
+	u8 nonce[12];
 
 	if (WARN_ON(skb_queue_len(&tx->skbs) != 1))
 		return TX_DROP;
@@ -1175,7 +1173,7 @@ ieee80211_crypto_aes_gmac_decrypt(struct ieee80211_rx_data *rx)
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
 	struct ieee80211_key *key = rx->key;
 	struct ieee80211_mmie_16 *mmie;
-	u8 aad[GMAC_AAD_LEN], mic[GMAC_MIC_LEN], ipn[6], nonce[GMAC_NONCE_LEN];
+	u8 aad[20], mic[16], ipn[6], nonce[12];
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 
 	if (!ieee80211_is_mgmt(hdr->frame_control))
diff --git a/net/wireless/Kconfig b/net/wireless/Kconfig
index 6f08718..67a8452 100644
--- a/net/wireless/Kconfig
+++ b/net/wireless/Kconfig
@@ -185,7 +185,7 @@ config CFG80211_WEXT_EXPORT
 endif # CFG80211
 
 config LIB80211
-	tristate
+	tristate "lib80211"
 	depends on m
 	default n
 	help
@@ -195,15 +195,15 @@ config LIB80211
 	  Drivers should select this themselves if needed.
 
 config LIB80211_CRYPT_WEP
-	tristate
+	tristate "lib80211 WEP support"
 	depends on m
 
 config LIB80211_CRYPT_CCMP
-	tristate
+	tristate "lib80211 CCMP support"
 	depends on m
 
 config LIB80211_CRYPT_TKIP
-	tristate
+	tristate "lib80211 TKIP support"
 	depends on m
 
 config LIB80211_DEBUG
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 8abb01e..8af160d 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -1351,8 +1351,13 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
 		}
 		break;
 	case NETDEV_PRE_UP:
-		if (!(wdev->wiphy->interface_modes & BIT(wdev->iftype)))
-			return notifier_from_errno(-EOPNOTSUPP);
+		if (!(wdev->wiphy->interface_modes & BIT(wdev->iftype))) {
+			if (!(wdev->iftype == NL80211_IFTYPE_AP_VLAN &&
+			      rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP &&
+			      wdev->use_4addr))
+				return notifier_from_errno(-EOPNOTSUPP);
+		}
+
 		if (rfkill_blocked(rdev->rfkill))
 			return notifier_from_errno(-ERFKILL);
 		break;
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 1b14bf8..66d0ffb 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -430,6 +430,8 @@ static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
 	[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },
 	[NL80211_ATTR_HE_CAPABILITY] = { .type = NLA_BINARY,
 					 .len = NL80211_HE_MAX_CAPABILITY_LEN },
+	[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),
+	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
 };
 
 /* policy for the key attributes */
@@ -2588,6 +2590,20 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
 			return result;
 	}
 
+	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
+		int idx, dbi = 0;
+
+		if (!rdev->ops->set_antenna_gain)
+			return -EOPNOTSUPP;
+
+		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
+		dbi = nla_get_u32(info->attrs[idx]);
+
+		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
+		if (result)
+			return result;
+	}
+
 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
 		u32 tx_ant, rx_ant;
@@ -3193,8 +3209,7 @@ static int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
 			return -EINVAL;
 	}
 
-	if (!rdev->ops->add_virtual_intf ||
-	    !(rdev->wiphy.interface_modes & (1 << type)))
+	if (!rdev->ops->add_virtual_intf)
 		return -EOPNOTSUPP;
 
 	if ((type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN ||
@@ -3213,6 +3228,13 @@ static int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
 			return err;
 	}
 
+	if (!(rdev->wiphy.interface_modes & (1 << type))) {
+		if (!(type == NL80211_IFTYPE_AP_VLAN &&
+		      rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP &&
+		      params.use_4addr))
+			return -EOPNOTSUPP;
+	}
+
 	err = nl80211_parse_mon_options(rdev, type, info, &params);
 	if (err < 0)
 		return err;
@@ -4658,6 +4680,11 @@ static int nl80211_send_station(struct sk_buff *msg, u32 cmd, u32 portid,
 	PUT_SINFO(PLID, plid, u16);
 	PUT_SINFO(PLINK_STATE, plink_state, u8);
 	PUT_SINFO_U64(RX_DURATION, rx_duration);
+	PUT_SINFO_U64(TX_DURATION, tx_duration);
+
+	if (wiphy_ext_feature_isset(&rdev->wiphy,
+				    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
+		PUT_SINFO(AIRTIME_WEIGHT, airtime_weight, u16);
 
 	switch (rdev->wiphy.signal_type) {
 	case CFG80211_SIGNAL_TYPE_MBM:
@@ -5294,6 +5321,15 @@ static int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)
 			nla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);
 	}
 
+	if (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])
+		params.airtime_weight =
+			nla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);
+
+	if (params.airtime_weight &&
+	    !wiphy_ext_feature_isset(&rdev->wiphy,
+				     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
+		return -EOPNOTSUPP;
+
 	/* Include parameters for TDLS peer (will check later) */
 	err = nl80211_set_station_tdls(info, &params);
 	if (err)
@@ -5432,6 +5468,15 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
 			return -EINVAL;
 	}
 
+	if (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])
+		params.airtime_weight =
+			nla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);
+
+	if (params.airtime_weight &&
+	    !wiphy_ext_feature_isset(&rdev->wiphy,
+				     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
+		return -EOPNOTSUPP;
+
 	err = nl80211_parse_sta_channel_info(info, &params);
 	if (err)
 		return err;
diff --git a/net/wireless/reg.c b/net/wireless/reg.c
index a0a068e..036c7a0 100644
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -2982,6 +2982,8 @@ void regulatory_hint_country_ie(struct wiphy *wiphy, enum nl80211_band band,
 	enum environment_cap env = ENVIRON_ANY;
 	struct regulatory_request *request = NULL, *lr;
 
+	return;
+
 	/* IE len must be evenly divisible by 2 */
 	if (country_ie_len & 0x01)
 		return;
@@ -3188,6 +3190,7 @@ static void restore_regulatory_settings(bool reset_user)
 
 void regulatory_hint_disconnect(void)
 {
+	return;
 	pr_debug("All devices are disconnected, going to restore regulatory settings\n");
 	restore_regulatory_settings(false);
 }
diff --git a/net/wireless/sysfs.c b/net/wireless/sysfs.c
index ff967c2..8f13d0e 100644
--- a/net/wireless/sysfs.c
+++ b/net/wireless/sysfs.c
@@ -24,18 +24,35 @@ static inline struct cfg80211_registered_device *dev_to_rdev(
 	return container_of(dev, struct cfg80211_registered_device, wiphy.dev);
 }
 
-#define SHOW_FMT(name, fmt, member)					\
+#define SHOW_FMT(name, fmt, member, mode)				\
 static ssize_t name ## _show(struct device *dev,			\
 			      struct device_attribute *attr,		\
 			      char *buf)				\
 {									\
 	return sprintf(buf, fmt "\n", dev_to_rdev(dev)->member);	\
 }									\
-static DEVICE_ATTR_RO(name)
+static DEVICE_ATTR_##mode(name)
 
-SHOW_FMT(index, "%d", wiphy_idx);
-SHOW_FMT(macaddress, "%pM", wiphy.perm_addr);
-SHOW_FMT(address_mask, "%pM", wiphy.addr_mask);
+static ssize_t macaddress_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	u8 mac[ETH_ALEN];
+
+	if (!mac_pton(buf, mac))
+		return -EINVAL;
+
+	if (buf[3 * ETH_ALEN - 1] && buf[3 * ETH_ALEN - 1] != '\n')
+		return -EINVAL;
+
+	memcpy(dev_to_rdev(dev)->wiphy.perm_addr, mac, ETH_ALEN);
+
+	return strnlen(buf, len);
+}
+
+SHOW_FMT(index, "%d", wiphy_idx, RO);
+SHOW_FMT(macaddress, "%pM", wiphy.perm_addr, RW);
+SHOW_FMT(address_mask, "%pM", wiphy.addr_mask, RO);
 
 static ssize_t name_show(struct device *dev,
 			 struct device_attribute *attr,
-- 
2.20.1

